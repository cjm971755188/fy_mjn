"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class DentryModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createdTime: 'createdTime',
            creator: 'creator',
            dentryId: 'dentryId',
            dentryType: 'dentryType',
            dentryUuid: 'dentryUuid',
            docKey: 'docKey',
            extension: 'extension',
            hasChildren: 'hasChildren',
            linkSourceInfo: 'linkSourceInfo',
            name: 'name',
            path: 'path',
            space: 'space',
            spaceId: 'spaceId',
            statisticalInfo: 'statisticalInfo',
            updatedTime: 'updatedTime',
            updater: 'updater',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createdTime: 'number',
            creator: DentryModelCreator,
            dentryId: 'string',
            dentryType: 'string',
            dentryUuid: 'string',
            docKey: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            linkSourceInfo: LinkSourceInfo,
            name: 'string',
            path: 'string',
            space: SpaceModel,
            spaceId: 'string',
            statisticalInfo: DentryModelStatisticalInfo,
            updatedTime: 'number',
            updater: DentryModelUpdater,
            url: 'string',
            visitorInfo: DentryModelVisitorInfo,
        };
    }
}
exports.DentryModel = DentryModel;
class DentryVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentType: 'contentType',
            createdTime: 'createdTime',
            creator: 'creator',
            dentryId: 'dentryId',
            dentryType: 'dentryType',
            dentryUuid: 'dentryUuid',
            docKey: 'docKey',
            extension: 'extension',
            hasChildren: 'hasChildren',
            linkSourceInfo: 'linkSourceInfo',
            name: 'name',
            path: 'path',
            space: 'space',
            spaceId: 'spaceId',
            updatedTime: 'updatedTime',
            updater: 'updater',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            contentType: 'string',
            createdTime: 'number',
            creator: DentryVOCreator,
            dentryId: 'string',
            dentryType: 'string',
            dentryUuid: 'string',
            docKey: 'string',
            extension: 'string',
            hasChildren: 'boolean',
            linkSourceInfo: LinkSourceInfo,
            name: 'string',
            path: 'string',
            space: SpaceModel,
            spaceId: 'string',
            updatedTime: 'number',
            updater: DentryVOUpdater,
            url: 'string',
            visitorInfo: DentryVOVisitorInfo,
        };
    }
}
exports.DentryVO = DentryVO;
class LinkSourceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            iconUrl: 'iconUrl',
            id: 'id',
            linkType: 'linkType',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            extension: 'string',
            iconUrl: LinkSourceInfoIconUrl,
            id: 'string',
            linkType: 'number',
            spaceId: 'string',
        };
    }
}
exports.LinkSourceInfo = LinkSourceInfo;
class OpenActionModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            name: 'string',
            timestamp: 'number',
        };
    }
}
exports.OpenActionModel = OpenActionModel;
class SpaceModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            description: 'description',
            hdIconVO: 'hdIconVO',
            iconVO: 'iconVO',
            id: 'id',
            name: 'name',
            owner: 'owner',
            recentList: 'recentList',
            type: 'type',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            cover: 'string',
            description: 'string',
            hdIconVO: SpaceModelHdIconVO,
            iconVO: SpaceModelIconVO,
            id: 'string',
            name: 'string',
            owner: SpaceModelOwner,
            recentList: { 'type': 'array', 'itemType': DentryModel },
            type: 'number',
            url: 'string',
            visitorInfo: SpaceModelVisitorInfo,
        };
    }
}
exports.SpaceModel = SpaceModel;
class SpaceVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            description: 'description',
            iconVO: 'iconVO',
            id: 'id',
            name: 'name',
            owner: 'owner',
            type: 'type',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            cover: 'string',
            description: 'string',
            iconVO: SpaceVOIconVO,
            id: 'string',
            name: 'string',
            owner: SpaceVOOwner,
            type: 'number',
            url: 'string',
            visitorInfo: SpaceVOVisitorInfo,
        };
    }
}
exports.SpaceVO = SpaceVO;
class TeamModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            createdTime: 'createdTime',
            creator: 'creator',
            description: 'description',
            icon: 'icon',
            id: 'id',
            name: 'name',
            relatedDeptInfo: 'relatedDeptInfo',
            status: 'status',
            type: 'type',
            updatedTime: 'updatedTime',
            updater: 'updater',
            url: 'url',
            visitInfo: 'visitInfo',
        };
    }
    static types() {
        return {
            cover: 'string',
            createdTime: 'number',
            creator: TeamModelCreator,
            description: 'string',
            icon: 'string',
            id: 'string',
            name: 'string',
            relatedDeptInfo: TeamModelRelatedDeptInfo,
            status: 'number',
            type: 'number',
            updatedTime: 'number',
            updater: TeamModelUpdater,
            url: 'string',
            visitInfo: TeamModelVisitInfo,
        };
    }
}
exports.TeamModel = TeamModel;
class TeamVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            createdTime: 'createdTime',
            creator: 'creator',
            description: 'description',
            icon: 'icon',
            id: 'id',
            name: 'name',
            relatedDeptInfo: 'relatedDeptInfo',
            shareScopeInfo: 'shareScopeInfo',
            status: 'status',
            type: 'type',
            updatedTime: 'updatedTime',
            updater: 'updater',
            url: 'url',
            visitInfo: 'visitInfo',
        };
    }
    static types() {
        return {
            cover: 'string',
            createdTime: 'number',
            creator: TeamVOCreator,
            description: 'string',
            icon: 'string',
            id: 'string',
            name: 'string',
            relatedDeptInfo: TeamVORelatedDeptInfo,
            shareScopeInfo: TeamVOShareScopeInfo,
            status: 'number',
            type: 'number',
            updatedTime: 'number',
            updater: TeamVOUpdater,
            url: 'string',
            visitInfo: TeamVOVisitInfo,
        };
    }
}
exports.TeamVO = TeamVO;
class MapValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            templateId: 'templateId',
            title: 'title',
            type: 'type',
            coverDownloadUrl: 'coverDownloadUrl',
            description: 'description',
            authorName: 'authorName',
            createTime: 'createTime',
            modifiedTime: 'modifiedTime',
            workspaceId: 'workspaceId',
            workspaceName: 'workspaceName',
            usedCount: 'usedCount',
            belong: 'belong',
            contentDownloadUrl: 'contentDownloadUrl',
        };
    }
    static types() {
        return {
            templateId: 'string',
            title: 'string',
            type: 'number',
            coverDownloadUrl: 'string',
            description: 'string',
            authorName: 'string',
            createTime: 'string',
            modifiedTime: 'string',
            workspaceId: 'string',
            workspaceName: 'string',
            usedCount: 'number',
            belong: 'string',
            contentDownloadUrl: 'string',
        };
    }
}
exports.MapValue = MapValue;
class BatchCreateTeamHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchCreateTeamHeaders = BatchCreateTeamHeaders;
class BatchCreateTeamRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            param: 'param',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            param: BatchCreateTeamRequestParam,
            operatorId: 'string',
        };
    }
}
exports.BatchCreateTeamRequest = BatchCreateTeamRequest;
class BatchCreateTeamResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.BatchCreateTeamResponseBody = BatchCreateTeamResponseBody;
class BatchCreateTeamResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchCreateTeamResponseBody,
        };
    }
}
exports.BatchCreateTeamResponse = BatchCreateTeamResponse;
class BatchDeleteRecentsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchDeleteRecentsHeaders = BatchDeleteRecentsHeaders;
class BatchDeleteRecentsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryUuids: 'dentryUuids',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            dentryUuids: { 'type': 'array', 'itemType': 'string' },
            operatorId: 'string',
        };
    }
}
exports.BatchDeleteRecentsRequest = BatchDeleteRecentsRequest;
class BatchDeleteRecentsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.BatchDeleteRecentsResponseBody = BatchDeleteRecentsResponseBody;
class BatchDeleteRecentsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchDeleteRecentsResponseBody,
        };
    }
}
exports.BatchDeleteRecentsResponse = BatchDeleteRecentsResponse;
class CategoriesTemplatesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CategoriesTemplatesHeaders = CategoriesTemplatesHeaders;
class CategoriesTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            param: 'param',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: CategoriesTemplatesRequestOption,
            param: CategoriesTemplatesRequestParam,
            operatorId: 'string',
        };
    }
}
exports.CategoriesTemplatesRequest = CategoriesTemplatesRequest;
class CategoriesTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            map: 'map',
        };
    }
    static types() {
        return {
            map: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': MapValue } },
        };
    }
}
exports.CategoriesTemplatesResponseBody = CategoriesTemplatesResponseBody;
class CategoriesTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CategoriesTemplatesResponseBody,
        };
    }
}
exports.CategoriesTemplatesResponse = CategoriesTemplatesResponse;
class CategoryTemplatesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CategoryTemplatesHeaders = CategoryTemplatesHeaders;
class CategoryTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            param: 'param',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: CategoryTemplatesRequestOption,
            param: CategoryTemplatesRequestParam,
            operatorId: 'string',
        };
    }
}
exports.CategoryTemplatesRequest = CategoryTemplatesRequest;
class CategoryTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': CategoryTemplatesResponseBodyList },
        };
    }
}
exports.CategoryTemplatesResponseBody = CategoryTemplatesResponseBody;
class CategoryTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CategoryTemplatesResponseBody,
        };
    }
}
exports.CategoryTemplatesResponse = CategoryTemplatesResponse;
class CopyDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CopyDentryHeaders = CopyDentryHeaders;
class CopyDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            operatorId: 'operatorId',
            targetSpaceId: 'targetSpaceId',
            toNextDentryId: 'toNextDentryId',
            toParentDentryId: 'toParentDentryId',
            toPrevDentryId: 'toPrevDentryId',
        };
    }
    static types() {
        return {
            name: 'string',
            operatorId: 'string',
            targetSpaceId: 'string',
            toNextDentryId: 'string',
            toParentDentryId: 'string',
            toPrevDentryId: 'string',
        };
    }
}
exports.CopyDentryRequest = CopyDentryRequest;
class CopyDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DentryVO,
        };
    }
}
exports.CopyDentryResponse = CopyDentryResponse;
class CreateDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateDentryHeaders = CreateDentryHeaders;
class CreateDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryType: 'dentryType',
            documentType: 'documentType',
            name: 'name',
            operatorId: 'operatorId',
            parentDentryId: 'parentDentryId',
        };
    }
    static types() {
        return {
            dentryType: 'string',
            documentType: 'number',
            name: 'string',
            operatorId: 'string',
            parentDentryId: 'string',
        };
    }
}
exports.CreateDentryRequest = CreateDentryRequest;
class CreateDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DentryVO,
        };
    }
}
exports.CreateDentryResponse = CreateDentryResponse;
class CreateSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateSpaceHeaders = CreateSpaceHeaders;
class CreateSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            icon: 'icon',
            name: 'name',
            operatorId: 'operatorId',
            sectionId: 'sectionId',
            shareScope: 'shareScope',
            teamId: 'teamId',
        };
    }
    static types() {
        return {
            description: 'string',
            icon: 'string',
            name: 'string',
            operatorId: 'string',
            sectionId: 'string',
            shareScope: CreateSpaceRequestShareScope,
            teamId: 'string',
        };
    }
}
exports.CreateSpaceRequest = CreateSpaceRequest;
class CreateSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SpaceVO,
        };
    }
}
exports.CreateSpaceResponse = CreateSpaceResponse;
class CreateTeamHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateTeamHeaders = CreateTeamHeaders;
class CreateTeamRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            description: 'description',
            icon: 'icon',
            members: 'members',
            name: 'name',
            operatorId: 'operatorId',
            teamType: 'teamType',
        };
    }
    static types() {
        return {
            cover: 'string',
            description: 'string',
            icon: 'string',
            members: { 'type': 'array', 'itemType': CreateTeamRequestMembers },
            name: 'string',
            operatorId: 'string',
            teamType: 'number',
        };
    }
}
exports.CreateTeamRequest = CreateTeamRequest;
class CreateTeamResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TeamVO,
        };
    }
}
exports.CreateTeamResponse = CreateTeamResponse;
class CrossOrgMigrateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CrossOrgMigrateHeaders = CrossOrgMigrateHeaders;
class CrossOrgMigrateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            param: 'param',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: CrossOrgMigrateRequestOption,
            param: CrossOrgMigrateRequestParam,
            operatorId: 'string',
        };
    }
}
exports.CrossOrgMigrateRequest = CrossOrgMigrateRequest;
class CrossOrgMigrateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.CrossOrgMigrateResponseBody = CrossOrgMigrateResponseBody;
class CrossOrgMigrateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CrossOrgMigrateResponseBody,
        };
    }
}
exports.CrossOrgMigrateResponse = CrossOrgMigrateResponse;
class DeleteTeamHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteTeamHeaders = DeleteTeamHeaders;
class DeleteTeamRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.DeleteTeamRequest = DeleteTeamRequest;
class DeleteTeamResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TeamVO,
        };
    }
}
exports.DeleteTeamResponse = DeleteTeamResponse;
class DocContentHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DocContentHeaders = DocContentHeaders;
class DocContentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: DocContentRequestOption,
            operatorId: 'string',
        };
    }
}
exports.DocContentRequest = DocContentRequest;
class DocContentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            taskId: 'number',
        };
    }
}
exports.DocContentResponseBody = DocContentResponseBody;
class DocContentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DocContentResponseBody,
        };
    }
}
exports.DocContentResponse = DocContentResponse;
class GetDocContentHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetDocContentHeaders = GetDocContentHeaders;
class GetDocContentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetFormat: 'targetFormat',
        };
    }
    static types() {
        return {
            targetFormat: 'string',
        };
    }
}
exports.GetDocContentRequest = GetDocContentRequest;
class GetDocContentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            taskId: 'number',
        };
    }
}
exports.GetDocContentResponseBody = GetDocContentResponseBody;
class GetDocContentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDocContentResponseBody,
        };
    }
}
exports.GetDocContentResponse = GetDocContentResponse;
class GetSchemaHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSchemaHeaders = GetSchemaHeaders;
class GetSchemaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.GetSchemaRequest = GetSchemaRequest;
class GetSchemaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            revision: 'revision',
            value: 'value',
        };
    }
    static types() {
        return {
            revision: 'number',
            value: 'string',
        };
    }
}
exports.GetSchemaResponseBody = GetSchemaResponseBody;
class GetSchemaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSchemaResponseBody,
        };
    }
}
exports.GetSchemaResponse = GetSchemaResponse;
class GetSpaceDirectoriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSpaceDirectoriesHeaders = GetSpaceDirectoriesHeaders;
class GetSpaceDirectoriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryId: 'dentryId',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            dentryId: 'string',
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
        };
    }
}
exports.GetSpaceDirectoriesRequest = GetSpaceDirectoriesRequest;
class GetSpaceDirectoriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            children: 'children',
            hasMore: 'hasMore',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            children: { 'type': 'array', 'itemType': DentryModel },
            hasMore: 'boolean',
            nextToken: 'string',
        };
    }
}
exports.GetSpaceDirectoriesResponseBody = GetSpaceDirectoriesResponseBody;
class GetSpaceDirectoriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSpaceDirectoriesResponseBody,
        };
    }
}
exports.GetSpaceDirectoriesResponse = GetSpaceDirectoriesResponse;
class GetStarInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetStarInfoHeaders = GetStarInfoHeaders;
class GetStarInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.GetStarInfoRequest = GetStarInfoRequest;
class GetStarInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            starred: 'starred',
        };
    }
    static types() {
        return {
            starred: 'boolean',
        };
    }
}
exports.GetStarInfoResponseBody = GetStarInfoResponseBody;
class GetStarInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetStarInfoResponseBody,
        };
    }
}
exports.GetStarInfoResponse = GetStarInfoResponse;
class GetTeamHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetTeamHeaders = GetTeamHeaders;
class GetTeamRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.GetTeamRequest = GetTeamRequest;
class GetTeamResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TeamVO,
        };
    }
}
exports.GetTeamResponse = GetTeamResponse;
class GetTotalNumberOfDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetTotalNumberOfDentriesHeaders = GetTotalNumberOfDentriesHeaders;
class GetTotalNumberOfDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            includeFolder: 'includeFolder',
            operatorId: 'operatorId',
            spaceTypes: 'spaceTypes',
        };
    }
    static types() {
        return {
            includeFolder: 'boolean',
            operatorId: 'string',
            spaceTypes: 'string',
        };
    }
}
exports.GetTotalNumberOfDentriesRequest = GetTotalNumberOfDentriesRequest;
class GetTotalNumberOfDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentriesCount: 'dentriesCount',
        };
    }
    static types() {
        return {
            dentriesCount: 'string',
        };
    }
}
exports.GetTotalNumberOfDentriesResponseBody = GetTotalNumberOfDentriesResponseBody;
class GetTotalNumberOfDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTotalNumberOfDentriesResponseBody,
        };
    }
}
exports.GetTotalNumberOfDentriesResponse = GetTotalNumberOfDentriesResponse;
class GetTotalNumberOfSpacesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetTotalNumberOfSpacesHeaders = GetTotalNumberOfSpacesHeaders;
class GetTotalNumberOfSpacesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.GetTotalNumberOfSpacesRequest = GetTotalNumberOfSpacesRequest;
class GetTotalNumberOfSpacesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            spacesCount: 'spacesCount',
        };
    }
    static types() {
        return {
            spacesCount: 'string',
        };
    }
}
exports.GetTotalNumberOfSpacesResponseBody = GetTotalNumberOfSpacesResponseBody;
class GetTotalNumberOfSpacesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTotalNumberOfSpacesResponseBody,
        };
    }
}
exports.GetTotalNumberOfSpacesResponse = GetTotalNumberOfSpacesResponse;
class GetUserInfoByOpenTokenHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetUserInfoByOpenTokenHeaders = GetUserInfoByOpenTokenHeaders;
class GetUserInfoByOpenTokenRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            docKey: 'docKey',
            openToken: 'openToken',
        };
    }
    static types() {
        return {
            docKey: 'string',
            openToken: 'string',
        };
    }
}
exports.GetUserInfoByOpenTokenRequest = GetUserInfoByOpenTokenRequest;
class GetUserInfoByOpenTokenResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            unionId: 'string',
            userId: 'string',
        };
    }
}
exports.GetUserInfoByOpenTokenResponseBody = GetUserInfoByOpenTokenResponseBody;
class GetUserInfoByOpenTokenResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserInfoByOpenTokenResponseBody,
        };
    }
}
exports.GetUserInfoByOpenTokenResponse = GetUserInfoByOpenTokenResponse;
class ListFeedsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListFeedsHeaders = ListFeedsHeaders;
class ListFeedsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            excludeFile: 'excludeFile',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            excludeFile: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
        };
    }
}
exports.ListFeedsRequest = ListFeedsRequest;
class ListFeedsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': ListFeedsResponseBodyItems },
            nextToken: 'string',
        };
    }
}
exports.ListFeedsResponseBody = ListFeedsResponseBody;
class ListFeedsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListFeedsResponseBody,
        };
    }
}
exports.ListFeedsResponse = ListFeedsResponse;
class ListHotDocsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListHotDocsHeaders = ListHotDocsHeaders;
class ListHotDocsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.ListHotDocsRequest = ListHotDocsRequest;
class ListHotDocsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': DentryModel },
        };
    }
}
exports.ListHotDocsResponseBody = ListHotDocsResponseBody;
class ListHotDocsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListHotDocsResponseBody,
        };
    }
}
exports.ListHotDocsResponse = ListHotDocsResponse;
class ListPinSpacesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListPinSpacesHeaders = ListPinSpacesHeaders;
class ListPinSpacesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: ListPinSpacesRequestOption,
            operatorId: 'string',
        };
    }
}
exports.ListPinSpacesRequest = ListPinSpacesRequest;
class ListPinSpacesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            resultItems: 'resultItems',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            resultItems: { 'type': 'array', 'itemType': ListPinSpacesResponseBodyResultItems },
        };
    }
}
exports.ListPinSpacesResponseBody = ListPinSpacesResponseBody;
class ListPinSpacesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListPinSpacesResponseBody,
        };
    }
}
exports.ListPinSpacesResponse = ListPinSpacesResponse;
class ListRelatedSpaceTeamsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListRelatedSpaceTeamsHeaders = ListRelatedSpaceTeamsHeaders;
class ListRelatedSpaceTeamsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
            type: 'type',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            type: 'number',
        };
    }
}
exports.ListRelatedSpaceTeamsRequest = ListRelatedSpaceTeamsRequest;
class ListRelatedSpaceTeamsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': TeamModel },
        };
    }
}
exports.ListRelatedSpaceTeamsResponseBody = ListRelatedSpaceTeamsResponseBody;
class ListRelatedSpaceTeamsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListRelatedSpaceTeamsResponseBody,
        };
    }
}
exports.ListRelatedSpaceTeamsResponse = ListRelatedSpaceTeamsResponse;
class ListRelatedTeamsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListRelatedTeamsHeaders = ListRelatedTeamsHeaders;
class ListRelatedTeamsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            type: 'type',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            type: 'number',
        };
    }
}
exports.ListRelatedTeamsRequest = ListRelatedTeamsRequest;
class ListRelatedTeamsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': TeamModel },
            nextToken: 'string',
        };
    }
}
exports.ListRelatedTeamsResponseBody = ListRelatedTeamsResponseBody;
class ListRelatedTeamsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListRelatedTeamsResponseBody,
        };
    }
}
exports.ListRelatedTeamsResponse = ListRelatedTeamsResponse;
class ListSpaceSectionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListSpaceSectionsHeaders = ListSpaceSectionsHeaders;
class ListSpaceSectionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.ListSpaceSectionsRequest = ListSpaceSectionsRequest;
class ListSpaceSectionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': ListSpaceSectionsResponseBodyItems },
        };
    }
}
exports.ListSpaceSectionsResponseBody = ListSpaceSectionsResponseBody;
class ListSpaceSectionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListSpaceSectionsResponseBody,
        };
    }
}
exports.ListSpaceSectionsResponse = ListSpaceSectionsResponse;
class ListStarsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListStarsHeaders = ListStarsHeaders;
class ListStarsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: ListStarsRequestOption,
            operatorId: 'string',
        };
    }
}
exports.ListStarsRequest = ListStarsRequest;
class ListStarsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            starList: 'starList',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            starList: { 'type': 'array', 'itemType': ListStarsResponseBodyStarList },
        };
    }
}
exports.ListStarsResponseBody = ListStarsResponseBody;
class ListStarsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListStarsResponseBody,
        };
    }
}
exports.ListStarsResponse = ListStarsResponse;
class ListTeamMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListTeamMembersHeaders = ListTeamMembersHeaders;
class ListTeamMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.ListTeamMembersRequest = ListTeamMembersRequest;
class ListTeamMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            teamName: 'teamName',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': ListTeamMembersResponseBodyMembers },
            teamName: 'string',
        };
    }
}
exports.ListTeamMembersResponseBody = ListTeamMembersResponseBody;
class ListTeamMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListTeamMembersResponseBody,
        };
    }
}
exports.ListTeamMembersResponse = ListTeamMembersResponse;
class MarkStarHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MarkStarHeaders = MarkStarHeaders;
class MarkStarRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.MarkStarRequest = MarkStarRequest;
class MarkStarResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.MarkStarResponseBody = MarkStarResponseBody;
class MarkStarResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MarkStarResponseBody,
        };
    }
}
exports.MarkStarResponse = MarkStarResponse;
class MoveDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MoveDentryHeaders = MoveDentryHeaders;
class MoveDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
            targetSpaceId: 'targetSpaceId',
            toNextDentryId: 'toNextDentryId',
            toParentDentryId: 'toParentDentryId',
            toPrevDentryId: 'toPrevDentryId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            targetSpaceId: 'string',
            toNextDentryId: 'string',
            toParentDentryId: 'string',
            toPrevDentryId: 'string',
        };
    }
}
exports.MoveDentryRequest = MoveDentryRequest;
class MoveDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DentryVO,
        };
    }
}
exports.MoveDentryResponse = MoveDentryResponse;
class PinSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PinSpaceHeaders = PinSpaceHeaders;
class PinSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.PinSpaceRequest = PinSpaceRequest;
class PinSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.PinSpaceResponseBody = PinSpaceResponseBody;
class PinSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PinSpaceResponseBody,
        };
    }
}
exports.PinSpaceResponse = PinSpaceResponse;
class QueryDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryDentryHeaders = QueryDentryHeaders;
class QueryDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            includeSpace: 'includeSpace',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            includeSpace: 'boolean',
            operatorId: 'string',
        };
    }
}
exports.QueryDentryRequest = QueryDentryRequest;
class QueryDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DentryVO,
        };
    }
}
exports.QueryDentryResponse = QueryDentryResponse;
class QueryDocContentHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryDocContentHeaders = QueryDocContentHeaders;
class QueryDocContentRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
            targetFormat: 'targetFormat',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            targetFormat: 'string',
        };
    }
}
exports.QueryDocContentRequest = QueryDocContentRequest;
class QueryDocContentResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            taskId: 'number',
        };
    }
}
exports.QueryDocContentResponseBody = QueryDocContentResponseBody;
class QueryDocContentResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDocContentResponseBody,
        };
    }
}
exports.QueryDocContentResponse = QueryDocContentResponse;
class QueryItemByUrlHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryItemByUrlHeaders = QueryItemByUrlHeaders;
class QueryItemByUrlRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
            url: 'url',
            withStatisticalInfo: 'withStatisticalInfo',
        };
    }
    static types() {
        return {
            operatorId: 'string',
            url: 'string',
            withStatisticalInfo: 'boolean',
        };
    }
}
exports.QueryItemByUrlRequest = QueryItemByUrlRequest;
class QueryItemByUrlResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            dentry: 'dentry',
            resourceType: 'resourceType',
            space: 'space',
        };
    }
    static types() {
        return {
            bizType: 'string',
            dentry: DentryModel,
            resourceType: 'string',
            space: QueryItemByUrlResponseBodySpace,
        };
    }
}
exports.QueryItemByUrlResponseBody = QueryItemByUrlResponseBody;
class QueryItemByUrlResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryItemByUrlResponseBody,
        };
    }
}
exports.QueryItemByUrlResponse = QueryItemByUrlResponse;
class QueryMineSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryMineSpaceHeaders = QueryMineSpaceHeaders;
class QueryMineSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SpaceVO,
        };
    }
}
exports.QueryMineSpaceResponse = QueryMineSpaceResponse;
class QueryRecentListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryRecentListHeaders = QueryRecentListHeaders;
class QueryRecentListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorType: 'creatorType',
            fileType: 'fileType',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            recentType: 'recentType',
        };
    }
    static types() {
        return {
            creatorType: 'number',
            fileType: 'number',
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            recentType: 'number',
        };
    }
}
exports.QueryRecentListRequest = QueryRecentListRequest;
class QueryRecentListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            recentList: 'recentList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            recentList: { 'type': 'array', 'itemType': QueryRecentListResponseBodyRecentList },
        };
    }
}
exports.QueryRecentListResponseBody = QueryRecentListResponseBody;
class QueryRecentListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRecentListResponseBody,
        };
    }
}
exports.QueryRecentListResponse = QueryRecentListResponse;
class QuerySpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QuerySpaceHeaders = QuerySpaceHeaders;
class QuerySpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.QuerySpaceRequest = QuerySpaceRequest;
class QuerySpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SpaceVO,
        };
    }
}
exports.QuerySpaceResponse = QuerySpaceResponse;
class RelatedSpacesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RelatedSpacesHeaders = RelatedSpacesHeaders;
class RelatedSpacesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorId: 'operatorId',
            teamId: 'teamId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            operatorId: 'string',
            teamId: 'string',
        };
    }
}
exports.RelatedSpacesRequest = RelatedSpacesRequest;
class RelatedSpacesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': RelatedSpacesResponseBodyItems },
            nextToken: 'string',
        };
    }
}
exports.RelatedSpacesResponseBody = RelatedSpacesResponseBody;
class RelatedSpacesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RelatedSpacesResponseBody,
        };
    }
}
exports.RelatedSpacesResponse = RelatedSpacesResponse;
class RemoveTeamMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RemoveTeamMembersHeaders = RemoveTeamMembersHeaders;
class RemoveTeamMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            notify: 'notify',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': RemoveTeamMembersRequestMembers },
            notify: 'boolean',
            operatorId: 'string',
        };
    }
}
exports.RemoveTeamMembersRequest = RemoveTeamMembersRequest;
class RemoveTeamMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            notInOrgMembers: 'notInOrgMembers',
            saveSuccess: 'saveSuccess',
        };
    }
    static types() {
        return {
            notInOrgMembers: { 'type': 'array', 'itemType': RemoveTeamMembersResponseBodyNotInOrgMembers },
            saveSuccess: 'boolean',
        };
    }
}
exports.RemoveTeamMembersResponseBody = RemoveTeamMembersResponseBody;
class RemoveTeamMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RemoveTeamMembersResponseBody,
        };
    }
}
exports.RemoveTeamMembersResponse = RemoveTeamMembersResponse;
class RenameDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RenameDentryHeaders = RenameDentryHeaders;
class RenameDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            name: 'string',
            operatorId: 'string',
        };
    }
}
exports.RenameDentryRequest = RenameDentryRequest;
class RenameDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DentryVO,
        };
    }
}
exports.RenameDentryResponse = RenameDentryResponse;
class SaveTeamMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SaveTeamMembersHeaders = SaveTeamMembersHeaders;
class SaveTeamMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            notify: 'notify',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': SaveTeamMembersRequestMembers },
            notify: 'boolean',
            operatorId: 'string',
        };
    }
}
exports.SaveTeamMembersRequest = SaveTeamMembersRequest;
class SaveTeamMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            notInOrgMembers: 'notInOrgMembers',
            saveSuccess: 'saveSuccess',
        };
    }
    static types() {
        return {
            notInOrgMembers: { 'type': 'array', 'itemType': SaveTeamMembersResponseBodyNotInOrgMembers },
            saveSuccess: 'boolean',
        };
    }
}
exports.SaveTeamMembersResponseBody = SaveTeamMembersResponseBody;
class SaveTeamMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SaveTeamMembersResponseBody,
        };
    }
}
exports.SaveTeamMembersResponse = SaveTeamMembersResponse;
class SearchHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SearchHeaders = SearchHeaders;
class SearchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryRequest: 'dentryRequest',
            keyword: 'keyword',
            operatorId: 'operatorId',
            spaceRequest: 'spaceRequest',
        };
    }
    static types() {
        return {
            dentryRequest: SearchRequestDentryRequest,
            keyword: 'string',
            operatorId: 'string',
            spaceRequest: SearchRequestSpaceRequest,
        };
    }
}
exports.SearchRequest = SearchRequest;
class SearchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryResult: 'dentryResult',
            spaceResult: 'spaceResult',
        };
    }
    static types() {
        return {
            dentryResult: SearchResponseBodyDentryResult,
            spaceResult: SearchResponseBodySpaceResult,
        };
    }
}
exports.SearchResponseBody = SearchResponseBody;
class SearchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SearchResponseBody,
        };
    }
}
exports.SearchResponse = SearchResponse;
class SearchTemplatesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SearchTemplatesHeaders = SearchTemplatesHeaders;
class SearchTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            param: 'param',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: SearchTemplatesRequestOption,
            param: SearchTemplatesRequestParam,
            operatorId: 'string',
        };
    }
}
exports.SearchTemplatesRequest = SearchTemplatesRequest;
class SearchTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            templateList: 'templateList',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            templateList: { 'type': 'array', 'itemType': SearchTemplatesResponseBodyTemplateList },
        };
    }
}
exports.SearchTemplatesResponseBody = SearchTemplatesResponseBody;
class SearchTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SearchTemplatesResponseBody,
        };
    }
}
exports.SearchTemplatesResponse = SearchTemplatesResponse;
class TeamTemplatesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.TeamTemplatesHeaders = TeamTemplatesHeaders;
class TeamTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: TeamTemplatesRequestOption,
            operatorId: 'string',
        };
    }
}
exports.TeamTemplatesRequest = TeamTemplatesRequest;
class TeamTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            templateList: 'templateList',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            templateList: { 'type': 'array', 'itemType': TeamTemplatesResponseBodyTemplateList },
        };
    }
}
exports.TeamTemplatesResponseBody = TeamTemplatesResponseBody;
class TeamTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TeamTemplatesResponseBody,
        };
    }
}
exports.TeamTemplatesResponse = TeamTemplatesResponse;
class TemplateCategoriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.TemplateCategoriesHeaders = TemplateCategoriesHeaders;
class TemplateCategoriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            param: 'param',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: TemplateCategoriesRequestOption,
            param: TemplateCategoriesRequestParam,
            operatorId: 'string',
        };
    }
}
exports.TemplateCategoriesRequest = TemplateCategoriesRequest;
class TemplateCategoriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': TemplateCategoriesResponseBodyList },
        };
    }
}
exports.TemplateCategoriesResponseBody = TemplateCategoriesResponseBody;
class TemplateCategoriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TemplateCategoriesResponseBody,
        };
    }
}
exports.TemplateCategoriesResponse = TemplateCategoriesResponse;
class UnmarkStarHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UnmarkStarHeaders = UnmarkStarHeaders;
class UnmarkStarRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.UnmarkStarRequest = UnmarkStarRequest;
class UnmarkStarResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UnmarkStarResponseBody = UnmarkStarResponseBody;
class UnmarkStarResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnmarkStarResponseBody,
        };
    }
}
exports.UnmarkStarResponse = UnmarkStarResponse;
class UnpinSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UnpinSpaceHeaders = UnpinSpaceHeaders;
class UnpinSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            operatorId: 'string',
        };
    }
}
exports.UnpinSpaceRequest = UnpinSpaceRequest;
class UnpinSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UnpinSpaceResponseBody = UnpinSpaceResponseBody;
class UnpinSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnpinSpaceResponseBody,
        };
    }
}
exports.UnpinSpaceResponse = UnpinSpaceResponse;
class UpdateTeamHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateTeamHeaders = UpdateTeamHeaders;
class UpdateTeamRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            name: 'name',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            description: 'string',
            name: 'string',
            operatorId: 'string',
        };
    }
}
exports.UpdateTeamRequest = UpdateTeamRequest;
class UpdateTeamResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: TeamVO,
        };
    }
}
exports.UpdateTeamResponse = UpdateTeamResponse;
class UserTemplatesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UserTemplatesHeaders = UserTemplatesHeaders;
class UserTemplatesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            operatorId: 'operatorId',
        };
    }
    static types() {
        return {
            option: UserTemplatesRequestOption,
            operatorId: 'string',
        };
    }
}
exports.UserTemplatesRequest = UserTemplatesRequest;
class UserTemplatesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            templateList: 'templateList',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            templateList: { 'type': 'array', 'itemType': UserTemplatesResponseBodyTemplateList },
        };
    }
}
exports.UserTemplatesResponseBody = UserTemplatesResponseBody;
class UserTemplatesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UserTemplatesResponseBody,
        };
    }
}
exports.UserTemplatesResponse = UserTemplatesResponse;
class DentryModelCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryModelCreator = DentryModelCreator;
class DentryModelStatisticalInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            wordCount: 'wordCount',
        };
    }
    static types() {
        return {
            wordCount: 'number',
        };
    }
}
exports.DentryModelStatisticalInfo = DentryModelStatisticalInfo;
class DentryModelUpdater extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryModelUpdater = DentryModelUpdater;
class DentryModelVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DentryModelVisitorInfo = DentryModelVisitorInfo;
class DentryVOCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryVOCreator = DentryVOCreator;
class DentryVOUpdater extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.DentryVOUpdater = DentryVOUpdater;
class DentryVOVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DentryVOVisitorInfo = DentryVOVisitorInfo;
class LinkSourceInfoIconUrl extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            line: 'line',
            small: 'small',
        };
    }
    static types() {
        return {
            line: 'string',
            small: 'string',
        };
    }
}
exports.LinkSourceInfoIconUrl = LinkSourceInfoIconUrl;
class SpaceModelHdIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.SpaceModelHdIconVO = SpaceModelHdIconVO;
class SpaceModelIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.SpaceModelIconVO = SpaceModelIconVO;
class SpaceModelOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.SpaceModelOwner = SpaceModelOwner;
class SpaceModelVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SpaceModelVisitorInfo = SpaceModelVisitorInfo;
class SpaceVOIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.SpaceVOIconVO = SpaceVOIconVO;
class SpaceVOOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.SpaceVOOwner = SpaceVOOwner;
class SpaceVOVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SpaceVOVisitorInfo = SpaceVOVisitorInfo;
class TeamModelCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.TeamModelCreator = TeamModelCreator;
class TeamModelRelatedDeptInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptId: 'deptId',
            deptName: 'deptName',
        };
    }
    static types() {
        return {
            deptId: 'string',
            deptName: 'string',
        };
    }
}
exports.TeamModelRelatedDeptInfo = TeamModelRelatedDeptInfo;
class TeamModelUpdater extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.TeamModelUpdater = TeamModelUpdater;
class TeamModelVisitInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            joinTime: 'joinTime',
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            joinTime: 'string',
            roleCode: 'string',
        };
    }
}
exports.TeamModelVisitInfo = TeamModelVisitInfo;
class TeamVOCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.TeamVOCreator = TeamVOCreator;
class TeamVORelatedDeptInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptId: 'deptId',
            deptName: 'deptName',
        };
    }
    static types() {
        return {
            deptId: 'string',
            deptName: 'string',
        };
    }
}
exports.TeamVORelatedDeptInfo = TeamVORelatedDeptInfo;
class TeamVOShareScopeInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            roleId: 'roleId',
            scope: 'scope',
        };
    }
    static types() {
        return {
            roleId: 'string',
            scope: 'number',
        };
    }
}
exports.TeamVOShareScopeInfo = TeamVOShareScopeInfo;
class TeamVOUpdater extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.TeamVOUpdater = TeamVOUpdater;
class TeamVOVisitInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            roleCode: 'string',
        };
    }
}
exports.TeamVOVisitInfo = TeamVOVisitInfo;
class BatchCreateTeamRequestParamCreateTeamParamList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adminUnionIdList: 'adminUnionIdList',
            creatorUnionId: 'creatorUnionId',
            deptId: 'deptId',
            teamName: 'teamName',
        };
    }
    static types() {
        return {
            adminUnionIdList: { 'type': 'array', 'itemType': 'string' },
            creatorUnionId: 'string',
            deptId: 'string',
            teamName: 'string',
        };
    }
}
exports.BatchCreateTeamRequestParamCreateTeamParamList = BatchCreateTeamRequestParamCreateTeamParamList;
class BatchCreateTeamRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTeamParamList: 'createTeamParamList',
        };
    }
    static types() {
        return {
            createTeamParamList: { 'type': 'array', 'itemType': BatchCreateTeamRequestParamCreateTeamParamList },
        };
    }
}
exports.BatchCreateTeamRequestParam = BatchCreateTeamRequestParam;
class CategoriesTemplatesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryStatus: 'categoryStatus',
            queryPlatform: 'queryPlatform',
            size: 'size',
            templateStatus: 'templateStatus',
        };
    }
    static types() {
        return {
            categoryStatus: 'number',
            queryPlatform: 'string',
            size: 'number',
            templateStatus: 'number',
        };
    }
}
exports.CategoriesTemplatesRequestOption = CategoriesTemplatesRequestOption;
class CategoriesTemplatesRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryIds: 'categoryIds',
        };
    }
    static types() {
        return {
            categoryIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.CategoriesTemplatesRequestParam = CategoriesTemplatesRequestParam;
class CategoryTemplatesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryStatus: 'categoryStatus',
            templateStatus: 'templateStatus',
        };
    }
    static types() {
        return {
            categoryStatus: 'number',
            templateStatus: 'number',
        };
    }
}
exports.CategoryTemplatesRequestOption = CategoryTemplatesRequestOption;
class CategoryTemplatesRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryId: 'categoryId',
        };
    }
    static types() {
        return {
            categoryId: 'string',
        };
    }
}
exports.CategoryTemplatesRequestParam = CategoryTemplatesRequestParam;
class CategoryTemplatesResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authorName: 'authorName',
            belong: 'belong',
            contentDownloadUrl: 'contentDownloadUrl',
            coverDownloadUrl: 'coverDownloadUrl',
            createTime: 'createTime',
            description: 'description',
            modifiedTime: 'modifiedTime',
            templateId: 'templateId',
            title: 'title',
            type: 'type',
            usedCount: 'usedCount',
            workspaceId: 'workspaceId',
            workspaceName: 'workspaceName',
        };
    }
    static types() {
        return {
            authorName: 'string',
            belong: 'string',
            contentDownloadUrl: 'string',
            coverDownloadUrl: 'string',
            createTime: 'string',
            description: 'string',
            modifiedTime: 'string',
            templateId: 'string',
            title: 'string',
            type: 'number',
            usedCount: 'number',
            workspaceId: 'string',
            workspaceName: 'string',
        };
    }
}
exports.CategoryTemplatesResponseBodyList = CategoryTemplatesResponseBodyList;
class CreateSpaceRequestShareScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scope: 'scope',
        };
    }
    static types() {
        return {
            scope: 'number',
        };
    }
}
exports.CreateSpaceRequestShareScope = CreateSpaceRequestShareScope;
class CreateTeamRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'number',
            roleCode: 'string',
        };
    }
}
exports.CreateTeamRequestMembers = CreateTeamRequestMembers;
class CrossOrgMigrateRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkOperatorSourceRole: 'checkOperatorSourceRole',
            deleteSource: 'deleteSource',
            needRecycleFailedWorkspaceId: 'needRecycleFailedWorkspaceId',
            relateTeamId: 'relateTeamId',
            relateTeamIdStr: 'relateTeamIdStr',
            retainOrgGroup: 'retainOrgGroup',
            skipRole: 'skipRole',
            workspaceIdStrs: 'workspaceIdStrs',
            workspaceIds: 'workspaceIds',
        };
    }
    static types() {
        return {
            checkOperatorSourceRole: 'boolean',
            deleteSource: 'boolean',
            needRecycleFailedWorkspaceId: 'boolean',
            relateTeamId: 'number',
            relateTeamIdStr: 'string',
            retainOrgGroup: 'boolean',
            skipRole: 'boolean',
            workspaceIdStrs: { 'type': 'array', 'itemType': 'string' },
            workspaceIds: { 'type': 'array', 'itemType': 'number' },
        };
    }
}
exports.CrossOrgMigrateRequestOption = CrossOrgMigrateRequestOption;
class CrossOrgMigrateRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
        };
    }
    static types() {
        return {
            corpId: 'string',
        };
    }
}
exports.CrossOrgMigrateRequestParam = CrossOrgMigrateRequestParam;
class DocContentRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            targetFormat: 'targetFormat',
        };
    }
    static types() {
        return {
            targetFormat: 'string',
        };
    }
}
exports.DocContentRequestOption = DocContentRequestOption;
class ListFeedsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            time: 'time',
            type: 'type',
        };
    }
    static types() {
        return {
            content: 'string',
            time: 'number',
            type: 'number',
        };
    }
}
exports.ListFeedsResponseBodyItems = ListFeedsResponseBodyItems;
class ListPinSpacesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            withSpaceCreatorInfo: 'withSpaceCreatorInfo',
            withSpaceModifierInfo: 'withSpaceModifierInfo',
            withSpacePermissionRole: 'withSpacePermissionRole',
            withTeamDetail: 'withTeamDetail',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            withSpaceCreatorInfo: 'boolean',
            withSpaceModifierInfo: 'boolean',
            withSpacePermissionRole: 'boolean',
            withTeamDetail: 'boolean',
        };
    }
}
exports.ListPinSpacesRequestOption = ListPinSpacesRequestOption;
class ListPinSpacesResponseBodyResultItemsSpaceInfoCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.ListPinSpacesResponseBodyResultItemsSpaceInfoCreator = ListPinSpacesResponseBodyResultItemsSpaceInfoCreator;
class ListPinSpacesResponseBodyResultItemsSpaceInfoIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.ListPinSpacesResponseBodyResultItemsSpaceInfoIconVO = ListPinSpacesResponseBodyResultItemsSpaceInfoIconVO;
class ListPinSpacesResponseBodyResultItemsSpaceInfoModifier extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.ListPinSpacesResponseBodyResultItemsSpaceInfoModifier = ListPinSpacesResponseBodyResultItemsSpaceInfoModifier;
class ListPinSpacesResponseBodyResultItemsSpaceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            createTime: 'createTime',
            creator: 'creator',
            description: 'description',
            iconVO: 'iconVO',
            id: 'id',
            mobileUrl: 'mobileUrl',
            modifiedTime: 'modifiedTime',
            modifier: 'modifier',
            name: 'name',
            pcUrl: 'pcUrl',
        };
    }
    static types() {
        return {
            cover: 'string',
            createTime: 'string',
            creator: ListPinSpacesResponseBodyResultItemsSpaceInfoCreator,
            description: 'string',
            iconVO: ListPinSpacesResponseBodyResultItemsSpaceInfoIconVO,
            id: 'string',
            mobileUrl: 'string',
            modifiedTime: 'string',
            modifier: ListPinSpacesResponseBodyResultItemsSpaceInfoModifier,
            name: 'string',
            pcUrl: 'string',
        };
    }
}
exports.ListPinSpacesResponseBodyResultItemsSpaceInfo = ListPinSpacesResponseBodyResultItemsSpaceInfo;
class ListPinSpacesResponseBodyResultItemsTeamInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.ListPinSpacesResponseBodyResultItemsTeamInfo = ListPinSpacesResponseBodyResultItemsTeamInfo;
class ListPinSpacesResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            modifiedTime: 'modifiedTime',
            spaceInfo: 'spaceInfo',
            spacePermissionRole: 'spacePermissionRole',
            teamInfo: 'teamInfo',
        };
    }
    static types() {
        return {
            createTime: 'string',
            modifiedTime: 'string',
            spaceInfo: ListPinSpacesResponseBodyResultItemsSpaceInfo,
            spacePermissionRole: 'string',
            teamInfo: ListPinSpacesResponseBodyResultItemsTeamInfo,
        };
    }
}
exports.ListPinSpacesResponseBodyResultItems = ListPinSpacesResponseBodyResultItems;
class ListSpaceSectionsResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            displayType: 'displayType',
            id: 'id',
            name: 'name',
            spaceNum: 'spaceNum',
            spaces: 'spaces',
        };
    }
    static types() {
        return {
            displayType: 'string',
            id: 'string',
            name: 'string',
            spaceNum: 'number',
            spaces: { 'type': 'array', 'itemType': SpaceModel },
        };
    }
}
exports.ListSpaceSectionsResponseBodyItems = ListSpaceSectionsResponseBodyItems;
class ListStarsRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentTypeList: 'contentTypeList',
            filterDocTypes: 'filterDocTypes',
            listV2: 'listV2',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            order: 'order',
            orderBy: 'orderBy',
            withDentryCreatorInfo: 'withDentryCreatorInfo',
            withDentryModifierInfo: 'withDentryModifierInfo',
            withDentryPermissionRole: 'withDentryPermissionRole',
            withSpaceDetail: 'withSpaceDetail',
            withSpacePermissionRole: 'withSpacePermissionRole',
            withTeamDetail: 'withTeamDetail',
        };
    }
    static types() {
        return {
            contentTypeList: { 'type': 'array', 'itemType': 'string' },
            filterDocTypes: { 'type': 'array', 'itemType': 'string' },
            listV2: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            order: 'string',
            orderBy: 'string',
            withDentryCreatorInfo: 'boolean',
            withDentryModifierInfo: 'boolean',
            withDentryPermissionRole: 'boolean',
            withSpaceDetail: 'boolean',
            withSpacePermissionRole: 'boolean',
            withTeamDetail: 'boolean',
        };
    }
}
exports.ListStarsRequestOption = ListStarsRequestOption;
class ListStarsResponseBodyStarListDentryInfoCreator extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.ListStarsResponseBodyStarListDentryInfoCreator = ListStarsResponseBodyStarListDentryInfoCreator;
class ListStarsResponseBodyStarListDentryInfoModifier extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.ListStarsResponseBodyStarListDentryInfoModifier = ListStarsResponseBodyStarListDentryInfoModifier;
class ListStarsResponseBodyStarListDentryInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            creator: 'creator',
            extension: 'extension',
            id: 'id',
            mobileUrl: 'mobileUrl',
            modifiedTime: 'modifiedTime',
            modifier: 'modifier',
            name: 'name',
            pcUrl: 'pcUrl',
            spaceId: 'spaceId',
            status: 'status',
            type: 'type',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            createTime: 'string',
            creator: ListStarsResponseBodyStarListDentryInfoCreator,
            extension: 'string',
            id: 'string',
            mobileUrl: 'string',
            modifiedTime: 'string',
            modifier: ListStarsResponseBodyStarListDentryInfoModifier,
            name: 'string',
            pcUrl: 'string',
            spaceId: 'string',
            status: 'string',
            type: 'string',
            uuid: 'string',
        };
    }
}
exports.ListStarsResponseBodyStarListDentryInfo = ListStarsResponseBodyStarListDentryInfo;
class ListStarsResponseBodyStarListSpaceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.ListStarsResponseBodyStarListSpaceInfo = ListStarsResponseBodyStarListSpaceInfo;
class ListStarsResponseBodyStarListTeamInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.ListStarsResponseBodyStarListTeamInfo = ListStarsResponseBodyStarListTeamInfo;
class ListStarsResponseBodyStarList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            dentryInfo: 'dentryInfo',
            dentryPermissionRole: 'dentryPermissionRole',
            id: 'id',
            isDeleted: 'isDeleted',
            modifiedTime: 'modifiedTime',
            spaceInfo: 'spaceInfo',
            spacePermissionRole: 'spacePermissionRole',
            starType: 'starType',
            teamInfo: 'teamInfo',
        };
    }
    static types() {
        return {
            createTime: 'string',
            dentryInfo: ListStarsResponseBodyStarListDentryInfo,
            dentryPermissionRole: 'string',
            id: 'string',
            isDeleted: 'boolean',
            modifiedTime: 'string',
            spaceInfo: ListStarsResponseBodyStarListSpaceInfo,
            spacePermissionRole: 'string',
            starType: 'string',
            teamInfo: ListStarsResponseBodyStarListTeamInfo,
        };
    }
}
exports.ListStarsResponseBodyStarList = ListStarsResponseBodyStarList;
class ListTeamMembersResponseBodyMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            name: 'name',
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'number',
            name: 'string',
            roleCode: 'string',
        };
    }
}
exports.ListTeamMembersResponseBodyMembers = ListTeamMembersResponseBodyMembers;
class QueryItemByUrlResponseBodySpaceOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.QueryItemByUrlResponseBodySpaceOwner = QueryItemByUrlResponseBodySpaceOwner;
class QueryItemByUrlResponseBodySpace extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            id: 'id',
            name: 'name',
            owner: 'owner',
            type: 'type',
        };
    }
    static types() {
        return {
            description: 'string',
            id: 'string',
            name: 'string',
            owner: QueryItemByUrlResponseBodySpaceOwner,
            type: 'number',
        };
    }
}
exports.QueryItemByUrlResponseBodySpace = QueryItemByUrlResponseBodySpace;
class QueryRecentListResponseBodyRecentListTeam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.QueryRecentListResponseBodyRecentListTeam = QueryRecentListResponseBodyRecentListTeam;
class QueryRecentListResponseBodyRecentList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deleted: 'deleted',
            dentry: 'dentry',
            recentTime: 'recentTime',
            team: 'team',
        };
    }
    static types() {
        return {
            deleted: 'boolean',
            dentry: DentryModel,
            recentTime: 'number',
            team: QueryRecentListResponseBodyRecentListTeam,
        };
    }
}
exports.QueryRecentListResponseBodyRecentList = QueryRecentListResponseBodyRecentList;
class RelatedSpacesResponseBodyItemsHdIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.RelatedSpacesResponseBodyItemsHdIconVO = RelatedSpacesResponseBodyItemsHdIconVO;
class RelatedSpacesResponseBodyItemsIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.RelatedSpacesResponseBodyItemsIconVO = RelatedSpacesResponseBodyItemsIconVO;
class RelatedSpacesResponseBodyItemsOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            unionId: 'string',
        };
    }
}
exports.RelatedSpacesResponseBodyItemsOwner = RelatedSpacesResponseBodyItemsOwner;
class RelatedSpacesResponseBodyItemsVisitorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryActions: 'dentryActions',
            pinned: 'pinned',
            roleCode: 'roleCode',
            spaceActions: 'spaceActions',
        };
    }
    static types() {
        return {
            dentryActions: { 'type': 'array', 'itemType': 'string' },
            pinned: 'boolean',
            roleCode: 'string',
            spaceActions: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.RelatedSpacesResponseBodyItemsVisitorInfo = RelatedSpacesResponseBodyItemsVisitorInfo;
class RelatedSpacesResponseBodyItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cover: 'cover',
            description: 'description',
            hdIconVO: 'hdIconVO',
            iconVO: 'iconVO',
            id: 'id',
            name: 'name',
            owner: 'owner',
            recentList: 'recentList',
            type: 'type',
            url: 'url',
            visitorInfo: 'visitorInfo',
        };
    }
    static types() {
        return {
            cover: 'string',
            description: 'string',
            hdIconVO: RelatedSpacesResponseBodyItemsHdIconVO,
            iconVO: RelatedSpacesResponseBodyItemsIconVO,
            id: 'string',
            name: 'string',
            owner: RelatedSpacesResponseBodyItemsOwner,
            recentList: { 'type': 'array', 'itemType': DentryModel },
            type: 'number',
            url: 'string',
            visitorInfo: RelatedSpacesResponseBodyItemsVisitorInfo,
        };
    }
}
exports.RelatedSpacesResponseBodyItems = RelatedSpacesResponseBodyItems;
class RemoveTeamMembersRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'number',
            roleCode: 'string',
        };
    }
}
exports.RemoveTeamMembersRequestMembers = RemoveTeamMembersRequestMembers;
class RemoveTeamMembersResponseBodyNotInOrgMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            name: 'name',
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'number',
            name: 'string',
            roleCode: 'string',
        };
    }
}
exports.RemoveTeamMembersResponseBodyNotInOrgMembers = RemoveTeamMembersResponseBodyNotInOrgMembers;
class SaveTeamMembersRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'number',
            roleCode: 'string',
        };
    }
}
exports.SaveTeamMembersRequestMembers = SaveTeamMembersRequestMembers;
class SaveTeamMembersResponseBodyNotInOrgMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberId: 'memberId',
            memberType: 'memberType',
            name: 'name',
            roleCode: 'roleCode',
        };
    }
    static types() {
        return {
            memberId: 'string',
            memberType: 'number',
            name: 'string',
            roleCode: 'string',
        };
    }
}
exports.SaveTeamMembersResponseBodyNotInOrgMembers = SaveTeamMembersResponseBodyNotInOrgMembers;
class SearchRequestDentryRequestVisitTimeRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            end: 'end',
            start: 'start',
        };
    }
    static types() {
        return {
            end: 'number',
            start: 'number',
        };
    }
}
exports.SearchRequestDentryRequestVisitTimeRange = SearchRequestDentryRequestVisitTimeRange;
class SearchRequestDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            searchField: 'searchField',
            searchFileType: 'searchFileType',
            spaceId: 'spaceId',
            spaceIds: 'spaceIds',
            summaryLength: 'summaryLength',
            visitTimeRange: 'visitTimeRange',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            searchField: 'number',
            searchFileType: 'number',
            spaceId: 'string',
            spaceIds: { 'type': 'array', 'itemType': 'string' },
            summaryLength: 'number',
            visitTimeRange: SearchRequestDentryRequestVisitTimeRange,
        };
    }
}
exports.SearchRequestDentryRequest = SearchRequestDentryRequest;
class SearchRequestSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            withTeamInfo: 'withTeamInfo',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            withTeamInfo: 'boolean',
        };
    }
}
exports.SearchRequestSpaceRequest = SearchRequestSpaceRequest;
class SearchResponseBodyDentryResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            creation: 'creation',
            dentryId: 'dentryId',
            dentryUuid: 'dentryUuid',
            extension: 'extension',
            iconUrl: 'iconUrl',
            lastEdition: 'lastEdition',
            name: 'name',
            originName: 'originName',
            path: 'path',
            sceneType: 'sceneType',
            searchFileType: 'searchFileType',
            spaceId: 'spaceId',
            thumbnailUrl: 'thumbnailUrl',
            url: 'url',
        };
    }
    static types() {
        return {
            content: 'string',
            creation: OpenActionModel,
            dentryId: 'string',
            dentryUuid: 'string',
            extension: 'string',
            iconUrl: 'string',
            lastEdition: OpenActionModel,
            name: 'string',
            originName: 'string',
            path: 'string',
            sceneType: 'number',
            searchFileType: 'number',
            spaceId: 'string',
            thumbnailUrl: 'string',
            url: 'string',
        };
    }
}
exports.SearchResponseBodyDentryResultItems = SearchResponseBodyDentryResultItems;
class SearchResponseBodyDentryResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': SearchResponseBodyDentryResultItems },
            nextToken: 'string',
        };
    }
}
exports.SearchResponseBodyDentryResult = SearchResponseBodyDentryResult;
class SearchResponseBodySpaceResultItemsIconVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            type: 'type',
        };
    }
    static types() {
        return {
            icon: 'string',
            type: 'string',
        };
    }
}
exports.SearchResponseBodySpaceResultItemsIconVO = SearchResponseBodySpaceResultItemsIconVO;
class SearchResponseBodySpaceResultItemsTeamVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.SearchResponseBodySpaceResultItemsTeamVO = SearchResponseBodySpaceResultItemsTeamVO;
class SearchResponseBodySpaceResultItemsUserLastOperation extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            time: 'time',
        };
    }
    static types() {
        return {
            name: 'string',
            time: 'number',
        };
    }
}
exports.SearchResponseBodySpaceResultItemsUserLastOperation = SearchResponseBodySpaceResultItemsUserLastOperation;
class SearchResponseBodySpaceResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            iconVO: 'iconVO',
            name: 'name',
            originName: 'originName',
            spaceId: 'spaceId',
            teamVO: 'teamVO',
            url: 'url',
            userLastOperation: 'userLastOperation',
        };
    }
    static types() {
        return {
            iconVO: SearchResponseBodySpaceResultItemsIconVO,
            name: 'string',
            originName: 'string',
            spaceId: 'string',
            teamVO: SearchResponseBodySpaceResultItemsTeamVO,
            url: 'string',
            userLastOperation: SearchResponseBodySpaceResultItemsUserLastOperation,
        };
    }
}
exports.SearchResponseBodySpaceResultItems = SearchResponseBodySpaceResultItems;
class SearchResponseBodySpaceResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            items: 'items',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            items: { 'type': 'array', 'itemType': SearchResponseBodySpaceResultItems },
            nextToken: 'string',
        };
    }
}
exports.SearchResponseBodySpaceResult = SearchResponseBodySpaceResult;
class SearchTemplatesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            excludeWorkspaceIds: 'excludeWorkspaceIds',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            platform: 'platform',
            templateTypes: 'templateTypes',
            version: 'version',
            workspaceIds: 'workspaceIds',
        };
    }
    static types() {
        return {
            excludeWorkspaceIds: { 'type': 'array', 'itemType': 'string' },
            maxResults: 'number',
            nextToken: 'string',
            platform: 'string',
            templateTypes: { 'type': 'array', 'itemType': 'number' },
            version: 'number',
            workspaceIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SearchTemplatesRequestOption = SearchTemplatesRequestOption;
class SearchTemplatesRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            belong: 'belong',
            searchName: 'searchName',
        };
    }
    static types() {
        return {
            belong: 'string',
            searchName: 'string',
        };
    }
}
exports.SearchTemplatesRequestParam = SearchTemplatesRequestParam;
class SearchTemplatesResponseBodyTemplateList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authorName: 'authorName',
            belong: 'belong',
            contentDownloadUrl: 'contentDownloadUrl',
            coverDownloadUrl: 'coverDownloadUrl',
            createTime: 'createTime',
            description: 'description',
            modifiedTime: 'modifiedTime',
            templateId: 'templateId',
            title: 'title',
            type: 'type',
            usedCount: 'usedCount',
            workspaceId: 'workspaceId',
            workspaceName: 'workspaceName',
        };
    }
    static types() {
        return {
            authorName: 'string',
            belong: 'string',
            contentDownloadUrl: 'string',
            coverDownloadUrl: 'string',
            createTime: 'string',
            description: 'string',
            modifiedTime: 'string',
            templateId: 'string',
            title: 'string',
            type: 'number',
            usedCount: 'number',
            workspaceId: 'string',
            workspaceName: 'string',
        };
    }
}
exports.SearchTemplatesResponseBodyTemplateList = SearchTemplatesResponseBodyTemplateList;
class TeamTemplatesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            excludeWorkspaceIds: 'excludeWorkspaceIds',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            platform: 'platform',
            templateTypes: 'templateTypes',
            version: 'version',
            workspaceIds: 'workspaceIds',
        };
    }
    static types() {
        return {
            excludeWorkspaceIds: { 'type': 'array', 'itemType': 'string' },
            maxResults: 'number',
            nextToken: 'string',
            platform: 'string',
            templateTypes: { 'type': 'array', 'itemType': 'number' },
            version: 'number',
            workspaceIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.TeamTemplatesRequestOption = TeamTemplatesRequestOption;
class TeamTemplatesResponseBodyTemplateList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authorName: 'authorName',
            belong: 'belong',
            contentDownloadUrl: 'contentDownloadUrl',
            coverDownloadUrl: 'coverDownloadUrl',
            createTime: 'createTime',
            description: 'description',
            modifiedTime: 'modifiedTime',
            templateId: 'templateId',
            title: 'title',
            type: 'type',
            usedCount: 'usedCount',
            workspaceId: 'workspaceId',
            workspaceName: 'workspaceName',
        };
    }
    static types() {
        return {
            authorName: 'string',
            belong: 'string',
            contentDownloadUrl: 'string',
            coverDownloadUrl: 'string',
            createTime: 'string',
            description: 'string',
            modifiedTime: 'string',
            templateId: 'string',
            title: 'string',
            type: 'number',
            usedCount: 'number',
            workspaceId: 'string',
            workspaceName: 'string',
        };
    }
}
exports.TeamTemplatesResponseBodyTemplateList = TeamTemplatesResponseBodyTemplateList;
class TemplateCategoriesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryStatus: 'categoryStatus',
            industryId: 'industryId',
        };
    }
    static types() {
        return {
            categoryStatus: 'number',
            industryId: 'number',
        };
    }
}
exports.TemplateCategoriesRequestOption = TemplateCategoriesRequestOption;
class TemplateCategoriesRequestParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tenantId: 'tenantId',
        };
    }
    static types() {
        return {
            tenantId: 'string',
        };
    }
}
exports.TemplateCategoriesRequestParam = TemplateCategoriesRequestParam;
class TemplateCategoriesResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryId: 'categoryId',
            categoryName: 'categoryName',
            sort: 'sort',
        };
    }
    static types() {
        return {
            categoryId: 'string',
            categoryName: 'string',
            sort: 'string',
        };
    }
}
exports.TemplateCategoriesResponseBodyList = TemplateCategoriesResponseBodyList;
class UserTemplatesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            platform: 'platform',
            templateTypes: 'templateTypes',
            version: 'version',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            platform: 'string',
            templateTypes: { 'type': 'array', 'itemType': 'number' },
            version: 'number',
        };
    }
}
exports.UserTemplatesRequestOption = UserTemplatesRequestOption;
class UserTemplatesResponseBodyTemplateList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authorName: 'authorName',
            belong: 'belong',
            contentDownloadUrl: 'contentDownloadUrl',
            coverDownloadUrl: 'coverDownloadUrl',
            createTime: 'createTime',
            description: 'description',
            modifiedTime: 'modifiedTime',
            templateId: 'templateId',
            title: 'title',
            type: 'type',
            usedCount: 'usedCount',
            workspaceId: 'workspaceId',
            workspaceName: 'workspaceName',
        };
    }
    static types() {
        return {
            authorName: 'string',
            belong: 'string',
            contentDownloadUrl: 'string',
            coverDownloadUrl: 'string',
            createTime: 'string',
            description: 'string',
            modifiedTime: 'string',
            templateId: 'string',
            title: 'string',
            type: 'number',
            usedCount: 'number',
            workspaceId: 'string',
            workspaceName: 'string',
        };
    }
}
exports.UserTemplatesResponseBodyTemplateList = UserTemplatesResponseBodyTemplateList;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async batchCreateTeamWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.param)) {
            body["param"] = request.param;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchCreateTeam",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/batch`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchCreateTeamResponse({}));
    }
    async batchCreateTeam(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchCreateTeamHeaders({});
        return await this.batchCreateTeamWithOptions(request, headers, runtime);
    }
    async batchDeleteRecentsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryUuids)) {
            body["dentryUuids"] = request.dentryUuids;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchDeleteRecents",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/dentries/recentRecords/batchRemove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchDeleteRecentsResponse({}));
    }
    async batchDeleteRecents(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchDeleteRecentsHeaders({});
        return await this.batchDeleteRecentsWithOptions(request, headers, runtime);
    }
    async categoriesTemplatesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.param)) {
            body["param"] = request.param;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CategoriesTemplates",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/categoryLists/templates/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CategoriesTemplatesResponse({}));
    }
    async categoriesTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CategoriesTemplatesHeaders({});
        return await this.categoriesTemplatesWithOptions(request, headers, runtime);
    }
    async categoryTemplatesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.param)) {
            body["param"] = request.param;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CategoryTemplates",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/categories/templates/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CategoryTemplatesResponse({}));
    }
    async categoryTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CategoryTemplatesHeaders({});
        return await this.categoryTemplatesWithOptions(request, headers, runtime);
    }
    async copyDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        if (!tea_util_1.default.isUnset(request.toNextDentryId)) {
            body["toNextDentryId"] = request.toNextDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toParentDentryId)) {
            body["toParentDentryId"] = request.toParentDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toPrevDentryId)) {
            body["toPrevDentryId"] = request.toPrevDentryId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CopyDentry",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}/copy`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CopyDentryResponse({}));
    }
    async copyDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CopyDentryHeaders({});
        return await this.copyDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async createDentryWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryType)) {
            body["dentryType"] = request.dentryType;
        }
        if (!tea_util_1.default.isUnset(request.documentType)) {
            body["documentType"] = request.documentType;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.parentDentryId)) {
            body["parentDentryId"] = request.parentDentryId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateDentry",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/dentries`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateDentryResponse({}));
    }
    async createDentry(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateDentryHeaders({});
        return await this.createDentryWithOptions(spaceId, request, headers, runtime);
    }
    async createSpaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.sectionId)) {
            body["sectionId"] = request.sectionId;
        }
        if (!tea_util_1.default.isUnset(request.shareScope)) {
            body["shareScope"] = request.shareScope;
        }
        if (!tea_util_1.default.isUnset(request.teamId)) {
            body["teamId"] = request.teamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateSpace",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateSpaceResponse({}));
    }
    async createSpace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateSpaceHeaders({});
        return await this.createSpaceWithOptions(request, headers, runtime);
    }
    async createTeamWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.cover)) {
            body["cover"] = request.cover;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.teamType)) {
            body["teamType"] = request.teamType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateTeam",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateTeamResponse({}));
    }
    async createTeam(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateTeamHeaders({});
        return await this.createTeamWithOptions(request, headers, runtime);
    }
    async crossOrgMigrateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.param)) {
            body["param"] = request.param;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CrossOrgMigrate",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/crossOrganizations/spaces/migrate`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CrossOrgMigrateResponse({}));
    }
    async crossOrgMigrate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CrossOrgMigrateHeaders({});
        return await this.crossOrgMigrateWithOptions(request, headers, runtime);
    }
    async deleteTeamWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteTeam",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteTeamResponse({}));
    }
    async deleteTeam(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteTeamHeaders({});
        return await this.deleteTeamWithOptions(teamId, request, headers, runtime);
    }
    async docContentWithOptions(dentryUuid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DocContent",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/dentries/${dentryUuid}/contents`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DocContentResponse({}));
    }
    async docContent(dentryUuid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DocContentHeaders({});
        return await this.docContentWithOptions(dentryUuid, request, headers, runtime);
    }
    async getDocContentWithOptions(dentryUuid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.targetFormat)) {
            query["targetFormat"] = request.targetFormat;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetDocContent",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/me/query/${dentryUuid}/contents`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDocContentResponse({}));
    }
    async getDocContent(dentryUuid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDocContentHeaders({});
        return await this.getDocContentWithOptions(dentryUuid, request, headers, runtime);
    }
    async getSchemaWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSchema",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}/schemas`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSchemaResponse({}));
    }
    async getSchema(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSchemaHeaders({});
        return await this.getSchemaWithOptions(teamId, request, headers, runtime);
    }
    async getSpaceDirectoriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.dentryId)) {
            query["dentryId"] = request.dentryId;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSpaceDirectories",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/directories`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSpaceDirectoriesResponse({}));
    }
    async getSpaceDirectories(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSpaceDirectoriesHeaders({});
        return await this.getSpaceDirectoriesWithOptions(spaceId, request, headers, runtime);
    }
    async getStarInfoWithOptions(dentryUuid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetStarInfo",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/dentries/${dentryUuid}/starInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetStarInfoResponse({}));
    }
    async getStarInfo(dentryUuid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetStarInfoHeaders({});
        return await this.getStarInfoWithOptions(dentryUuid, request, headers, runtime);
    }
    async getTeamWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetTeam",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTeamResponse({}));
    }
    async getTeam(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTeamHeaders({});
        return await this.getTeamWithOptions(teamId, request, headers, runtime);
    }
    async getTotalNumberOfDentriesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.includeFolder)) {
            query["includeFolder"] = request.includeFolder;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.spaceTypes)) {
            query["spaceTypes"] = request.spaceTypes;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetTotalNumberOfDentries",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/statistics/dentryCounts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTotalNumberOfDentriesResponse({}));
    }
    async getTotalNumberOfDentries(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTotalNumberOfDentriesHeaders({});
        return await this.getTotalNumberOfDentriesWithOptions(request, headers, runtime);
    }
    async getTotalNumberOfSpacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetTotalNumberOfSpaces",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/statistics/spaceCounts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTotalNumberOfSpacesResponse({}));
    }
    async getTotalNumberOfSpaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTotalNumberOfSpacesHeaders({});
        return await this.getTotalNumberOfSpacesWithOptions(request, headers, runtime);
    }
    async getUserInfoByOpenTokenWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.docKey)) {
            query["docKey"] = request.docKey;
        }
        if (!tea_util_1.default.isUnset(request.openToken)) {
            query["openToken"] = request.openToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetUserInfoByOpenToken",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/userInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserInfoByOpenTokenResponse({}));
    }
    async getUserInfoByOpenToken(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserInfoByOpenTokenHeaders({});
        return await this.getUserInfoByOpenTokenWithOptions(request, headers, runtime);
    }
    async listFeedsWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.excludeFile)) {
            query["excludeFile"] = request.excludeFile;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListFeeds",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}/feeds`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListFeedsResponse({}));
    }
    async listFeeds(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListFeedsHeaders({});
        return await this.listFeedsWithOptions(teamId, request, headers, runtime);
    }
    async listHotDocsWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListHotDocs",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}/hotDocs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListHotDocsResponse({}));
    }
    async listHotDocs(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListHotDocsHeaders({});
        return await this.listHotDocsWithOptions(teamId, request, headers, runtime);
    }
    async listPinSpacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListPinSpaces",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/pinLists/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListPinSpacesResponse({}));
    }
    async listPinSpaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListPinSpacesHeaders({});
        return await this.listPinSpacesWithOptions(request, headers, runtime);
    }
    async listRelatedSpaceTeamsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListRelatedSpaceTeams",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/relations/spaceTeams`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListRelatedSpaceTeamsResponse({}));
    }
    async listRelatedSpaceTeams(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListRelatedSpaceTeamsHeaders({});
        return await this.listRelatedSpaceTeamsWithOptions(request, headers, runtime);
    }
    async listRelatedTeamsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListRelatedTeams",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListRelatedTeamsResponse({}));
    }
    async listRelatedTeams(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListRelatedTeamsHeaders({});
        return await this.listRelatedTeamsWithOptions(request, headers, runtime);
    }
    async listSpaceSectionsWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListSpaceSections",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}/spaceSections`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListSpaceSectionsResponse({}));
    }
    async listSpaceSections(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListSpaceSectionsHeaders({});
        return await this.listSpaceSectionsWithOptions(teamId, request, headers, runtime);
    }
    async listStarsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListStars",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/dentries/starLists/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListStarsResponse({}));
    }
    async listStars(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListStarsHeaders({});
        return await this.listStarsWithOptions(request, headers, runtime);
    }
    async listTeamMembersWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListTeamMembers",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}/members`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListTeamMembersResponse({}));
    }
    async listTeamMembers(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListTeamMembersHeaders({});
        return await this.listTeamMembersWithOptions(teamId, request, headers, runtime);
    }
    async markStarWithOptions(dentryUuid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MarkStar",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/dentries/${dentryUuid}/stars/mark`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MarkStarResponse({}));
    }
    async markStar(dentryUuid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MarkStarHeaders({});
        return await this.markStarWithOptions(dentryUuid, request, headers, runtime);
    }
    async moveDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        if (!tea_util_1.default.isUnset(request.toNextDentryId)) {
            body["toNextDentryId"] = request.toNextDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toParentDentryId)) {
            body["toParentDentryId"] = request.toParentDentryId;
        }
        if (!tea_util_1.default.isUnset(request.toPrevDentryId)) {
            body["toPrevDentryId"] = request.toPrevDentryId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MoveDentry",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}/move`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MoveDentryResponse({}));
    }
    async moveDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MoveDentryHeaders({});
        return await this.moveDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async pinSpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PinSpace",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/pin`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PinSpaceResponse({}));
    }
    async pinSpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PinSpaceHeaders({});
        return await this.pinSpaceWithOptions(spaceId, request, headers, runtime);
    }
    async queryDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.includeSpace)) {
            query["includeSpace"] = request.includeSpace;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDentry",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryDentryResponse({}));
    }
    async queryDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryDentryHeaders({});
        return await this.queryDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async queryDocContentWithOptions(dentryUuid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.targetFormat)) {
            query["targetFormat"] = request.targetFormat;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDocContent",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/query/${dentryUuid}/contents`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryDocContentResponse({}));
    }
    async queryDocContent(dentryUuid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryDocContentHeaders({});
        return await this.queryDocContentWithOptions(dentryUuid, request, headers, runtime);
    }
    async queryItemByUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.url)) {
            query["url"] = request.url;
        }
        if (!tea_util_1.default.isUnset(request.withStatisticalInfo)) {
            query["withStatisticalInfo"] = request.withStatisticalInfo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryItemByUrl",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/items`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryItemByUrlResponse({}));
    }
    async queryItemByUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryItemByUrlHeaders({});
        return await this.queryItemByUrlWithOptions(request, headers, runtime);
    }
    async queryMineSpaceWithOptions(unionId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "QueryMineSpace",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/users/${unionId}/mine`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryMineSpaceResponse({}));
    }
    async queryMineSpace(unionId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryMineSpaceHeaders({});
        return await this.queryMineSpaceWithOptions(unionId, headers, runtime);
    }
    async queryRecentListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.creatorType)) {
            query["creatorType"] = request.creatorType;
        }
        if (!tea_util_1.default.isUnset(request.fileType)) {
            query["fileType"] = request.fileType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.recentType)) {
            query["recentType"] = request.recentType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryRecentList",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/docs/recent`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryRecentListResponse({}));
    }
    async queryRecentList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryRecentListHeaders({});
        return await this.queryRecentListWithOptions(request, headers, runtime);
    }
    async querySpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QuerySpace",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QuerySpaceResponse({}));
    }
    async querySpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QuerySpaceHeaders({});
        return await this.querySpaceWithOptions(spaceId, request, headers, runtime);
    }
    async relatedSpacesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.teamId)) {
            query["teamId"] = request.teamId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RelatedSpaces",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/relations/spaces`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RelatedSpacesResponse({}));
    }
    async relatedSpaces(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RelatedSpacesHeaders({});
        return await this.relatedSpacesWithOptions(request, headers, runtime);
    }
    async removeTeamMembersWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RemoveTeamMembers",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}/members/remove`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RemoveTeamMembersResponse({}));
    }
    async removeTeamMembers(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RemoveTeamMembersHeaders({});
        return await this.removeTeamMembersWithOptions(teamId, request, headers, runtime);
    }
    async renameDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RenameDentry",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/dentries/${dentryId}/rename`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RenameDentryResponse({}));
    }
    async renameDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RenameDentryHeaders({});
        return await this.renameDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async saveTeamMembersWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.notify)) {
            body["notify"] = request.notify;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SaveTeamMembers",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}/members`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SaveTeamMembersResponse({}));
    }
    async saveTeamMembers(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SaveTeamMembersHeaders({});
        return await this.saveTeamMembersWithOptions(teamId, request, headers, runtime);
    }
    async searchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryRequest)) {
            body["dentryRequest"] = request.dentryRequest;
        }
        if (!tea_util_1.default.isUnset(request.keyword)) {
            body["keyword"] = request.keyword;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        if (!tea_util_1.default.isUnset(request.spaceRequest)) {
            body["spaceRequest"] = request.spaceRequest;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Search",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/search`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SearchResponse({}));
    }
    async search(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchHeaders({});
        return await this.searchWithOptions(request, headers, runtime);
    }
    async searchTemplatesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.param)) {
            body["param"] = request.param;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SearchTemplates",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/templates/search`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SearchTemplatesResponse({}));
    }
    async searchTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchTemplatesHeaders({});
        return await this.searchTemplatesWithOptions(request, headers, runtime);
    }
    async teamTemplatesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TeamTemplates",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/workspaces/templates/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new TeamTemplatesResponse({}));
    }
    async teamTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TeamTemplatesHeaders({});
        return await this.teamTemplatesWithOptions(request, headers, runtime);
    }
    async templateCategoriesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.param)) {
            body["param"] = request.param;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "TemplateCategories",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/templates/categories/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new TemplateCategoriesResponse({}));
    }
    async templateCategories(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new TemplateCategoriesHeaders({});
        return await this.templateCategoriesWithOptions(request, headers, runtime);
    }
    async unmarkStarWithOptions(dentryUuid, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnmarkStar",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/dentries/${dentryUuid}/stars/unmark`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UnmarkStarResponse({}));
    }
    async unmarkStar(dentryUuid, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UnmarkStarHeaders({});
        return await this.unmarkStarWithOptions(dentryUuid, request, headers, runtime);
    }
    async unpinSpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "UnpinSpace",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/spaces/${spaceId}/unpin`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UnpinSpaceResponse({}));
    }
    async unpinSpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UnpinSpaceHeaders({});
        return await this.unpinSpaceWithOptions(spaceId, request, headers, runtime);
    }
    async updateTeamWithOptions(teamId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            body["operatorId"] = request.operatorId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateTeam",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/teams/${teamId}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateTeamResponse({}));
    }
    async updateTeam(teamId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateTeamHeaders({});
        return await this.updateTeamWithOptions(teamId, request, headers, runtime);
    }
    async userTemplatesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorId)) {
            query["operatorId"] = request.operatorId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UserTemplates",
            version: "doc_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/doc/users/templates/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UserTemplatesResponse({}));
    }
    async userTemplates(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UserTemplatesHeaders({});
        return await this.userTemplatesWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map