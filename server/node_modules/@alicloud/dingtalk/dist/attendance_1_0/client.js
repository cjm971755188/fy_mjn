"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class ResultDurationSettingsValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            calcType: 'calcType',
            durationType: 'durationType',
            overtimeRedress: 'overtimeRedress',
            settings: 'settings',
            overtimeRedressBy: 'overtimeRedressBy',
            vacationRate: 'vacationRate',
            skipTime: 'skipTime',
            skipTimeByFrames: 'skipTimeByFrames',
            skipTimeByDurations: 'skipTimeByDurations',
            holidayPlanOvertimeRedress: 'holidayPlanOvertimeRedress',
            holidayPlanOvertimeRedressBy: 'holidayPlanOvertimeRedressBy',
            holidayPlanVacationRate: 'holidayPlanVacationRate',
        };
    }
    static types() {
        return {
            calcType: 'number',
            durationType: 'number',
            overtimeRedress: 'boolean',
            settings: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            overtimeRedressBy: 'string',
            vacationRate: 'number',
            skipTime: 'string',
            skipTimeByFrames: { 'type': 'array', 'itemType': ResultDurationSettingsValueSkipTimeByFrames },
            skipTimeByDurations: { 'type': 'array', 'itemType': ResultDurationSettingsValueSkipTimeByDurations },
            holidayPlanOvertimeRedress: 'boolean',
            holidayPlanOvertimeRedressBy: 'string',
            holidayPlanVacationRate: 'number',
        };
    }
}
exports.ResultDurationSettingsValue = ResultDurationSettingsValue;
class AddLeaveTypeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddLeaveTypeHeaders = AddLeaveTypeHeaders;
class AddLeaveTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            extras: 'extras',
            freedomLeave: 'freedomLeave',
            hoursInPerDay: 'hoursInPerDay',
            leaveCertificate: 'leaveCertificate',
            leaveHourCeil: 'leaveHourCeil',
            leaveName: 'leaveName',
            leaveTimeCeil: 'leaveTimeCeil',
            leaveTimeCeilMinUnit: 'leaveTimeCeilMinUnit',
            leaveViewUnit: 'leaveViewUnit',
            maxLeaveTime: 'maxLeaveTime',
            minLeaveHour: 'minLeaveHour',
            naturalDayLeave: 'naturalDayLeave',
            paidLeave: 'paidLeave',
            submitTimeRule: 'submitTimeRule',
            visibilityRules: 'visibilityRules',
            whenCanLeave: 'whenCanLeave',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            extras: 'string',
            freedomLeave: 'boolean',
            hoursInPerDay: 'number',
            leaveCertificate: AddLeaveTypeRequestLeaveCertificate,
            leaveHourCeil: 'string',
            leaveName: 'string',
            leaveTimeCeil: 'boolean',
            leaveTimeCeilMinUnit: 'string',
            leaveViewUnit: 'string',
            maxLeaveTime: 'number',
            minLeaveHour: 'number',
            naturalDayLeave: 'boolean',
            paidLeave: 'boolean',
            submitTimeRule: AddLeaveTypeRequestSubmitTimeRule,
            visibilityRules: { 'type': 'array', 'itemType': AddLeaveTypeRequestVisibilityRules },
            whenCanLeave: 'string',
            opUserId: 'string',
        };
    }
}
exports.AddLeaveTypeRequest = AddLeaveTypeRequest;
class AddLeaveTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: AddLeaveTypeResponseBodyResult,
        };
    }
}
exports.AddLeaveTypeResponseBody = AddLeaveTypeResponseBody;
class AddLeaveTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddLeaveTypeResponseBody,
        };
    }
}
exports.AddLeaveTypeResponse = AddLeaveTypeResponse;
class AttendanceBleDevicesAddHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AttendanceBleDevicesAddHeaders = AttendanceBleDevicesAddHeaders;
class AttendanceBleDevicesAddRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceIdList: 'deviceIdList',
            groupKey: 'groupKey',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            deviceIdList: { 'type': 'array', 'itemType': 'number' },
            groupKey: 'string',
            opUserId: 'string',
        };
    }
}
exports.AttendanceBleDevicesAddRequest = AttendanceBleDevicesAddRequest;
class AttendanceBleDevicesAddResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorList: 'errorList',
            successList: 'successList',
        };
    }
    static types() {
        return {
            errorList: { 'type': 'array', 'itemType': AttendanceBleDevicesAddResponseBodyErrorList },
            successList: { 'type': 'array', 'itemType': AttendanceBleDevicesAddResponseBodySuccessList },
        };
    }
}
exports.AttendanceBleDevicesAddResponseBody = AttendanceBleDevicesAddResponseBody;
class AttendanceBleDevicesAddResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AttendanceBleDevicesAddResponseBody,
        };
    }
}
exports.AttendanceBleDevicesAddResponse = AttendanceBleDevicesAddResponse;
class AttendanceBleDevicesQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AttendanceBleDevicesQueryHeaders = AttendanceBleDevicesQueryHeaders;
class AttendanceBleDevicesQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupKey: 'groupKey',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            groupKey: 'string',
            opUserId: 'string',
        };
    }
}
exports.AttendanceBleDevicesQueryRequest = AttendanceBleDevicesQueryRequest;
class AttendanceBleDevicesQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': AttendanceBleDevicesQueryResponseBodyResult },
        };
    }
}
exports.AttendanceBleDevicesQueryResponseBody = AttendanceBleDevicesQueryResponseBody;
class AttendanceBleDevicesQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AttendanceBleDevicesQueryResponseBody,
        };
    }
}
exports.AttendanceBleDevicesQueryResponse = AttendanceBleDevicesQueryResponse;
class AttendanceBleDevicesRemoveHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AttendanceBleDevicesRemoveHeaders = AttendanceBleDevicesRemoveHeaders;
class AttendanceBleDevicesRemoveRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceIdList: 'deviceIdList',
            groupKey: 'groupKey',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            deviceIdList: { 'type': 'array', 'itemType': 'number' },
            groupKey: 'string',
            opUserId: 'string',
        };
    }
}
exports.AttendanceBleDevicesRemoveRequest = AttendanceBleDevicesRemoveRequest;
class AttendanceBleDevicesRemoveResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorList: 'errorList',
            successList: 'successList',
        };
    }
    static types() {
        return {
            errorList: { 'type': 'array', 'itemType': AttendanceBleDevicesRemoveResponseBodyErrorList },
            successList: { 'type': 'array', 'itemType': 'number' },
        };
    }
}
exports.AttendanceBleDevicesRemoveResponseBody = AttendanceBleDevicesRemoveResponseBody;
class AttendanceBleDevicesRemoveResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AttendanceBleDevicesRemoveResponseBody,
        };
    }
}
exports.AttendanceBleDevicesRemoveResponse = AttendanceBleDevicesRemoveResponse;
class BatchBossCheckHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchBossCheckHeaders = BatchBossCheckHeaders;
class BatchBossCheckRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            models: 'models',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            models: { 'type': 'array', 'itemType': BatchBossCheckRequestModels },
            opUserId: 'string',
        };
    }
}
exports.BatchBossCheckRequest = BatchBossCheckRequest;
class BatchBossCheckResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.BatchBossCheckResponseBody = BatchBossCheckResponseBody;
class BatchBossCheckResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchBossCheckResponseBody,
        };
    }
}
exports.BatchBossCheckResponse = BatchBossCheckResponse;
class CalculateDurationHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CalculateDurationHeaders = CalculateDurationHeaders;
class CalculateDurationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            calculateModel: 'calculateModel',
            durationUnit: 'durationUnit',
            fromTime: 'fromTime',
            leaveCode: 'leaveCode',
            toTime: 'toTime',
            userId: 'userId',
        };
    }
    static types() {
        return {
            bizType: 'number',
            calculateModel: 'number',
            durationUnit: 'string',
            fromTime: 'string',
            leaveCode: 'string',
            toTime: 'string',
            userId: 'string',
        };
    }
}
exports.CalculateDurationRequest = CalculateDurationRequest;
class CalculateDurationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: CalculateDurationResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.CalculateDurationResponseBody = CalculateDurationResponseBody;
class CalculateDurationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CalculateDurationResponseBody,
        };
    }
}
exports.CalculateDurationResponse = CalculateDurationResponse;
class CheckClosingAccountHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CheckClosingAccountHeaders = CheckClosingAccountHeaders;
class CheckClosingAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            userIds: 'userIds',
            userTimeRange: 'userTimeRange',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
            userTimeRange: { 'type': 'array', 'itemType': CheckClosingAccountRequestUserTimeRange },
        };
    }
}
exports.CheckClosingAccountRequest = CheckClosingAccountRequest;
class CheckClosingAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            mesage: 'mesage',
            pass: 'pass',
        };
    }
    static types() {
        return {
            code: 'string',
            mesage: 'string',
            pass: 'boolean',
        };
    }
}
exports.CheckClosingAccountResponseBody = CheckClosingAccountResponseBody;
class CheckClosingAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckClosingAccountResponseBody,
        };
    }
}
exports.CheckClosingAccountResponse = CheckClosingAccountResponse;
class CheckWritePermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CheckWritePermissionHeaders = CheckWritePermissionHeaders;
class CheckWritePermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'category',
            entityIds: 'entityIds',
            opUserId: 'opUserId',
            resourceKey: 'resourceKey',
        };
    }
    static types() {
        return {
            category: 'string',
            entityIds: { 'type': 'array', 'itemType': 'number' },
            opUserId: 'string',
            resourceKey: 'string',
        };
    }
}
exports.CheckWritePermissionRequest = CheckWritePermissionRequest;
class CheckWritePermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            entityPermissionMap: 'entityPermissionMap',
        };
    }
    static types() {
        return {
            entityPermissionMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'boolean' },
        };
    }
}
exports.CheckWritePermissionResponseBody = CheckWritePermissionResponseBody;
class CheckWritePermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CheckWritePermissionResponseBody,
        };
    }
}
exports.CheckWritePermissionResponse = CheckWritePermissionResponse;
class CreateApproveHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateApproveHeaders = CreateApproveHeaders;
class CreateApproveRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            approveId: 'approveId',
            opUserid: 'opUserid',
            punchParam: 'punchParam',
            subType: 'subType',
            tagName: 'tagName',
            userid: 'userid',
        };
    }
    static types() {
        return {
            approveId: 'string',
            opUserid: 'string',
            punchParam: CreateApproveRequestPunchParam,
            subType: 'string',
            tagName: 'string',
            userid: 'string',
        };
    }
}
exports.CreateApproveRequest = CreateApproveRequest;
class CreateApproveResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingtalkApproveId: 'dingtalkApproveId',
        };
    }
    static types() {
        return {
            dingtalkApproveId: 'string',
        };
    }
}
exports.CreateApproveResponseBody = CreateApproveResponseBody;
class CreateApproveResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateApproveResponseBody,
        };
    }
}
exports.CreateApproveResponse = CreateApproveResponse;
class DeleteWaterMarkTemplateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteWaterMarkTemplateHeaders = DeleteWaterMarkTemplateHeaders;
class DeleteWaterMarkTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            formCode: 'formCode',
            formContent: 'formContent',
            openConversationId: 'openConversationId',
            systemTemplate: 'systemTemplate',
            userId: 'userId',
        };
    }
    static types() {
        return {
            formCode: 'string',
            formContent: 'string',
            openConversationId: 'string',
            systemTemplate: 'boolean',
            userId: 'string',
        };
    }
}
exports.DeleteWaterMarkTemplateRequest = DeleteWaterMarkTemplateRequest;
class DeleteWaterMarkTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.DeleteWaterMarkTemplateResponseBody = DeleteWaterMarkTemplateResponseBody;
class DeleteWaterMarkTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteWaterMarkTemplateResponseBody,
        };
    }
}
exports.DeleteWaterMarkTemplateResponse = DeleteWaterMarkTemplateResponse;
class DingTalkSecurityCheckHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DingTalkSecurityCheckHeaders = DingTalkSecurityCheckHeaders;
class DingTalkSecurityCheckRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            clientVer: 'clientVer',
            platform: 'platform',
            platformVer: 'platformVer',
            sec: 'sec',
            userId: 'userId',
        };
    }
    static types() {
        return {
            clientVer: 'string',
            platform: 'string',
            platformVer: 'string',
            sec: 'string',
            userId: 'string',
        };
    }
}
exports.DingTalkSecurityCheckRequest = DingTalkSecurityCheckRequest;
class DingTalkSecurityCheckResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: DingTalkSecurityCheckResponseBodyResult,
        };
    }
}
exports.DingTalkSecurityCheckResponseBody = DingTalkSecurityCheckResponseBody;
class DingTalkSecurityCheckResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DingTalkSecurityCheckResponseBody,
        };
    }
}
exports.DingTalkSecurityCheckResponse = DingTalkSecurityCheckResponse;
class GetATManageScopeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetATManageScopeHeaders = GetATManageScopeHeaders;
class GetATManageScopeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            userId: 'userId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            userId: 'string',
        };
    }
}
exports.GetATManageScopeRequest = GetATManageScopeRequest;
class GetATManageScopeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetATManageScopeResponseBodyResult },
        };
    }
}
exports.GetATManageScopeResponseBody = GetATManageScopeResponseBody;
class GetATManageScopeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetATManageScopeResponseBody,
        };
    }
}
exports.GetATManageScopeResponse = GetATManageScopeResponse;
class GetAdjustmentsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetAdjustmentsHeaders = GetAdjustmentsHeaders;
class GetAdjustmentsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
}
exports.GetAdjustmentsRequest = GetAdjustmentsRequest;
class GetAdjustmentsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetAdjustmentsResponseBodyResult,
        };
    }
}
exports.GetAdjustmentsResponseBody = GetAdjustmentsResponseBody;
class GetAdjustmentsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAdjustmentsResponseBody,
        };
    }
}
exports.GetAdjustmentsResponse = GetAdjustmentsResponse;
class GetCheckInSchemaTemplateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCheckInSchemaTemplateHeaders = GetCheckInSchemaTemplateHeaders;
class GetCheckInSchemaTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            openConversationId: 'openConversationId',
            sceneCode: 'sceneCode',
            userId: 'userId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            openConversationId: 'string',
            sceneCode: 'string',
            userId: 'string',
        };
    }
}
exports.GetCheckInSchemaTemplateRequest = GetCheckInSchemaTemplateRequest;
class GetCheckInSchemaTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetCheckInSchemaTemplateResponseBodyResult,
        };
    }
}
exports.GetCheckInSchemaTemplateResponseBody = GetCheckInSchemaTemplateResponseBody;
class GetCheckInSchemaTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCheckInSchemaTemplateResponseBody,
        };
    }
}
exports.GetCheckInSchemaTemplateResponse = GetCheckInSchemaTemplateResponse;
class GetCheckinRecordByUserHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCheckinRecordByUserHeaders = GetCheckinRecordByUserHeaders;
class GetCheckinRecordByUserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operatorUserId: 'operatorUserId',
            startTime: 'startTime',
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            endTime: 'number',
            maxResults: 'number',
            nextToken: 'number',
            operatorUserId: 'string',
            startTime: 'number',
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetCheckinRecordByUserRequest = GetCheckinRecordByUserRequest;
class GetCheckinRecordByUserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetCheckinRecordByUserResponseBodyResult,
        };
    }
}
exports.GetCheckinRecordByUserResponseBody = GetCheckinRecordByUserResponseBody;
class GetCheckinRecordByUserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCheckinRecordByUserResponseBody,
        };
    }
}
exports.GetCheckinRecordByUserResponse = GetCheckinRecordByUserResponse;
class GetClosingAccountsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetClosingAccountsHeaders = GetClosingAccountsHeaders;
class GetClosingAccountsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetClosingAccountsRequest = GetClosingAccountsRequest;
class GetClosingAccountsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetClosingAccountsResponseBodyResult },
        };
    }
}
exports.GetClosingAccountsResponseBody = GetClosingAccountsResponseBody;
class GetClosingAccountsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetClosingAccountsResponseBody,
        };
    }
}
exports.GetClosingAccountsResponse = GetClosingAccountsResponse;
class GetLeaveRecordsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetLeaveRecordsHeaders = GetLeaveRecordsHeaders;
class GetLeaveRecordsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            leaveCode: 'leaveCode',
            opUserId: 'opUserId',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            leaveCode: 'string',
            opUserId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetLeaveRecordsRequest = GetLeaveRecordsRequest;
class GetLeaveRecordsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: GetLeaveRecordsResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.GetLeaveRecordsResponseBody = GetLeaveRecordsResponseBody;
class GetLeaveRecordsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetLeaveRecordsResponseBody,
        };
    }
}
exports.GetLeaveRecordsResponse = GetLeaveRecordsResponse;
class GetLeaveTypeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetLeaveTypeHeaders = GetLeaveTypeHeaders;
class GetLeaveTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            opUserId: 'opUserId',
            vacationSource: 'vacationSource',
        };
    }
    static types() {
        return {
            opUserId: 'string',
            vacationSource: 'string',
        };
    }
}
exports.GetLeaveTypeRequest = GetLeaveTypeRequest;
class GetLeaveTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetLeaveTypeResponseBodyResult },
        };
    }
}
exports.GetLeaveTypeResponseBody = GetLeaveTypeResponseBody;
class GetLeaveTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetLeaveTypeResponseBody,
        };
    }
}
exports.GetLeaveTypeResponse = GetLeaveTypeResponse;
class GetMachineHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetMachineHeaders = GetMachineHeaders;
class GetMachineResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetMachineResponseBodyResult,
        };
    }
}
exports.GetMachineResponseBody = GetMachineResponseBody;
class GetMachineResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMachineResponseBody,
        };
    }
}
exports.GetMachineResponse = GetMachineResponse;
class GetMachineUserHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetMachineUserHeaders = GetMachineUserHeaders;
class GetMachineUserRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.GetMachineUserRequest = GetMachineUserRequest;
class GetMachineUserResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetMachineUserResponseBodyResult,
        };
    }
}
exports.GetMachineUserResponseBody = GetMachineUserResponseBody;
class GetMachineUserResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMachineUserResponseBody,
        };
    }
}
exports.GetMachineUserResponse = GetMachineUserResponse;
class GetOvertimeSettingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetOvertimeSettingHeaders = GetOvertimeSettingHeaders;
class GetOvertimeSettingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            overtimeSettingIds: 'overtimeSettingIds',
        };
    }
    static types() {
        return {
            overtimeSettingIds: { 'type': 'array', 'itemType': 'number' },
        };
    }
}
exports.GetOvertimeSettingRequest = GetOvertimeSettingRequest;
class GetOvertimeSettingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetOvertimeSettingResponseBodyResult },
        };
    }
}
exports.GetOvertimeSettingResponseBody = GetOvertimeSettingResponseBody;
class GetOvertimeSettingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOvertimeSettingResponseBody,
        };
    }
}
exports.GetOvertimeSettingResponse = GetOvertimeSettingResponse;
class GetShiftHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetShiftHeaders = GetShiftHeaders;
class GetShiftRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            opUserId: 'opUserId',
            shiftId: 'shiftId',
        };
    }
    static types() {
        return {
            opUserId: 'string',
            shiftId: 'number',
        };
    }
}
exports.GetShiftRequest = GetShiftRequest;
class GetShiftResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetShiftResponseBodyResult,
        };
    }
}
exports.GetShiftResponseBody = GetShiftResponseBody;
class GetShiftResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetShiftResponseBody,
        };
    }
}
exports.GetShiftResponse = GetShiftResponse;
class GetSimpleOvertimeSettingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSimpleOvertimeSettingHeaders = GetSimpleOvertimeSettingHeaders;
class GetSimpleOvertimeSettingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
}
exports.GetSimpleOvertimeSettingRequest = GetSimpleOvertimeSettingRequest;
class GetSimpleOvertimeSettingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: GetSimpleOvertimeSettingResponseBodyResult,
        };
    }
}
exports.GetSimpleOvertimeSettingResponseBody = GetSimpleOvertimeSettingResponseBody;
class GetSimpleOvertimeSettingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSimpleOvertimeSettingResponseBody,
        };
    }
}
exports.GetSimpleOvertimeSettingResponse = GetSimpleOvertimeSettingResponse;
class GetUserHolidaysHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetUserHolidaysHeaders = GetUserHolidaysHeaders;
class GetUserHolidaysRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userIds: 'userIds',
            workDateFrom: 'workDateFrom',
            workDateTo: 'workDateTo',
        };
    }
    static types() {
        return {
            userIds: { 'type': 'array', 'itemType': 'string' },
            workDateFrom: 'number',
            workDateTo: 'number',
        };
    }
}
exports.GetUserHolidaysRequest = GetUserHolidaysRequest;
class GetUserHolidaysResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetUserHolidaysResponseBodyResult },
        };
    }
}
exports.GetUserHolidaysResponseBody = GetUserHolidaysResponseBody;
class GetUserHolidaysResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserHolidaysResponseBody,
        };
    }
}
exports.GetUserHolidaysResponse = GetUserHolidaysResponse;
class GroupAddHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GroupAddHeaders = GroupAddHeaders;
class GroupAddRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustmentSettingId: 'adjustmentSettingId',
            bleDeviceList: 'bleDeviceList',
            checkNeedHealthyCode: 'checkNeedHealthyCode',
            defaultClassId: 'defaultClassId',
            disableCheckWhenRest: 'disableCheckWhenRest',
            disableCheckWithoutSchedule: 'disableCheckWithoutSchedule',
            enableCameraCheck: 'enableCameraCheck',
            enableEmpSelectClass: 'enableEmpSelectClass',
            enableFaceCheck: 'enableFaceCheck',
            enableFaceStrictMode: 'enableFaceStrictMode',
            enableNextDay: 'enableNextDay',
            enableOutSideUpdateNormalCheck: 'enableOutSideUpdateNormalCheck',
            enableOutsideApply: 'enableOutsideApply',
            enableOutsideCameraCheck: 'enableOutsideCameraCheck',
            enableOutsideCheck: 'enableOutsideCheck',
            enableOutsideRemark: 'enableOutsideRemark',
            enablePositionBle: 'enablePositionBle',
            enableTrimDistance: 'enableTrimDistance',
            forbidHideOutSideAddress: 'forbidHideOutSideAddress',
            freeCheckSetting: 'freeCheckSetting',
            freeCheckTypeId: 'freeCheckTypeId',
            freecheckDayStartMinOffset: 'freecheckDayStartMinOffset',
            freecheckWorkDays: 'freecheckWorkDays',
            groupId: 'groupId',
            groupName: 'groupName',
            managerList: 'managerList',
            members: 'members',
            modifyMember: 'modifyMember',
            offset: 'offset',
            openCameraCheck: 'openCameraCheck',
            openFaceCheck: 'openFaceCheck',
            outsideCheckApproveModeId: 'outsideCheckApproveModeId',
            overtimeSettingId: 'overtimeSettingId',
            owner: 'owner',
            positions: 'positions',
            resourcePermissionMap: 'resourcePermissionMap',
            shiftVOList: 'shiftVOList',
            skipHolidays: 'skipHolidays',
            specialDays: 'specialDays',
            trimDistance: 'trimDistance',
            type: 'type',
            wifis: 'wifis',
            workdayClassList: 'workdayClassList',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            adjustmentSettingId: 'number',
            bleDeviceList: { 'type': 'array', 'itemType': GroupAddRequestBleDeviceList },
            checkNeedHealthyCode: 'boolean',
            defaultClassId: 'number',
            disableCheckWhenRest: 'boolean',
            disableCheckWithoutSchedule: 'boolean',
            enableCameraCheck: 'boolean',
            enableEmpSelectClass: 'boolean',
            enableFaceCheck: 'boolean',
            enableFaceStrictMode: 'boolean',
            enableNextDay: 'boolean',
            enableOutSideUpdateNormalCheck: 'boolean',
            enableOutsideApply: 'boolean',
            enableOutsideCameraCheck: 'boolean',
            enableOutsideCheck: 'boolean',
            enableOutsideRemark: 'boolean',
            enablePositionBle: 'boolean',
            enableTrimDistance: 'boolean',
            forbidHideOutSideAddress: 'boolean',
            freeCheckSetting: GroupAddRequestFreeCheckSetting,
            freeCheckTypeId: 'number',
            freecheckDayStartMinOffset: 'number',
            freecheckWorkDays: { 'type': 'array', 'itemType': 'number' },
            groupId: 'number',
            groupName: 'string',
            managerList: { 'type': 'array', 'itemType': 'string' },
            members: { 'type': 'array', 'itemType': GroupAddRequestMembers },
            modifyMember: 'boolean',
            offset: 'number',
            openCameraCheck: 'boolean',
            openFaceCheck: 'boolean',
            outsideCheckApproveModeId: 'number',
            overtimeSettingId: 'number',
            owner: 'string',
            positions: { 'type': 'array', 'itemType': GroupAddRequestPositions },
            resourcePermissionMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            shiftVOList: { 'type': 'array', 'itemType': GroupAddRequestShiftVOList },
            skipHolidays: 'boolean',
            specialDays: 'string',
            trimDistance: 'number',
            type: 'string',
            wifis: { 'type': 'array', 'itemType': GroupAddRequestWifis },
            workdayClassList: { 'type': 'array', 'itemType': 'number' },
            opUserId: 'string',
        };
    }
}
exports.GroupAddRequest = GroupAddRequest;
class GroupAddResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: GroupAddResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.GroupAddResponseBody = GroupAddResponseBody;
class GroupAddResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GroupAddResponseBody,
        };
    }
}
exports.GroupAddResponse = GroupAddResponse;
class GroupUpdateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GroupUpdateHeaders = GroupUpdateHeaders;
class GroupUpdateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            adjustmentSettingId: 'adjustmentSettingId',
            disableCheckWhenRest: 'disableCheckWhenRest',
            disableCheckWithoutSchedule: 'disableCheckWithoutSchedule',
            enableCameraCheck: 'enableCameraCheck',
            enableEmpSelectClass: 'enableEmpSelectClass',
            enableFaceCheck: 'enableFaceCheck',
            enableFaceStrictMode: 'enableFaceStrictMode',
            enableOutSideUpdateNormalCheck: 'enableOutSideUpdateNormalCheck',
            enableOutsideApply: 'enableOutsideApply',
            enableOutsideCheck: 'enableOutsideCheck',
            enableOutsideRemark: 'enableOutsideRemark',
            enableTrimDistance: 'enableTrimDistance',
            forbidHideOutSideAddress: 'forbidHideOutSideAddress',
            freeCheckSetting: 'freeCheckSetting',
            freeCheckTypeId: 'freeCheckTypeId',
            groupId: 'groupId',
            groupName: 'groupName',
            managerList: 'managerList',
            offset: 'offset',
            openCameraCheck: 'openCameraCheck',
            openFaceCheck: 'openFaceCheck',
            outsideCheckApproveModeId: 'outsideCheckApproveModeId',
            overtimeSettingId: 'overtimeSettingId',
            owner: 'owner',
            positions: 'positions',
            resourcePermissionMap: 'resourcePermissionMap',
            shiftVOList: 'shiftVOList',
            skipHolidays: 'skipHolidays',
            trimDistance: 'trimDistance',
            workdayClassList: 'workdayClassList',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            adjustmentSettingId: 'number',
            disableCheckWhenRest: 'boolean',
            disableCheckWithoutSchedule: 'boolean',
            enableCameraCheck: 'boolean',
            enableEmpSelectClass: 'boolean',
            enableFaceCheck: 'boolean',
            enableFaceStrictMode: 'boolean',
            enableOutSideUpdateNormalCheck: 'boolean',
            enableOutsideApply: 'boolean',
            enableOutsideCheck: 'boolean',
            enableOutsideRemark: 'boolean',
            enableTrimDistance: 'boolean',
            forbidHideOutSideAddress: 'boolean',
            freeCheckSetting: GroupUpdateRequestFreeCheckSetting,
            freeCheckTypeId: 'number',
            groupId: 'number',
            groupName: 'string',
            managerList: { 'type': 'array', 'itemType': 'string' },
            offset: 'number',
            openCameraCheck: 'boolean',
            openFaceCheck: 'boolean',
            outsideCheckApproveModeId: 'number',
            overtimeSettingId: 'number',
            owner: 'string',
            positions: { 'type': 'array', 'itemType': GroupUpdateRequestPositions },
            resourcePermissionMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            shiftVOList: { 'type': 'array', 'itemType': GroupUpdateRequestShiftVOList },
            skipHolidays: 'boolean',
            trimDistance: 'number',
            workdayClassList: { 'type': 'array', 'itemType': 'number' },
            opUserId: 'string',
        };
    }
}
exports.GroupUpdateRequest = GroupUpdateRequest;
class GroupUpdateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: GroupUpdateResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.GroupUpdateResponseBody = GroupUpdateResponseBody;
class GroupUpdateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GroupUpdateResponseBody,
        };
    }
}
exports.GroupUpdateResponse = GroupUpdateResponse;
class InitAndGetLeaveALlocationQuotasHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.InitAndGetLeaveALlocationQuotasHeaders = InitAndGetLeaveALlocationQuotasHeaders;
class InitAndGetLeaveALlocationQuotasRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            leaveCode: 'leaveCode',
            opUserId: 'opUserId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            leaveCode: 'string',
            opUserId: 'string',
            userId: 'string',
        };
    }
}
exports.InitAndGetLeaveALlocationQuotasRequest = InitAndGetLeaveALlocationQuotasRequest;
class InitAndGetLeaveALlocationQuotasResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': InitAndGetLeaveALlocationQuotasResponseBodyResult },
        };
    }
}
exports.InitAndGetLeaveALlocationQuotasResponseBody = InitAndGetLeaveALlocationQuotasResponseBody;
class InitAndGetLeaveALlocationQuotasResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InitAndGetLeaveALlocationQuotasResponseBody,
        };
    }
}
exports.InitAndGetLeaveALlocationQuotasResponse = InitAndGetLeaveALlocationQuotasResponse;
class ListApproveByUsersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListApproveByUsersHeaders = ListApproveByUsersHeaders;
class ListApproveByUsersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizTypes: 'bizTypes',
            fromDateTime: 'fromDateTime',
            toDateTime: 'toDateTime',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            bizTypes: { 'type': 'array', 'itemType': 'number' },
            fromDateTime: 'number',
            toDateTime: 'number',
            userIds: 'string',
        };
    }
}
exports.ListApproveByUsersRequest = ListApproveByUsersRequest;
class ListApproveByUsersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': ListApproveByUsersResponseBodyResult },
        };
    }
}
exports.ListApproveByUsersResponseBody = ListApproveByUsersResponseBody;
class ListApproveByUsersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListApproveByUsersResponseBody,
        };
    }
}
exports.ListApproveByUsersResponse = ListApproveByUsersResponse;
class ModifyWaterMarkTemplateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ModifyWaterMarkTemplateHeaders = ModifyWaterMarkTemplateHeaders;
class ModifyWaterMarkTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            formCode: 'formCode',
            icon: 'icon',
            layoutDesignId: 'layoutDesignId',
            schemaContent: 'schemaContent',
            title: 'title',
            waterMarkId: 'waterMarkId',
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            formCode: 'string',
            icon: 'string',
            layoutDesignId: 'string',
            schemaContent: 'string',
            title: 'string',
            waterMarkId: 'string',
            openConversationId: 'string',
            userId: 'string',
        };
    }
}
exports.ModifyWaterMarkTemplateRequest = ModifyWaterMarkTemplateRequest;
class ModifyWaterMarkTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.ModifyWaterMarkTemplateResponseBody = ModifyWaterMarkTemplateResponseBody;
class ModifyWaterMarkTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ModifyWaterMarkTemplateResponseBody,
        };
    }
}
exports.ModifyWaterMarkTemplateResponse = ModifyWaterMarkTemplateResponse;
class ProcessApproveCreateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ProcessApproveCreateHeaders = ProcessApproveCreateHeaders;
class ProcessApproveCreateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            approveId: 'approveId',
            opUserId: 'opUserId',
            punchParam: 'punchParam',
            subType: 'subType',
            tagName: 'tagName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            approveId: 'string',
            opUserId: 'string',
            punchParam: ProcessApproveCreateRequestPunchParam,
            subType: 'string',
            tagName: 'string',
            userId: 'string',
        };
    }
}
exports.ProcessApproveCreateRequest = ProcessApproveCreateRequest;
class ProcessApproveCreateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: ProcessApproveCreateResponseBodyResult,
        };
    }
}
exports.ProcessApproveCreateResponseBody = ProcessApproveCreateResponseBody;
class ProcessApproveCreateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ProcessApproveCreateResponseBody,
        };
    }
}
exports.ProcessApproveCreateResponse = ProcessApproveCreateResponse;
class ProcessApproveFinishHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ProcessApproveFinishHeaders = ProcessApproveFinishHeaders;
class ProcessApproveFinishRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            approveId: 'approveId',
            jumpUrl: 'jumpUrl',
            overTimeToMore: 'overTimeToMore',
            overtimeDuration: 'overtimeDuration',
            subType: 'subType',
            tagName: 'tagName',
            topCalculateApproveDurationParam: 'topCalculateApproveDurationParam',
            userId: 'userId',
        };
    }
    static types() {
        return {
            approveId: 'string',
            jumpUrl: 'string',
            overTimeToMore: 'number',
            overtimeDuration: 'string',
            subType: 'string',
            tagName: 'string',
            topCalculateApproveDurationParam: ProcessApproveFinishRequestTopCalculateApproveDurationParam,
            userId: 'string',
        };
    }
}
exports.ProcessApproveFinishRequest = ProcessApproveFinishRequest;
class ProcessApproveFinishResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: ProcessApproveFinishResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.ProcessApproveFinishResponseBody = ProcessApproveFinishResponseBody;
class ProcessApproveFinishResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ProcessApproveFinishResponseBody,
        };
    }
}
exports.ProcessApproveFinishResponse = ProcessApproveFinishResponse;
class ReduceQuotaWithLeaveRecordHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ReduceQuotaWithLeaveRecordHeaders = ReduceQuotaWithLeaveRecordHeaders;
class ReduceQuotaWithLeaveRecordRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            leaveCode: 'leaveCode',
            outerId: 'outerId',
            quotaNum: 'quotaNum',
            reason: 'reason',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            endTime: 'number',
            leaveCode: 'string',
            outerId: 'string',
            quotaNum: 'number',
            reason: 'string',
            startTime: 'number',
        };
    }
}
exports.ReduceQuotaWithLeaveRecordRequest = ReduceQuotaWithLeaveRecordRequest;
class ReduceQuotaWithLeaveRecordResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: 'boolean',
            success: 'boolean',
        };
    }
}
exports.ReduceQuotaWithLeaveRecordResponseBody = ReduceQuotaWithLeaveRecordResponseBody;
class ReduceQuotaWithLeaveRecordResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReduceQuotaWithLeaveRecordResponseBody,
        };
    }
}
exports.ReduceQuotaWithLeaveRecordResponse = ReduceQuotaWithLeaveRecordResponse;
class RetainLeaveTypesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RetainLeaveTypesHeaders = RetainLeaveTypesHeaders;
class RetainLeaveTypesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            leaveCodes: 'leaveCodes',
            opUserId: 'opUserId',
            source: 'source',
        };
    }
    static types() {
        return {
            leaveCodes: { 'type': 'array', 'itemType': 'string' },
            opUserId: 'string',
            source: 'number',
        };
    }
}
exports.RetainLeaveTypesRequest = RetainLeaveTypesRequest;
class RetainLeaveTypesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': RetainLeaveTypesResponseBodyResult },
        };
    }
}
exports.RetainLeaveTypesResponseBody = RetainLeaveTypesResponseBody;
class RetainLeaveTypesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RetainLeaveTypesResponseBody,
        };
    }
}
exports.RetainLeaveTypesResponse = RetainLeaveTypesResponse;
class ReverseTrialAdvancedLeaveHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ReverseTrialAdvancedLeaveHeaders = ReverseTrialAdvancedLeaveHeaders;
class ReverseTrialAdvancedLeaveRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            opUserId: 'opUserId',
            servCode: 'servCode',
        };
    }
    static types() {
        return {
            opUserId: 'string',
            servCode: 'number',
        };
    }
}
exports.ReverseTrialAdvancedLeaveRequest = ReverseTrialAdvancedLeaveRequest;
class ReverseTrialAdvancedLeaveResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: 'boolean',
            success: 'boolean',
        };
    }
}
exports.ReverseTrialAdvancedLeaveResponseBody = ReverseTrialAdvancedLeaveResponseBody;
class ReverseTrialAdvancedLeaveResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReverseTrialAdvancedLeaveResponseBody,
        };
    }
}
exports.ReverseTrialAdvancedLeaveResponse = ReverseTrialAdvancedLeaveResponse;
class SaveCustomWaterMarkTemplateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SaveCustomWaterMarkTemplateHeaders = SaveCustomWaterMarkTemplateHeaders;
class SaveCustomWaterMarkTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            icon: 'icon',
            layoutDesignId: 'layoutDesignId',
            sceneCode: 'sceneCode',
            schemaContent: 'schemaContent',
            title: 'title',
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            icon: 'string',
            layoutDesignId: 'string',
            sceneCode: 'string',
            schemaContent: 'string',
            title: 'string',
            openConversationId: 'string',
            userId: 'string',
        };
    }
}
exports.SaveCustomWaterMarkTemplateRequest = SaveCustomWaterMarkTemplateRequest;
class SaveCustomWaterMarkTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: SaveCustomWaterMarkTemplateResponseBodyResult,
        };
    }
}
exports.SaveCustomWaterMarkTemplateResponseBody = SaveCustomWaterMarkTemplateResponseBody;
class SaveCustomWaterMarkTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SaveCustomWaterMarkTemplateResponseBody,
        };
    }
}
exports.SaveCustomWaterMarkTemplateResponse = SaveCustomWaterMarkTemplateResponse;
class SyncScheduleInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SyncScheduleInfoHeaders = SyncScheduleInfoHeaders;
class SyncScheduleInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            opUserId: 'opUserId',
            scheduleInfos: 'scheduleInfos',
        };
    }
    static types() {
        return {
            opUserId: 'string',
            scheduleInfos: { 'type': 'array', 'itemType': SyncScheduleInfoRequestScheduleInfos },
        };
    }
}
exports.SyncScheduleInfoRequest = SyncScheduleInfoRequest;
class SyncScheduleInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.SyncScheduleInfoResponse = SyncScheduleInfoResponse;
class UpdateLeaveTypeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateLeaveTypeHeaders = UpdateLeaveTypeHeaders;
class UpdateLeaveTypeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            extras: 'extras',
            hoursInPerDay: 'hoursInPerDay',
            leaveCertificate: 'leaveCertificate',
            leaveCode: 'leaveCode',
            leaveName: 'leaveName',
            leaveViewUnit: 'leaveViewUnit',
            naturalDayLeave: 'naturalDayLeave',
            submitTimeRule: 'submitTimeRule',
            visibilityRules: 'visibilityRules',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            extras: 'string',
            hoursInPerDay: 'number',
            leaveCertificate: UpdateLeaveTypeRequestLeaveCertificate,
            leaveCode: 'string',
            leaveName: 'string',
            leaveViewUnit: 'string',
            naturalDayLeave: 'boolean',
            submitTimeRule: UpdateLeaveTypeRequestSubmitTimeRule,
            visibilityRules: { 'type': 'array', 'itemType': UpdateLeaveTypeRequestVisibilityRules },
            opUserId: 'string',
        };
    }
}
exports.UpdateLeaveTypeRequest = UpdateLeaveTypeRequest;
class UpdateLeaveTypeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: UpdateLeaveTypeResponseBodyResult,
        };
    }
}
exports.UpdateLeaveTypeResponseBody = UpdateLeaveTypeResponseBody;
class UpdateLeaveTypeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateLeaveTypeResponseBody,
        };
    }
}
exports.UpdateLeaveTypeResponse = UpdateLeaveTypeResponse;
class ResultDurationSettingsValueSkipTimeByFrames extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            startTime: 'startTime',
            endTime: 'endTime',
            valid: 'valid',
        };
    }
    static types() {
        return {
            startTime: 'string',
            endTime: 'string',
            valid: 'boolean',
        };
    }
}
exports.ResultDurationSettingsValueSkipTimeByFrames = ResultDurationSettingsValueSkipTimeByFrames;
class ResultDurationSettingsValueSkipTimeByDurations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            minus: 'minus',
        };
    }
    static types() {
        return {
            duration: 'number',
            minus: 'number',
        };
    }
}
exports.ResultDurationSettingsValueSkipTimeByDurations = ResultDurationSettingsValueSkipTimeByDurations;
class AddLeaveTypeRequestLeaveCertificate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            enable: 'enable',
            promptInformation: 'promptInformation',
            unit: 'unit',
        };
    }
    static types() {
        return {
            duration: 'number',
            enable: 'boolean',
            promptInformation: 'string',
            unit: 'string',
        };
    }
}
exports.AddLeaveTypeRequestLeaveCertificate = AddLeaveTypeRequestLeaveCertificate;
class AddLeaveTypeRequestSubmitTimeRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableTimeLimit: 'enableTimeLimit',
            timeType: 'timeType',
            timeUnit: 'timeUnit',
            timeValue: 'timeValue',
        };
    }
    static types() {
        return {
            enableTimeLimit: 'boolean',
            timeType: 'string',
            timeUnit: 'string',
            timeValue: 'number',
        };
    }
}
exports.AddLeaveTypeRequestSubmitTimeRule = AddLeaveTypeRequestSubmitTimeRule;
class AddLeaveTypeRequestVisibilityRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            visible: 'visible',
        };
    }
    static types() {
        return {
            type: 'string',
            visible: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.AddLeaveTypeRequestVisibilityRules = AddLeaveTypeRequestVisibilityRules;
class AddLeaveTypeResponseBodyResultLeaveCertificate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            enable: 'enable',
            promptInformation: 'promptInformation',
            unit: 'unit',
        };
    }
    static types() {
        return {
            duration: 'number',
            enable: 'boolean',
            promptInformation: 'string',
            unit: 'string',
        };
    }
}
exports.AddLeaveTypeResponseBodyResultLeaveCertificate = AddLeaveTypeResponseBodyResultLeaveCertificate;
class AddLeaveTypeResponseBodyResultSubmitTimeRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableTimeLimit: 'enableTimeLimit',
            timeType: 'timeType',
            timeUnit: 'timeUnit',
            timeValue: 'timeValue',
        };
    }
    static types() {
        return {
            enableTimeLimit: 'boolean',
            timeType: 'string',
            timeUnit: 'string',
            timeValue: 'number',
        };
    }
}
exports.AddLeaveTypeResponseBodyResultSubmitTimeRule = AddLeaveTypeResponseBodyResultSubmitTimeRule;
class AddLeaveTypeResponseBodyResultVisibilityRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            visible: 'visible',
        };
    }
    static types() {
        return {
            type: 'string',
            visible: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.AddLeaveTypeResponseBodyResultVisibilityRules = AddLeaveTypeResponseBodyResultVisibilityRules;
class AddLeaveTypeResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            hoursInPerDay: 'hoursInPerDay',
            leaveCertificate: 'leaveCertificate',
            leaveCode: 'leaveCode',
            leaveName: 'leaveName',
            leaveViewUnit: 'leaveViewUnit',
            naturalDayLeave: 'naturalDayLeave',
            submitTimeRule: 'submitTimeRule',
            visibilityRules: 'visibilityRules',
        };
    }
    static types() {
        return {
            bizType: 'string',
            hoursInPerDay: 'number',
            leaveCertificate: AddLeaveTypeResponseBodyResultLeaveCertificate,
            leaveCode: 'string',
            leaveName: 'string',
            leaveViewUnit: 'string',
            naturalDayLeave: 'boolean',
            submitTimeRule: AddLeaveTypeResponseBodyResultSubmitTimeRule,
            visibilityRules: { 'type': 'array', 'itemType': AddLeaveTypeResponseBodyResultVisibilityRules },
        };
    }
}
exports.AddLeaveTypeResponseBodyResult = AddLeaveTypeResponseBodyResult;
class AttendanceBleDevicesAddResponseBodyErrorListFailureList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'deviceId',
            deviceName: 'deviceName',
            sn: 'sn',
        };
    }
    static types() {
        return {
            deviceId: 'number',
            deviceName: 'string',
            sn: 'string',
        };
    }
}
exports.AttendanceBleDevicesAddResponseBodyErrorListFailureList = AttendanceBleDevicesAddResponseBodyErrorListFailureList;
class AttendanceBleDevicesAddResponseBodyErrorList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            failureList: 'failureList',
            msg: 'msg',
        };
    }
    static types() {
        return {
            code: 'string',
            failureList: { 'type': 'array', 'itemType': AttendanceBleDevicesAddResponseBodyErrorListFailureList },
            msg: 'string',
        };
    }
}
exports.AttendanceBleDevicesAddResponseBodyErrorList = AttendanceBleDevicesAddResponseBodyErrorList;
class AttendanceBleDevicesAddResponseBodySuccessList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'deviceId',
            deviceName: 'deviceName',
            sn: 'sn',
        };
    }
    static types() {
        return {
            deviceId: 'number',
            deviceName: 'string',
            sn: 'string',
        };
    }
}
exports.AttendanceBleDevicesAddResponseBodySuccessList = AttendanceBleDevicesAddResponseBodySuccessList;
class AttendanceBleDevicesQueryResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'deviceId',
            deviceName: 'deviceName',
            sn: 'sn',
        };
    }
    static types() {
        return {
            deviceId: 'number',
            deviceName: 'string',
            sn: 'string',
        };
    }
}
exports.AttendanceBleDevicesQueryResponseBodyResult = AttendanceBleDevicesQueryResponseBodyResult;
class AttendanceBleDevicesRemoveResponseBodyErrorList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            failureList: 'failureList',
            msg: 'msg',
        };
    }
    static types() {
        return {
            code: 'string',
            failureList: { 'type': 'array', 'itemType': 'number' },
            msg: 'string',
        };
    }
}
exports.AttendanceBleDevicesRemoveResponseBodyErrorList = AttendanceBleDevicesRemoveResponseBodyErrorList;
class BatchBossCheckRequestModels extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            absentMin: 'absentMin',
            planId: 'planId',
            remark: 'remark',
            timeResult: 'timeResult',
        };
    }
    static types() {
        return {
            absentMin: 'number',
            planId: 'number',
            remark: 'string',
            timeResult: 'string',
        };
    }
}
exports.BatchBossCheckRequestModels = BatchBossCheckRequestModels;
class CalculateDurationResponseBodyResultDurationDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            duration: 'duration',
        };
    }
    static types() {
        return {
            date: 'string',
            duration: 'number',
        };
    }
}
exports.CalculateDurationResponseBodyResultDurationDetail = CalculateDurationResponseBodyResultDurationDetail;
class CalculateDurationResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            durationDetail: 'durationDetail',
        };
    }
    static types() {
        return {
            duration: 'number',
            durationDetail: { 'type': 'array', 'itemType': CalculateDurationResponseBodyResultDurationDetail },
        };
    }
}
exports.CalculateDurationResponseBodyResult = CalculateDurationResponseBodyResult;
class CheckClosingAccountRequestUserTimeRange extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
        };
    }
    static types() {
        return {
            endTime: 'number',
            startTime: 'number',
        };
    }
}
exports.CheckClosingAccountRequestUserTimeRange = CheckClosingAccountRequestUserTimeRange;
class CreateApproveRequestPunchParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            positionId: 'positionId',
            positionName: 'positionName',
            positionType: 'positionType',
            punchTime: 'punchTime',
        };
    }
    static types() {
        return {
            positionId: 'string',
            positionName: 'string',
            positionType: 'string',
            punchTime: 'number',
        };
    }
}
exports.CreateApproveRequestPunchParam = CreateApproveRequestPunchParam;
class DingTalkSecurityCheckResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasRisk: 'hasRisk',
            riskInfo: 'riskInfo',
        };
    }
    static types() {
        return {
            hasRisk: 'boolean',
            riskInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.DingTalkSecurityCheckResponseBodyResult = DingTalkSecurityCheckResponseBodyResult;
class GetATManageScopeResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            manageScope: 'manageScope',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            manageScope: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetATManageScopeResponseBodyResult = GetATManageScopeResponseBodyResult;
class GetAdjustmentsResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
            settingId: 'settingId',
        };
    }
    static types() {
        return {
            id: 'number',
            name: 'string',
            settingId: 'number',
        };
    }
}
exports.GetAdjustmentsResponseBodyResultItems = GetAdjustmentsResponseBodyResultItems;
class GetAdjustmentsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
            pageNumber: 'pageNumber',
            totalPage: 'totalPage',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': GetAdjustmentsResponseBodyResultItems },
            pageNumber: 'number',
            totalPage: 'number',
        };
    }
}
exports.GetAdjustmentsResponseBodyResult = GetAdjustmentsResponseBodyResult;
class GetCheckInSchemaTemplateResponseBodyResultWaterMarkTemplateModels extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            canModify: 'canModify',
            formCode: 'formCode',
            icon: 'icon',
            layoutDesign: 'layoutDesign',
            sceneCode: 'sceneCode',
            schemaContent: 'schemaContent',
            suiteKey: 'suiteKey',
            systemTemplate: 'systemTemplate',
            title: 'title',
            waterMarkId: 'waterMarkId',
        };
    }
    static types() {
        return {
            canModify: 'boolean',
            formCode: 'string',
            icon: 'string',
            layoutDesign: 'string',
            sceneCode: 'string',
            schemaContent: 'string',
            suiteKey: 'string',
            systemTemplate: 'boolean',
            title: 'string',
            waterMarkId: 'string',
        };
    }
}
exports.GetCheckInSchemaTemplateResponseBodyResultWaterMarkTemplateModels = GetCheckInSchemaTemplateResponseBodyResultWaterMarkTemplateModels;
class GetCheckInSchemaTemplateResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            canModifyAndAddTemplate: 'canModifyAndAddTemplate',
            conversationAdmin: 'conversationAdmin',
            customTemplateMaxSize: 'customTemplateMaxSize',
            openConversationId: 'openConversationId',
            showStat: 'showStat',
            templateDegrade: 'templateDegrade',
            waterMarkTemplateModels: 'waterMarkTemplateModels',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            canModifyAndAddTemplate: 'boolean',
            conversationAdmin: 'boolean',
            customTemplateMaxSize: 'number',
            openConversationId: 'string',
            showStat: 'boolean',
            templateDegrade: 'boolean',
            waterMarkTemplateModels: { 'type': 'array', 'itemType': GetCheckInSchemaTemplateResponseBodyResultWaterMarkTemplateModels },
        };
    }
}
exports.GetCheckInSchemaTemplateResponseBodyResult = GetCheckInSchemaTemplateResponseBodyResult;
class GetCheckinRecordByUserResponseBodyResultPageListCustomDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            label: 'label',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            label: 'string',
            value: 'string',
        };
    }
}
exports.GetCheckinRecordByUserResponseBodyResultPageListCustomDataList = GetCheckinRecordByUserResponseBodyResultPageListCustomDataList;
class GetCheckinRecordByUserResponseBodyResultPageList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkinTime: 'checkinTime',
            customDataList: 'customDataList',
            detailPlace: 'detailPlace',
            imageList: 'imageList',
            latitude: 'latitude',
            longitude: 'longitude',
            place: 'place',
            remark: 'remark',
            userId: 'userId',
            visitUser: 'visitUser',
        };
    }
    static types() {
        return {
            checkinTime: 'number',
            customDataList: { 'type': 'array', 'itemType': GetCheckinRecordByUserResponseBodyResultPageListCustomDataList },
            detailPlace: 'string',
            imageList: { 'type': 'array', 'itemType': 'string' },
            latitude: 'string',
            longitude: 'string',
            place: 'string',
            remark: 'string',
            userId: 'string',
            visitUser: 'string',
        };
    }
}
exports.GetCheckinRecordByUserResponseBodyResultPageList = GetCheckinRecordByUserResponseBodyResultPageList;
class GetCheckinRecordByUserResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            pageList: 'pageList',
        };
    }
    static types() {
        return {
            nextToken: 'number',
            pageList: { 'type': 'array', 'itemType': GetCheckinRecordByUserResponseBodyResultPageList },
        };
    }
}
exports.GetCheckinRecordByUserResponseBodyResult = GetCheckinRecordByUserResponseBodyResult;
class GetClosingAccountsResponseBodyResultClosingAccountModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            closingDay: 'closingDay',
            closingHourMinutes: 'closingHourMinutes',
            endDay: 'endDay',
            endMonth: 'endMonth',
            startDay: 'startDay',
            startMonth: 'startMonth',
        };
    }
    static types() {
        return {
            closingDay: 'number',
            closingHourMinutes: 'number',
            endDay: 'number',
            endMonth: 'number',
            startDay: 'number',
            startMonth: 'number',
        };
    }
}
exports.GetClosingAccountsResponseBodyResultClosingAccountModel = GetClosingAccountsResponseBodyResultClosingAccountModel;
class GetClosingAccountsResponseBodyResultUnsealClosingAccountModel extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            invalidTimeStamp: 'invalidTimeStamp',
        };
    }
    static types() {
        return {
            invalidTimeStamp: 'number',
        };
    }
}
exports.GetClosingAccountsResponseBodyResultUnsealClosingAccountModel = GetClosingAccountsResponseBodyResultUnsealClosingAccountModel;
class GetClosingAccountsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            closingAccountModel: 'closingAccountModel',
            switchOn: 'switchOn',
            unsealClosingAccountModel: 'unsealClosingAccountModel',
            userId: 'userId',
        };
    }
    static types() {
        return {
            closingAccountModel: GetClosingAccountsResponseBodyResultClosingAccountModel,
            switchOn: 'boolean',
            unsealClosingAccountModel: GetClosingAccountsResponseBodyResultUnsealClosingAccountModel,
            userId: 'string',
        };
    }
}
exports.GetClosingAccountsResponseBodyResult = GetClosingAccountsResponseBodyResult;
class GetLeaveRecordsResponseBodyResultLeaveRecords extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            calType: 'calType',
            endTime: 'endTime',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            leaveCode: 'leaveCode',
            leaveReason: 'leaveReason',
            leaveRecordType: 'leaveRecordType',
            leaveStatus: 'leaveStatus',
            leaveViewUnit: 'leaveViewUnit',
            opUserId: 'opUserId',
            quotaId: 'quotaId',
            recordId: 'recordId',
            recordNumPerDay: 'recordNumPerDay',
            recordNumPerHour: 'recordNumPerHour',
            startTime: 'startTime',
            userId: 'userId',
        };
    }
    static types() {
        return {
            calType: 'string',
            endTime: 'number',
            gmtCreate: 'number',
            gmtModified: 'number',
            leaveCode: 'string',
            leaveReason: 'string',
            leaveRecordType: 'string',
            leaveStatus: 'string',
            leaveViewUnit: 'string',
            opUserId: 'string',
            quotaId: 'string',
            recordId: 'string',
            recordNumPerDay: 'number',
            recordNumPerHour: 'number',
            startTime: 'number',
            userId: 'string',
        };
    }
}
exports.GetLeaveRecordsResponseBodyResultLeaveRecords = GetLeaveRecordsResponseBodyResultLeaveRecords;
class GetLeaveRecordsResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            leaveRecords: 'leaveRecords',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            leaveRecords: { 'type': 'array', 'itemType': GetLeaveRecordsResponseBodyResultLeaveRecords },
        };
    }
}
exports.GetLeaveRecordsResponseBodyResult = GetLeaveRecordsResponseBodyResult;
class GetLeaveTypeResponseBodyResultLeaveCertificate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            enable: 'enable',
            promptInformation: 'promptInformation',
            unit: 'unit',
        };
    }
    static types() {
        return {
            duration: 'number',
            enable: 'boolean',
            promptInformation: 'string',
            unit: 'string',
        };
    }
}
exports.GetLeaveTypeResponseBodyResultLeaveCertificate = GetLeaveTypeResponseBodyResultLeaveCertificate;
class GetLeaveTypeResponseBodyResultSubmitTimeRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableTimeLimit: 'enableTimeLimit',
            timeType: 'timeType',
            timeUnit: 'timeUnit',
            timeValue: 'timeValue',
        };
    }
    static types() {
        return {
            enableTimeLimit: 'boolean',
            timeType: 'string',
            timeUnit: 'string',
            timeValue: 'number',
        };
    }
}
exports.GetLeaveTypeResponseBodyResultSubmitTimeRule = GetLeaveTypeResponseBodyResultSubmitTimeRule;
class GetLeaveTypeResponseBodyResultVisibilityRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            visible: 'visible',
        };
    }
    static types() {
        return {
            type: 'string',
            visible: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetLeaveTypeResponseBodyResultVisibilityRules = GetLeaveTypeResponseBodyResultVisibilityRules;
class GetLeaveTypeResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            hoursInPerDay: 'hoursInPerDay',
            leaveCertificate: 'leaveCertificate',
            leaveCode: 'leaveCode',
            leaveName: 'leaveName',
            leaveViewUnit: 'leaveViewUnit',
            naturalDayLeave: 'naturalDayLeave',
            source: 'source',
            submitTimeRule: 'submitTimeRule',
            validityType: 'validityType',
            validityValue: 'validityValue',
            visibilityRules: 'visibilityRules',
        };
    }
    static types() {
        return {
            bizType: 'string',
            hoursInPerDay: 'number',
            leaveCertificate: GetLeaveTypeResponseBodyResultLeaveCertificate,
            leaveCode: 'string',
            leaveName: 'string',
            leaveViewUnit: 'string',
            naturalDayLeave: 'boolean',
            source: 'string',
            submitTimeRule: GetLeaveTypeResponseBodyResultSubmitTimeRule,
            validityType: 'string',
            validityValue: 'string',
            visibilityRules: { 'type': 'array', 'itemType': GetLeaveTypeResponseBodyResultVisibilityRules },
        };
    }
}
exports.GetLeaveTypeResponseBodyResult = GetLeaveTypeResponseBodyResult;
class GetMachineResponseBodyResultMachineBluetoothVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'address',
            bluetoothCheckWithFace: 'bluetoothCheckWithFace',
            bluetoothDistanceMode: 'bluetoothDistanceMode',
            bluetoothDistanceModeDesc: 'bluetoothDistanceModeDesc',
            bluetoothValue: 'bluetoothValue',
            latitude: 'latitude',
            limitUserDeviceCount: 'limitUserDeviceCount',
            longitude: 'longitude',
            monitorLocationAbnormal: 'monitorLocationAbnormal',
            userDeviceCount: 'userDeviceCount',
        };
    }
    static types() {
        return {
            address: 'string',
            bluetoothCheckWithFace: 'boolean',
            bluetoothDistanceMode: 'string',
            bluetoothDistanceModeDesc: 'string',
            bluetoothValue: 'boolean',
            latitude: 'number',
            limitUserDeviceCount: 'boolean',
            longitude: 'number',
            monitorLocationAbnormal: 'boolean',
            userDeviceCount: 'number',
        };
    }
}
exports.GetMachineResponseBodyResultMachineBluetoothVO = GetMachineResponseBodyResultMachineBluetoothVO;
class GetMachineResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            atmManagerList: 'atmManagerList',
            devId: 'devId',
            deviceId: 'deviceId',
            deviceName: 'deviceName',
            deviceSn: 'deviceSn',
            machineBluetoothVO: 'machineBluetoothVO',
            maxFace: 'maxFace',
            netStatus: 'netStatus',
            productName: 'productName',
            productVersion: 'productVersion',
            voiceMode: 'voiceMode',
        };
    }
    static types() {
        return {
            atmManagerList: { 'type': 'array', 'itemType': 'string' },
            devId: 'number',
            deviceId: 'string',
            deviceName: 'string',
            deviceSn: 'string',
            machineBluetoothVO: GetMachineResponseBodyResultMachineBluetoothVO,
            maxFace: 'number',
            netStatus: 'string',
            productName: 'string',
            productVersion: 'string',
            voiceMode: 'number',
        };
    }
}
exports.GetMachineResponseBodyResult = GetMachineResponseBodyResult;
class GetMachineUserResponseBodyResultUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasFace: 'hasFace',
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            hasFace: 'boolean',
            name: 'string',
            userId: 'string',
        };
    }
}
exports.GetMachineUserResponseBodyResultUserList = GetMachineUserResponseBodyResultUserList;
class GetMachineUserResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            userList: 'userList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            userList: { 'type': 'array', 'itemType': GetMachineUserResponseBodyResultUserList },
        };
    }
}
exports.GetMachineUserResponseBodyResult = GetMachineUserResponseBodyResult;
class GetOvertimeSettingResponseBodyResultOvertimeDivisions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextDayType: 'nextDayType',
            previousDayType: 'previousDayType',
            timeSplitPoint: 'timeSplitPoint',
        };
    }
    static types() {
        return {
            nextDayType: 'string',
            previousDayType: 'string',
            timeSplitPoint: 'string',
        };
    }
}
exports.GetOvertimeSettingResponseBodyResultOvertimeDivisions = GetOvertimeSettingResponseBodyResultOvertimeDivisions;
class GetOvertimeSettingResponseBodyResultWarningSettings extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            threshold: 'threshold',
            time: 'time',
        };
    }
    static types() {
        return {
            action: 'string',
            threshold: 'number',
            time: 'string',
        };
    }
}
exports.GetOvertimeSettingResponseBodyResultWarningSettings = GetOvertimeSettingResponseBodyResultWarningSettings;
class GetOvertimeSettingResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            default: 'default',
            durationSettings: 'durationSettings',
            id: 'id',
            name: 'name',
            overtimeDivisions: 'overtimeDivisions',
            settingId: 'settingId',
            stepType: 'stepType',
            stepValue: 'stepValue',
            warningSettings: 'warningSettings',
            workMinutesPerDay: 'workMinutesPerDay',
        };
    }
    static types() {
        return {
            default: 'boolean',
            durationSettings: { 'type': 'map', 'keyType': 'string', 'valueType': ResultDurationSettingsValue },
            id: 'number',
            name: 'string',
            overtimeDivisions: { 'type': 'array', 'itemType': GetOvertimeSettingResponseBodyResultOvertimeDivisions },
            settingId: 'number',
            stepType: 'number',
            stepValue: 'number',
            warningSettings: { 'type': 'array', 'itemType': GetOvertimeSettingResponseBodyResultWarningSettings },
            workMinutesPerDay: 'number',
        };
    }
}
exports.GetOvertimeSettingResponseBodyResult = GetOvertimeSettingResponseBodyResult;
class GetShiftResponseBodyResultSectionsPunchesLateBackSettingLateBackPairs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extra: 'extra',
            late: 'late',
        };
    }
    static types() {
        return {
            extra: 'number',
            late: 'number',
        };
    }
}
exports.GetShiftResponseBodyResultSectionsPunchesLateBackSettingLateBackPairs = GetShiftResponseBodyResultSectionsPunchesLateBackSettingLateBackPairs;
class GetShiftResponseBodyResultSectionsPunchesLateBackSetting extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            lateBackPairs: 'lateBackPairs',
        };
    }
    static types() {
        return {
            lateBackPairs: { 'type': 'array', 'itemType': GetShiftResponseBodyResultSectionsPunchesLateBackSettingLateBackPairs },
        };
    }
}
exports.GetShiftResponseBodyResultSectionsPunchesLateBackSetting = GetShiftResponseBodyResultSectionsPunchesLateBackSetting;
class GetShiftResponseBodyResultSectionsPunches extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            absenteeismLateMinutes: 'absenteeismLateMinutes',
            across: 'across',
            beginMin: 'beginMin',
            checkTime: 'checkTime',
            checkType: 'checkType',
            endMin: 'endMin',
            flexMinutes: 'flexMinutes',
            freeCheck: 'freeCheck',
            lateBackSetting: 'lateBackSetting',
            permitMinutes: 'permitMinutes',
            puncheId: 'puncheId',
            seriousLateMinutes: 'seriousLateMinutes',
        };
    }
    static types() {
        return {
            absenteeismLateMinutes: 'number',
            across: 'number',
            beginMin: 'number',
            checkTime: 'string',
            checkType: 'string',
            endMin: 'number',
            flexMinutes: { 'type': 'array', 'itemType': 'number' },
            freeCheck: 'boolean',
            lateBackSetting: GetShiftResponseBodyResultSectionsPunchesLateBackSetting,
            permitMinutes: 'number',
            puncheId: 'number',
            seriousLateMinutes: 'number',
        };
    }
}
exports.GetShiftResponseBodyResultSectionsPunches = GetShiftResponseBodyResultSectionsPunches;
class GetShiftResponseBodyResultSectionsRests extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            across: 'across',
            checkTime: 'checkTime',
            checkType: 'checkType',
            restId: 'restId',
        };
    }
    static types() {
        return {
            across: 'number',
            checkTime: 'string',
            checkType: 'string',
            restId: 'number',
        };
    }
}
exports.GetShiftResponseBodyResultSectionsRests = GetShiftResponseBodyResultSectionsRests;
class GetShiftResponseBodyResultSections extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            punches: 'punches',
            rests: 'rests',
            sectionId: 'sectionId',
        };
    }
    static types() {
        return {
            punches: { 'type': 'array', 'itemType': GetShiftResponseBodyResultSectionsPunches },
            rests: { 'type': 'array', 'itemType': GetShiftResponseBodyResultSectionsRests },
            sectionId: 'number',
        };
    }
}
exports.GetShiftResponseBodyResultSections = GetShiftResponseBodyResultSections;
class GetShiftResponseBodyResultShiftSetting extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendDays: 'attendDays',
            corpId: 'corpId',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            shiftId: 'shiftId',
            shiftSettingId: 'shiftSettingId',
            workTimeMinutes: 'workTimeMinutes',
        };
    }
    static types() {
        return {
            attendDays: 'string',
            corpId: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            shiftId: 'number',
            shiftSettingId: 'number',
            workTimeMinutes: 'number',
        };
    }
}
exports.GetShiftResponseBodyResultShiftSetting = GetShiftResponseBodyResultShiftSetting;
class GetShiftResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            id: 'id',
            name: 'name',
            owner: 'owner',
            sections: 'sections',
            shiftGroupId: 'shiftGroupId',
            shiftGroupName: 'shiftGroupName',
            shiftSetting: 'shiftSetting',
        };
    }
    static types() {
        return {
            corpId: 'string',
            id: 'number',
            name: 'string',
            owner: 'string',
            sections: { 'type': 'array', 'itemType': GetShiftResponseBodyResultSections },
            shiftGroupId: 'number',
            shiftGroupName: 'string',
            shiftSetting: GetShiftResponseBodyResultShiftSetting,
        };
    }
}
exports.GetShiftResponseBodyResult = GetShiftResponseBodyResult;
class GetSimpleOvertimeSettingResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
            settingId: 'settingId',
        };
    }
    static types() {
        return {
            id: 'number',
            name: 'string',
            settingId: 'number',
        };
    }
}
exports.GetSimpleOvertimeSettingResponseBodyResultItems = GetSimpleOvertimeSettingResponseBodyResultItems;
class GetSimpleOvertimeSettingResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            items: 'items',
            pageNumber: 'pageNumber',
            totalPage: 'totalPage',
        };
    }
    static types() {
        return {
            items: { 'type': 'array', 'itemType': GetSimpleOvertimeSettingResponseBodyResultItems },
            pageNumber: 'number',
            totalPage: 'number',
        };
    }
}
exports.GetSimpleOvertimeSettingResponseBodyResult = GetSimpleOvertimeSettingResponseBodyResult;
class GetUserHolidaysResponseBodyResultHolidays extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            holidayName: 'holidayName',
            holidayType: 'holidayType',
            realWorkDate: 'realWorkDate',
            workDate: 'workDate',
        };
    }
    static types() {
        return {
            holidayName: 'string',
            holidayType: 'string',
            realWorkDate: 'number',
            workDate: 'number',
        };
    }
}
exports.GetUserHolidaysResponseBodyResultHolidays = GetUserHolidaysResponseBodyResultHolidays;
class GetUserHolidaysResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            holidays: 'holidays',
            userId: 'userId',
        };
    }
    static types() {
        return {
            holidays: { 'type': 'array', 'itemType': GetUserHolidaysResponseBodyResultHolidays },
            userId: 'string',
        };
    }
}
exports.GetUserHolidaysResponseBodyResult = GetUserHolidaysResponseBodyResult;
class GroupAddRequestBleDeviceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deviceId: 'deviceId',
        };
    }
    static types() {
        return {
            deviceId: 'number',
        };
    }
}
exports.GroupAddRequestBleDeviceList = GroupAddRequestBleDeviceList;
class GroupAddRequestFreeCheckSettingFreeCheckGap extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            offOnCheckGapMinutes: 'offOnCheckGapMinutes',
            onOffCheckGapMinutes: 'onOffCheckGapMinutes',
        };
    }
    static types() {
        return {
            offOnCheckGapMinutes: 'number',
            onOffCheckGapMinutes: 'number',
        };
    }
}
exports.GroupAddRequestFreeCheckSettingFreeCheckGap = GroupAddRequestFreeCheckSettingFreeCheckGap;
class GroupAddRequestFreeCheckSetting extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            delimitOffsetMinutesBetweenDays: 'delimitOffsetMinutesBetweenDays',
            freeCheckGap: 'freeCheckGap',
        };
    }
    static types() {
        return {
            delimitOffsetMinutesBetweenDays: 'number',
            freeCheckGap: GroupAddRequestFreeCheckSettingFreeCheckGap,
        };
    }
}
exports.GroupAddRequestFreeCheckSetting = GroupAddRequestFreeCheckSetting;
class GroupAddRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            role: 'role',
            type: 'type',
            userId: 'userId',
        };
    }
    static types() {
        return {
            role: 'string',
            type: 'string',
            userId: 'string',
        };
    }
}
exports.GroupAddRequestMembers = GroupAddRequestMembers;
class GroupAddRequestPositions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'address',
            latitude: 'latitude',
            longitude: 'longitude',
            offset: 'offset',
            title: 'title',
        };
    }
    static types() {
        return {
            address: 'string',
            latitude: 'string',
            longitude: 'string',
            offset: 'number',
            title: 'string',
        };
    }
}
exports.GroupAddRequestPositions = GroupAddRequestPositions;
class GroupAddRequestShiftVOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            shiftId: 'shiftId',
        };
    }
    static types() {
        return {
            shiftId: 'number',
        };
    }
}
exports.GroupAddRequestShiftVOList = GroupAddRequestShiftVOList;
class GroupAddRequestWifis extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            macAddr: 'macAddr',
            ssid: 'ssid',
        };
    }
    static types() {
        return {
            macAddr: 'string',
            ssid: 'string',
        };
    }
}
exports.GroupAddRequestWifis = GroupAddRequestWifis;
class GroupAddResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'number',
            name: 'string',
        };
    }
}
exports.GroupAddResponseBodyResult = GroupAddResponseBodyResult;
class GroupUpdateRequestFreeCheckSettingFreeCheckGap extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            offOnCheckGapMinutes: 'offOnCheckGapMinutes',
            onOffCheckGapMinutes: 'onOffCheckGapMinutes',
        };
    }
    static types() {
        return {
            offOnCheckGapMinutes: 'number',
            onOffCheckGapMinutes: 'number',
        };
    }
}
exports.GroupUpdateRequestFreeCheckSettingFreeCheckGap = GroupUpdateRequestFreeCheckSettingFreeCheckGap;
class GroupUpdateRequestFreeCheckSetting extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            delimitOffsetMinutesBetweenDays: 'delimitOffsetMinutesBetweenDays',
            freeCheckGap: 'freeCheckGap',
        };
    }
    static types() {
        return {
            delimitOffsetMinutesBetweenDays: 'number',
            freeCheckGap: GroupUpdateRequestFreeCheckSettingFreeCheckGap,
        };
    }
}
exports.GroupUpdateRequestFreeCheckSetting = GroupUpdateRequestFreeCheckSetting;
class GroupUpdateRequestPositions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'address',
            latitude: 'latitude',
            longitude: 'longitude',
            offset: 'offset',
            title: 'title',
        };
    }
    static types() {
        return {
            address: 'string',
            latitude: 'string',
            longitude: 'string',
            offset: 'number',
            title: 'string',
        };
    }
}
exports.GroupUpdateRequestPositions = GroupUpdateRequestPositions;
class GroupUpdateRequestShiftVOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            shiftId: 'shiftId',
        };
    }
    static types() {
        return {
            shiftId: 'number',
        };
    }
}
exports.GroupUpdateRequestShiftVOList = GroupUpdateRequestShiftVOList;
class GroupUpdateResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'number',
            name: 'string',
        };
    }
}
exports.GroupUpdateResponseBodyResult = GroupUpdateResponseBodyResult;
class InitAndGetLeaveALlocationQuotasResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            leaveCode: 'leaveCode',
            quotaCycle: 'quotaCycle',
            quotaId: 'quotaId',
            quotaNumPerDay: 'quotaNumPerDay',
            quotaNumPerHour: 'quotaNumPerHour',
            startTime: 'startTime',
            usedNumPerDay: 'usedNumPerDay',
            usedNumPerHour: 'usedNumPerHour',
            userId: 'userId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            leaveCode: 'string',
            quotaCycle: 'string',
            quotaId: 'string',
            quotaNumPerDay: 'number',
            quotaNumPerHour: 'number',
            startTime: 'number',
            usedNumPerDay: 'number',
            usedNumPerHour: 'number',
            userId: 'string',
        };
    }
}
exports.InitAndGetLeaveALlocationQuotasResponseBodyResult = InitAndGetLeaveALlocationQuotasResponseBodyResult;
class ListApproveByUsersResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            approveId: 'approveId',
            beginTime: 'beginTime',
            bizType: 'bizType',
            calculateModel: 'calculateModel',
            durationUnit: 'durationUnit',
            endTime: 'endTime',
            subType: 'subType',
            tagName: 'tagName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            approveId: 'string',
            beginTime: 'string',
            bizType: 'number',
            calculateModel: 'number',
            durationUnit: 'string',
            endTime: 'string',
            subType: 'string',
            tagName: 'string',
            userId: 'string',
        };
    }
}
exports.ListApproveByUsersResponseBodyResult = ListApproveByUsersResponseBodyResult;
class ProcessApproveCreateRequestPunchParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            positionId: 'positionId',
            positionName: 'positionName',
            positionType: 'positionType',
            punchTime: 'punchTime',
        };
    }
    static types() {
        return {
            positionId: 'string',
            positionName: 'string',
            positionType: 'string',
            punchTime: 'number',
        };
    }
}
exports.ProcessApproveCreateRequestPunchParam = ProcessApproveCreateRequestPunchParam;
class ProcessApproveCreateResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingtalkApproveId: 'dingtalkApproveId',
        };
    }
    static types() {
        return {
            dingtalkApproveId: 'string',
        };
    }
}
exports.ProcessApproveCreateResponseBodyResult = ProcessApproveCreateResponseBodyResult;
class ProcessApproveFinishRequestTopCalculateApproveDurationParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            calculateModel: 'calculateModel',
            durationUnit: 'durationUnit',
            fromTime: 'fromTime',
            leaveCode: 'leaveCode',
            toTime: 'toTime',
        };
    }
    static types() {
        return {
            bizType: 'number',
            calculateModel: 'number',
            durationUnit: 'string',
            fromTime: 'string',
            leaveCode: 'string',
            toTime: 'string',
        };
    }
}
exports.ProcessApproveFinishRequestTopCalculateApproveDurationParam = ProcessApproveFinishRequestTopCalculateApproveDurationParam;
class ProcessApproveFinishResponseBodyResultDurationDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            date: 'date',
            duration: 'duration',
        };
    }
    static types() {
        return {
            date: 'string',
            duration: 'number',
        };
    }
}
exports.ProcessApproveFinishResponseBodyResultDurationDetail = ProcessApproveFinishResponseBodyResultDurationDetail;
class ProcessApproveFinishResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            durationDetail: 'durationDetail',
        };
    }
    static types() {
        return {
            duration: 'number',
            durationDetail: { 'type': 'array', 'itemType': ProcessApproveFinishResponseBodyResultDurationDetail },
        };
    }
}
exports.ProcessApproveFinishResponseBodyResult = ProcessApproveFinishResponseBodyResult;
class RetainLeaveTypesResponseBodyResultLeaveCertificate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            enable: 'enable',
            promptInformation: 'promptInformation',
            unit: 'unit',
        };
    }
    static types() {
        return {
            duration: 'number',
            enable: 'boolean',
            promptInformation: 'string',
            unit: 'string',
        };
    }
}
exports.RetainLeaveTypesResponseBodyResultLeaveCertificate = RetainLeaveTypesResponseBodyResultLeaveCertificate;
class RetainLeaveTypesResponseBodyResultSubmitTimeRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableTimeLimit: 'enableTimeLimit',
            timeType: 'timeType',
            timeUnit: 'timeUnit',
            timeValue: 'timeValue',
        };
    }
    static types() {
        return {
            enableTimeLimit: 'boolean',
            timeType: 'string',
            timeUnit: 'string',
            timeValue: 'number',
        };
    }
}
exports.RetainLeaveTypesResponseBodyResultSubmitTimeRule = RetainLeaveTypesResponseBodyResultSubmitTimeRule;
class RetainLeaveTypesResponseBodyResultVisibilityRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            visible: 'visible',
        };
    }
    static types() {
        return {
            type: 'string',
            visible: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.RetainLeaveTypesResponseBodyResultVisibilityRules = RetainLeaveTypesResponseBodyResultVisibilityRules;
class RetainLeaveTypesResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            hoursInPerDay: 'hoursInPerDay',
            leaveCertificate: 'leaveCertificate',
            leaveCode: 'leaveCode',
            leaveHourCeil: 'leaveHourCeil',
            leaveName: 'leaveName',
            leaveTimeCeil: 'leaveTimeCeil',
            leaveTimeCeilMinUnit: 'leaveTimeCeilMinUnit',
            leaveViewUnit: 'leaveViewUnit',
            lieuDelayNum: 'lieuDelayNum',
            lieuDelayUnit: 'lieuDelayUnit',
            maxLeaveTime: 'maxLeaveTime',
            minLeaveHour: 'minLeaveHour',
            naturalDayLeave: 'naturalDayLeave',
            paidLeave: 'paidLeave',
            submitTimeRule: 'submitTimeRule',
            visibilityRules: 'visibilityRules',
            whenCanLeave: 'whenCanLeave',
        };
    }
    static types() {
        return {
            bizType: 'string',
            hoursInPerDay: 'number',
            leaveCertificate: RetainLeaveTypesResponseBodyResultLeaveCertificate,
            leaveCode: 'string',
            leaveHourCeil: 'string',
            leaveName: 'string',
            leaveTimeCeil: 'boolean',
            leaveTimeCeilMinUnit: 'string',
            leaveViewUnit: 'string',
            lieuDelayNum: 'number',
            lieuDelayUnit: 'string',
            maxLeaveTime: 'number',
            minLeaveHour: 'number',
            naturalDayLeave: 'boolean',
            paidLeave: 'boolean',
            submitTimeRule: RetainLeaveTypesResponseBodyResultSubmitTimeRule,
            visibilityRules: { 'type': 'array', 'itemType': RetainLeaveTypesResponseBodyResultVisibilityRules },
            whenCanLeave: 'string',
        };
    }
}
exports.RetainLeaveTypesResponseBodyResult = RetainLeaveTypesResponseBodyResult;
class SaveCustomWaterMarkTemplateResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            formCode: 'formCode',
            waterMarkId: 'waterMarkId',
        };
    }
    static types() {
        return {
            formCode: 'string',
            waterMarkId: 'string',
        };
    }
}
exports.SaveCustomWaterMarkTemplateResponseBodyResult = SaveCustomWaterMarkTemplateResponseBodyResult;
class SyncScheduleInfoRequestScheduleInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            planId: 'planId',
            positionKeys: 'positionKeys',
            retainAttendanceCheck: 'retainAttendanceCheck',
            wifiKeys: 'wifiKeys',
        };
    }
    static types() {
        return {
            planId: 'number',
            positionKeys: { 'type': 'array', 'itemType': 'string' },
            retainAttendanceCheck: 'boolean',
            wifiKeys: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SyncScheduleInfoRequestScheduleInfos = SyncScheduleInfoRequestScheduleInfos;
class UpdateLeaveTypeRequestLeaveCertificate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            enable: 'enable',
            promptInformation: 'promptInformation',
            unit: 'unit',
        };
    }
    static types() {
        return {
            duration: 'number',
            enable: 'boolean',
            promptInformation: 'string',
            unit: 'string',
        };
    }
}
exports.UpdateLeaveTypeRequestLeaveCertificate = UpdateLeaveTypeRequestLeaveCertificate;
class UpdateLeaveTypeRequestSubmitTimeRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableTimeLimit: 'enableTimeLimit',
            timeType: 'timeType',
            timeUnit: 'timeUnit',
            timeValue: 'timeValue',
        };
    }
    static types() {
        return {
            enableTimeLimit: 'boolean',
            timeType: 'string',
            timeUnit: 'string',
            timeValue: 'number',
        };
    }
}
exports.UpdateLeaveTypeRequestSubmitTimeRule = UpdateLeaveTypeRequestSubmitTimeRule;
class UpdateLeaveTypeRequestVisibilityRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            visible: 'visible',
        };
    }
    static types() {
        return {
            type: 'string',
            visible: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UpdateLeaveTypeRequestVisibilityRules = UpdateLeaveTypeRequestVisibilityRules;
class UpdateLeaveTypeResponseBodyResultLeaveCertificate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            enable: 'enable',
            promptInformation: 'promptInformation',
            unit: 'unit',
        };
    }
    static types() {
        return {
            duration: 'number',
            enable: 'boolean',
            promptInformation: 'string',
            unit: 'string',
        };
    }
}
exports.UpdateLeaveTypeResponseBodyResultLeaveCertificate = UpdateLeaveTypeResponseBodyResultLeaveCertificate;
class UpdateLeaveTypeResponseBodyResultSubmitTimeRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            enableTimeLimit: 'enableTimeLimit',
            timeType: 'timeType',
            timeUnit: 'timeUnit',
            timeValue: 'timeValue',
        };
    }
    static types() {
        return {
            enableTimeLimit: 'boolean',
            timeType: 'string',
            timeUnit: 'string',
            timeValue: 'number',
        };
    }
}
exports.UpdateLeaveTypeResponseBodyResultSubmitTimeRule = UpdateLeaveTypeResponseBodyResultSubmitTimeRule;
class UpdateLeaveTypeResponseBodyResultVisibilityRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            visible: 'visible',
        };
    }
    static types() {
        return {
            type: 'string',
            visible: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UpdateLeaveTypeResponseBodyResultVisibilityRules = UpdateLeaveTypeResponseBodyResultVisibilityRules;
class UpdateLeaveTypeResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            hoursInPerDay: 'hoursInPerDay',
            leaveCertificate: 'leaveCertificate',
            leaveCode: 'leaveCode',
            leaveName: 'leaveName',
            leaveViewUnit: 'leaveViewUnit',
            naturalDayLeave: 'naturalDayLeave',
            submitTimeRule: 'submitTimeRule',
            visibilityRules: 'visibilityRules',
        };
    }
    static types() {
        return {
            bizType: 'string',
            hoursInPerDay: 'number',
            leaveCertificate: UpdateLeaveTypeResponseBodyResultLeaveCertificate,
            leaveCode: 'string',
            leaveName: 'string',
            leaveViewUnit: 'string',
            naturalDayLeave: 'boolean',
            submitTimeRule: UpdateLeaveTypeResponseBodyResultSubmitTimeRule,
            visibilityRules: { 'type': 'array', 'itemType': UpdateLeaveTypeResponseBodyResultVisibilityRules },
        };
    }
}
exports.UpdateLeaveTypeResponseBodyResult = UpdateLeaveTypeResponseBodyResult;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addLeaveTypeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            body["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.extras)) {
            body["extras"] = request.extras;
        }
        if (!tea_util_1.default.isUnset(request.freedomLeave)) {
            body["freedomLeave"] = request.freedomLeave;
        }
        if (!tea_util_1.default.isUnset(request.hoursInPerDay)) {
            body["hoursInPerDay"] = request.hoursInPerDay;
        }
        if (!tea_util_1.default.isUnset(request.leaveCertificate)) {
            body["leaveCertificate"] = request.leaveCertificate;
        }
        if (!tea_util_1.default.isUnset(request.leaveHourCeil)) {
            body["leaveHourCeil"] = request.leaveHourCeil;
        }
        if (!tea_util_1.default.isUnset(request.leaveName)) {
            body["leaveName"] = request.leaveName;
        }
        if (!tea_util_1.default.isUnset(request.leaveTimeCeil)) {
            body["leaveTimeCeil"] = request.leaveTimeCeil;
        }
        if (!tea_util_1.default.isUnset(request.leaveTimeCeilMinUnit)) {
            body["leaveTimeCeilMinUnit"] = request.leaveTimeCeilMinUnit;
        }
        if (!tea_util_1.default.isUnset(request.leaveViewUnit)) {
            body["leaveViewUnit"] = request.leaveViewUnit;
        }
        if (!tea_util_1.default.isUnset(request.maxLeaveTime)) {
            body["maxLeaveTime"] = request.maxLeaveTime;
        }
        if (!tea_util_1.default.isUnset(request.minLeaveHour)) {
            body["minLeaveHour"] = request.minLeaveHour;
        }
        if (!tea_util_1.default.isUnset(request.naturalDayLeave)) {
            body["naturalDayLeave"] = request.naturalDayLeave;
        }
        if (!tea_util_1.default.isUnset(request.paidLeave)) {
            body["paidLeave"] = request.paidLeave;
        }
        if (!tea_util_1.default.isUnset(request.submitTimeRule)) {
            body["submitTimeRule"] = request.submitTimeRule;
        }
        if (!tea_util_1.default.isUnset(request.visibilityRules)) {
            body["visibilityRules"] = request.visibilityRules;
        }
        if (!tea_util_1.default.isUnset(request.whenCanLeave)) {
            body["whenCanLeave"] = request.whenCanLeave;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddLeaveType",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/leaves/types`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddLeaveTypeResponse({}));
    }
    async addLeaveType(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddLeaveTypeHeaders({});
        return await this.addLeaveTypeWithOptions(request, headers, runtime);
    }
    async attendanceBleDevicesAddWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceIdList)) {
            body["deviceIdList"] = request.deviceIdList;
        }
        if (!tea_util_1.default.isUnset(request.groupKey)) {
            body["groupKey"] = request.groupKey;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AttendanceBleDevicesAdd",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/group/bledevices`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AttendanceBleDevicesAddResponse({}));
    }
    async attendanceBleDevicesAdd(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AttendanceBleDevicesAddHeaders({});
        return await this.attendanceBleDevicesAddWithOptions(request, headers, runtime);
    }
    async attendanceBleDevicesQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupKey)) {
            body["groupKey"] = request.groupKey;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AttendanceBleDevicesQuery",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/group/bledevices/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AttendanceBleDevicesQueryResponse({}));
    }
    async attendanceBleDevicesQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AttendanceBleDevicesQueryHeaders({});
        return await this.attendanceBleDevicesQueryWithOptions(request, headers, runtime);
    }
    async attendanceBleDevicesRemoveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deviceIdList)) {
            body["deviceIdList"] = request.deviceIdList;
        }
        if (!tea_util_1.default.isUnset(request.groupKey)) {
            body["groupKey"] = request.groupKey;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AttendanceBleDevicesRemove",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/group/bledevices/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AttendanceBleDevicesRemoveResponse({}));
    }
    async attendanceBleDevicesRemove(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AttendanceBleDevicesRemoveHeaders({});
        return await this.attendanceBleDevicesRemoveWithOptions(request, headers, runtime);
    }
    async batchBossCheckWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.models)) {
            body["models"] = request.models;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchBossCheck",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/results/batch`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchBossCheckResponse({}));
    }
    async batchBossCheck(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchBossCheckHeaders({});
        return await this.batchBossCheckWithOptions(request, headers, runtime);
    }
    async calculateDurationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            body["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.calculateModel)) {
            body["calculateModel"] = request.calculateModel;
        }
        if (!tea_util_1.default.isUnset(request.durationUnit)) {
            body["durationUnit"] = request.durationUnit;
        }
        if (!tea_util_1.default.isUnset(request.fromTime)) {
            body["fromTime"] = request.fromTime;
        }
        if (!tea_util_1.default.isUnset(request.leaveCode)) {
            body["leaveCode"] = request.leaveCode;
        }
        if (!tea_util_1.default.isUnset(request.toTime)) {
            body["toTime"] = request.toTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CalculateDuration",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/approvals/durations/calculate`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CalculateDurationResponse({}));
    }
    async calculateDuration(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CalculateDurationHeaders({});
        return await this.calculateDurationWithOptions(request, headers, runtime);
    }
    async checkClosingAccountWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            body["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        if (!tea_util_1.default.isUnset(request.userTimeRange)) {
            body["userTimeRange"] = request.userTimeRange;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CheckClosingAccount",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/closingAccounts/status/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CheckClosingAccountResponse({}));
    }
    async checkClosingAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CheckClosingAccountHeaders({});
        return await this.checkClosingAccountWithOptions(request, headers, runtime);
    }
    async checkWritePermissionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            body["category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.entityIds)) {
            body["entityIds"] = request.entityIds;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.resourceKey)) {
            body["resourceKey"] = request.resourceKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CheckWritePermission",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/writePermissions/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CheckWritePermissionResponse({}));
    }
    async checkWritePermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CheckWritePermissionHeaders({});
        return await this.checkWritePermissionWithOptions(request, headers, runtime);
    }
    async createApproveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.approveId)) {
            body["approveId"] = request.approveId;
        }
        if (!tea_util_1.default.isUnset(request.opUserid)) {
            body["opUserid"] = request.opUserid;
        }
        if (!tea_util_1.default.isUnset(request.punchParam)) {
            body["punchParam"] = request.punchParam;
        }
        if (!tea_util_1.default.isUnset(request.subType)) {
            body["subType"] = request.subType;
        }
        if (!tea_util_1.default.isUnset(request.tagName)) {
            body["tagName"] = request.tagName;
        }
        if (!tea_util_1.default.isUnset(request.userid)) {
            body["userid"] = request.userid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateApprove",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/approves`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateApproveResponse({}));
    }
    async createApprove(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateApproveHeaders({});
        return await this.createApproveWithOptions(request, headers, runtime);
    }
    async deleteWaterMarkTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.formCode)) {
            query["formCode"] = request.formCode;
        }
        if (!tea_util_1.default.isUnset(request.formContent)) {
            query["formContent"] = request.formContent;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.systemTemplate)) {
            query["systemTemplate"] = request.systemTemplate;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteWaterMarkTemplate",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/watermarks/templates`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteWaterMarkTemplateResponse({}));
    }
    async deleteWaterMarkTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteWaterMarkTemplateHeaders({});
        return await this.deleteWaterMarkTemplateWithOptions(request, headers, runtime);
    }
    async dingTalkSecurityCheckWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.clientVer)) {
            body["clientVer"] = request.clientVer;
        }
        if (!tea_util_1.default.isUnset(request.platform)) {
            body["platform"] = request.platform;
        }
        if (!tea_util_1.default.isUnset(request.platformVer)) {
            body["platformVer"] = request.platformVer;
        }
        if (!tea_util_1.default.isUnset(request.sec)) {
            body["sec"] = request.sec;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DingTalkSecurityCheck",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/securities/check`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DingTalkSecurityCheckResponse({}));
    }
    async dingTalkSecurityCheck(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DingTalkSecurityCheckHeaders({});
        return await this.dingTalkSecurityCheckWithOptions(request, headers, runtime);
    }
    async getATManageScopeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetATManageScope",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/manageScopes`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetATManageScopeResponse({}));
    }
    async getATManageScope(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetATManageScopeHeaders({});
        return await this.getATManageScopeWithOptions(request, headers, runtime);
    }
    async getAdjustmentsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAdjustments",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/adjustments`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAdjustmentsResponse({}));
    }
    async getAdjustments(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAdjustmentsHeaders({});
        return await this.getAdjustmentsWithOptions(request, headers, runtime);
    }
    async getCheckInSchemaTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.sceneCode)) {
            query["sceneCode"] = request.sceneCode;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetCheckInSchemaTemplate",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/watermarks/templates`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCheckInSchemaTemplateResponse({}));
    }
    async getCheckInSchemaTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCheckInSchemaTemplateHeaders({});
        return await this.getCheckInSchemaTemplateWithOptions(request, headers, runtime);
    }
    async getCheckinRecordByUserWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.userIdList)) {
            body["userIdList"] = request.userIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetCheckinRecordByUser",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/checkin/records/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCheckinRecordByUserResponse({}));
    }
    async getCheckinRecordByUser(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCheckinRecordByUserHeaders({});
        return await this.getCheckinRecordByUserWithOptions(request, headers, runtime);
    }
    async getClosingAccountsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetClosingAccounts",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/closingAccounts/rules/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetClosingAccountsResponse({}));
    }
    async getClosingAccounts(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetClosingAccountsHeaders({});
        return await this.getClosingAccountsWithOptions(request, headers, runtime);
    }
    async getLeaveRecordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.leaveCode)) {
            body["leaveCode"] = request.leaveCode;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            body["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetLeaveRecords",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/vacations/records/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetLeaveRecordsResponse({}));
    }
    async getLeaveRecords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetLeaveRecordsHeaders({});
        return await this.getLeaveRecordsWithOptions(request, headers, runtime);
    }
    async getLeaveTypeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.vacationSource)) {
            query["vacationSource"] = request.vacationSource;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetLeaveType",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/leaves/types`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetLeaveTypeResponse({}));
    }
    async getLeaveType(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetLeaveTypeHeaders({});
        return await this.getLeaveTypeWithOptions(request, headers, runtime);
    }
    async getMachineWithOptions(devId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetMachine",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/machines/${devId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetMachineResponse({}));
    }
    async getMachine(devId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetMachineHeaders({});
        return await this.getMachineWithOptions(devId, headers, runtime);
    }
    async getMachineUserWithOptions(devId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetMachineUser",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/machines/getUser/${devId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetMachineUserResponse({}));
    }
    async getMachineUser(devId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetMachineUserHeaders({});
        return await this.getMachineUserWithOptions(devId, request, headers, runtime);
    }
    async getOvertimeSettingWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.overtimeSettingIds)) {
            body["overtimeSettingIds"] = request.overtimeSettingIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetOvertimeSetting",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/overtimeSettings/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetOvertimeSettingResponse({}));
    }
    async getOvertimeSetting(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetOvertimeSettingHeaders({});
        return await this.getOvertimeSettingWithOptions(request, headers, runtime);
    }
    async getShiftWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.shiftId)) {
            query["shiftId"] = request.shiftId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetShift",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/shifts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetShiftResponse({}));
    }
    async getShift(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetShiftHeaders({});
        return await this.getShiftWithOptions(request, headers, runtime);
    }
    async getSimpleOvertimeSettingWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSimpleOvertimeSetting",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/overtimeSettings`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSimpleOvertimeSettingResponse({}));
    }
    async getSimpleOvertimeSetting(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSimpleOvertimeSettingHeaders({});
        return await this.getSimpleOvertimeSettingWithOptions(request, headers, runtime);
    }
    async getUserHolidaysWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        if (!tea_util_1.default.isUnset(request.workDateFrom)) {
            body["workDateFrom"] = request.workDateFrom;
        }
        if (!tea_util_1.default.isUnset(request.workDateTo)) {
            body["workDateTo"] = request.workDateTo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetUserHolidays",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/holidays`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserHolidaysResponse({}));
    }
    async getUserHolidays(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserHolidaysHeaders({});
        return await this.getUserHolidaysWithOptions(request, headers, runtime);
    }
    async groupAddWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.adjustmentSettingId)) {
            body["adjustmentSettingId"] = request.adjustmentSettingId;
        }
        if (!tea_util_1.default.isUnset(request.bleDeviceList)) {
            body["bleDeviceList"] = request.bleDeviceList;
        }
        if (!tea_util_1.default.isUnset(request.checkNeedHealthyCode)) {
            body["checkNeedHealthyCode"] = request.checkNeedHealthyCode;
        }
        if (!tea_util_1.default.isUnset(request.defaultClassId)) {
            body["defaultClassId"] = request.defaultClassId;
        }
        if (!tea_util_1.default.isUnset(request.disableCheckWhenRest)) {
            body["disableCheckWhenRest"] = request.disableCheckWhenRest;
        }
        if (!tea_util_1.default.isUnset(request.disableCheckWithoutSchedule)) {
            body["disableCheckWithoutSchedule"] = request.disableCheckWithoutSchedule;
        }
        if (!tea_util_1.default.isUnset(request.enableCameraCheck)) {
            body["enableCameraCheck"] = request.enableCameraCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableEmpSelectClass)) {
            body["enableEmpSelectClass"] = request.enableEmpSelectClass;
        }
        if (!tea_util_1.default.isUnset(request.enableFaceCheck)) {
            body["enableFaceCheck"] = request.enableFaceCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableFaceStrictMode)) {
            body["enableFaceStrictMode"] = request.enableFaceStrictMode;
        }
        if (!tea_util_1.default.isUnset(request.enableNextDay)) {
            body["enableNextDay"] = request.enableNextDay;
        }
        if (!tea_util_1.default.isUnset(request.enableOutSideUpdateNormalCheck)) {
            body["enableOutSideUpdateNormalCheck"] = request.enableOutSideUpdateNormalCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableOutsideApply)) {
            body["enableOutsideApply"] = request.enableOutsideApply;
        }
        if (!tea_util_1.default.isUnset(request.enableOutsideCameraCheck)) {
            body["enableOutsideCameraCheck"] = request.enableOutsideCameraCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableOutsideCheck)) {
            body["enableOutsideCheck"] = request.enableOutsideCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableOutsideRemark)) {
            body["enableOutsideRemark"] = request.enableOutsideRemark;
        }
        if (!tea_util_1.default.isUnset(request.enablePositionBle)) {
            body["enablePositionBle"] = request.enablePositionBle;
        }
        if (!tea_util_1.default.isUnset(request.enableTrimDistance)) {
            body["enableTrimDistance"] = request.enableTrimDistance;
        }
        if (!tea_util_1.default.isUnset(request.forbidHideOutSideAddress)) {
            body["forbidHideOutSideAddress"] = request.forbidHideOutSideAddress;
        }
        if (!tea_util_1.default.isUnset(request.freeCheckSetting)) {
            body["freeCheckSetting"] = request.freeCheckSetting;
        }
        if (!tea_util_1.default.isUnset(request.freeCheckTypeId)) {
            body["freeCheckTypeId"] = request.freeCheckTypeId;
        }
        if (!tea_util_1.default.isUnset(request.freecheckDayStartMinOffset)) {
            body["freecheckDayStartMinOffset"] = request.freecheckDayStartMinOffset;
        }
        if (!tea_util_1.default.isUnset(request.freecheckWorkDays)) {
            body["freecheckWorkDays"] = request.freecheckWorkDays;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            body["groupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.managerList)) {
            body["managerList"] = request.managerList;
        }
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.modifyMember)) {
            body["modifyMember"] = request.modifyMember;
        }
        if (!tea_util_1.default.isUnset(request.offset)) {
            body["offset"] = request.offset;
        }
        if (!tea_util_1.default.isUnset(request.openCameraCheck)) {
            body["openCameraCheck"] = request.openCameraCheck;
        }
        if (!tea_util_1.default.isUnset(request.openFaceCheck)) {
            body["openFaceCheck"] = request.openFaceCheck;
        }
        if (!tea_util_1.default.isUnset(request.outsideCheckApproveModeId)) {
            body["outsideCheckApproveModeId"] = request.outsideCheckApproveModeId;
        }
        if (!tea_util_1.default.isUnset(request.overtimeSettingId)) {
            body["overtimeSettingId"] = request.overtimeSettingId;
        }
        if (!tea_util_1.default.isUnset(request.owner)) {
            body["owner"] = request.owner;
        }
        if (!tea_util_1.default.isUnset(request.positions)) {
            body["positions"] = request.positions;
        }
        if (!tea_util_1.default.isUnset(request.resourcePermissionMap)) {
            body["resourcePermissionMap"] = request.resourcePermissionMap;
        }
        if (!tea_util_1.default.isUnset(request.shiftVOList)) {
            body["shiftVOList"] = request.shiftVOList;
        }
        if (!tea_util_1.default.isUnset(request.skipHolidays)) {
            body["skipHolidays"] = request.skipHolidays;
        }
        if (!tea_util_1.default.isUnset(request.specialDays)) {
            body["specialDays"] = request.specialDays;
        }
        if (!tea_util_1.default.isUnset(request.trimDistance)) {
            body["trimDistance"] = request.trimDistance;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        if (!tea_util_1.default.isUnset(request.wifis)) {
            body["wifis"] = request.wifis;
        }
        if (!tea_util_1.default.isUnset(request.workdayClassList)) {
            body["workdayClassList"] = request.workdayClassList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupAdd",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/groups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupAddResponse({}));
    }
    async groupAdd(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupAddHeaders({});
        return await this.groupAddWithOptions(request, headers, runtime);
    }
    async groupUpdateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.adjustmentSettingId)) {
            body["adjustmentSettingId"] = request.adjustmentSettingId;
        }
        if (!tea_util_1.default.isUnset(request.disableCheckWhenRest)) {
            body["disableCheckWhenRest"] = request.disableCheckWhenRest;
        }
        if (!tea_util_1.default.isUnset(request.disableCheckWithoutSchedule)) {
            body["disableCheckWithoutSchedule"] = request.disableCheckWithoutSchedule;
        }
        if (!tea_util_1.default.isUnset(request.enableCameraCheck)) {
            body["enableCameraCheck"] = request.enableCameraCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableEmpSelectClass)) {
            body["enableEmpSelectClass"] = request.enableEmpSelectClass;
        }
        if (!tea_util_1.default.isUnset(request.enableFaceCheck)) {
            body["enableFaceCheck"] = request.enableFaceCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableFaceStrictMode)) {
            body["enableFaceStrictMode"] = request.enableFaceStrictMode;
        }
        if (!tea_util_1.default.isUnset(request.enableOutSideUpdateNormalCheck)) {
            body["enableOutSideUpdateNormalCheck"] = request.enableOutSideUpdateNormalCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableOutsideApply)) {
            body["enableOutsideApply"] = request.enableOutsideApply;
        }
        if (!tea_util_1.default.isUnset(request.enableOutsideCheck)) {
            body["enableOutsideCheck"] = request.enableOutsideCheck;
        }
        if (!tea_util_1.default.isUnset(request.enableOutsideRemark)) {
            body["enableOutsideRemark"] = request.enableOutsideRemark;
        }
        if (!tea_util_1.default.isUnset(request.enableTrimDistance)) {
            body["enableTrimDistance"] = request.enableTrimDistance;
        }
        if (!tea_util_1.default.isUnset(request.forbidHideOutSideAddress)) {
            body["forbidHideOutSideAddress"] = request.forbidHideOutSideAddress;
        }
        if (!tea_util_1.default.isUnset(request.freeCheckSetting)) {
            body["freeCheckSetting"] = request.freeCheckSetting;
        }
        if (!tea_util_1.default.isUnset(request.freeCheckTypeId)) {
            body["freeCheckTypeId"] = request.freeCheckTypeId;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            body["groupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.managerList)) {
            body["managerList"] = request.managerList;
        }
        if (!tea_util_1.default.isUnset(request.offset)) {
            body["offset"] = request.offset;
        }
        if (!tea_util_1.default.isUnset(request.openCameraCheck)) {
            body["openCameraCheck"] = request.openCameraCheck;
        }
        if (!tea_util_1.default.isUnset(request.openFaceCheck)) {
            body["openFaceCheck"] = request.openFaceCheck;
        }
        if (!tea_util_1.default.isUnset(request.outsideCheckApproveModeId)) {
            body["outsideCheckApproveModeId"] = request.outsideCheckApproveModeId;
        }
        if (!tea_util_1.default.isUnset(request.overtimeSettingId)) {
            body["overtimeSettingId"] = request.overtimeSettingId;
        }
        if (!tea_util_1.default.isUnset(request.owner)) {
            body["owner"] = request.owner;
        }
        if (!tea_util_1.default.isUnset(request.positions)) {
            body["positions"] = request.positions;
        }
        if (!tea_util_1.default.isUnset(request.resourcePermissionMap)) {
            body["resourcePermissionMap"] = request.resourcePermissionMap;
        }
        if (!tea_util_1.default.isUnset(request.shiftVOList)) {
            body["shiftVOList"] = request.shiftVOList;
        }
        if (!tea_util_1.default.isUnset(request.skipHolidays)) {
            body["skipHolidays"] = request.skipHolidays;
        }
        if (!tea_util_1.default.isUnset(request.trimDistance)) {
            body["trimDistance"] = request.trimDistance;
        }
        if (!tea_util_1.default.isUnset(request.workdayClassList)) {
            body["workdayClassList"] = request.workdayClassList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GroupUpdate",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/groups`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GroupUpdateResponse({}));
    }
    async groupUpdate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GroupUpdateHeaders({});
        return await this.groupUpdateWithOptions(request, headers, runtime);
    }
    async initAndGetLeaveALlocationQuotasWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.leaveCode)) {
            query["leaveCode"] = request.leaveCode;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "InitAndGetLeaveALlocationQuotas",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/leaves/initializations/balances`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InitAndGetLeaveALlocationQuotasResponse({}));
    }
    async initAndGetLeaveALlocationQuotas(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InitAndGetLeaveALlocationQuotasHeaders({});
        return await this.initAndGetLeaveALlocationQuotasWithOptions(request, headers, runtime);
    }
    async listApproveByUsersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizTypes)) {
            body["bizTypes"] = request.bizTypes;
        }
        if (!tea_util_1.default.isUnset(request.fromDateTime)) {
            body["fromDateTime"] = request.fromDateTime;
        }
        if (!tea_util_1.default.isUnset(request.toDateTime)) {
            body["toDateTime"] = request.toDateTime;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListApproveByUsers",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/approvals/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListApproveByUsersResponse({}));
    }
    async listApproveByUsers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListApproveByUsersHeaders({});
        return await this.listApproveByUsersWithOptions(request, headers, runtime);
    }
    async modifyWaterMarkTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.formCode)) {
            body["formCode"] = request.formCode;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.layoutDesignId)) {
            body["layoutDesignId"] = request.layoutDesignId;
        }
        if (!tea_util_1.default.isUnset(request.schemaContent)) {
            body["schemaContent"] = request.schemaContent;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.waterMarkId)) {
            body["waterMarkId"] = request.waterMarkId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ModifyWaterMarkTemplate",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/watermarks/templates`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ModifyWaterMarkTemplateResponse({}));
    }
    async modifyWaterMarkTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ModifyWaterMarkTemplateHeaders({});
        return await this.modifyWaterMarkTemplateWithOptions(request, headers, runtime);
    }
    async processApproveCreateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.approveId)) {
            body["approveId"] = request.approveId;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.punchParam)) {
            body["punchParam"] = request.punchParam;
        }
        if (!tea_util_1.default.isUnset(request.subType)) {
            body["subType"] = request.subType;
        }
        if (!tea_util_1.default.isUnset(request.tagName)) {
            body["tagName"] = request.tagName;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ProcessApproveCreate",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/workflows/checkInForms`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ProcessApproveCreateResponse({}));
    }
    async processApproveCreate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ProcessApproveCreateHeaders({});
        return await this.processApproveCreateWithOptions(request, headers, runtime);
    }
    async processApproveFinishWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.approveId)) {
            body["approveId"] = request.approveId;
        }
        if (!tea_util_1.default.isUnset(request.jumpUrl)) {
            body["jumpUrl"] = request.jumpUrl;
        }
        if (!tea_util_1.default.isUnset(request.overTimeToMore)) {
            body["overTimeToMore"] = request.overTimeToMore;
        }
        if (!tea_util_1.default.isUnset(request.overtimeDuration)) {
            body["overtimeDuration"] = request.overtimeDuration;
        }
        if (!tea_util_1.default.isUnset(request.subType)) {
            body["subType"] = request.subType;
        }
        if (!tea_util_1.default.isUnset(request.tagName)) {
            body["tagName"] = request.tagName;
        }
        if (!tea_util_1.default.isUnset(request.topCalculateApproveDurationParam)) {
            body["topCalculateApproveDurationParam"] = request.topCalculateApproveDurationParam;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ProcessApproveFinish",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/approvals/finish`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ProcessApproveFinishResponse({}));
    }
    async processApproveFinish(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ProcessApproveFinishHeaders({});
        return await this.processApproveFinishWithOptions(request, headers, runtime);
    }
    async reduceQuotaWithLeaveRecordWithOptions(unionId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.leaveCode)) {
            body["leaveCode"] = request.leaveCode;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.quotaNum)) {
            body["quotaNum"] = request.quotaNum;
        }
        if (!tea_util_1.default.isUnset(request.reason)) {
            body["reason"] = request.reason;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ReduceQuotaWithLeaveRecord",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/users/${unionId}/vacations/records/modify`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ReduceQuotaWithLeaveRecordResponse({}));
    }
    async reduceQuotaWithLeaveRecord(unionId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReduceQuotaWithLeaveRecordHeaders({});
        return await this.reduceQuotaWithLeaveRecordWithOptions(unionId, request, headers, runtime);
    }
    async retainLeaveTypesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.leaveCodes)) {
            body["leaveCodes"] = request.leaveCodes;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RetainLeaveTypes",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/vacations/types/change`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RetainLeaveTypesResponse({}));
    }
    async retainLeaveTypes(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RetainLeaveTypesHeaders({});
        return await this.retainLeaveTypesWithOptions(request, headers, runtime);
    }
    async reverseTrialAdvancedLeaveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.servCode)) {
            query["servCode"] = request.servCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ReverseTrialAdvancedLeave",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/leaves/reverse`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ReverseTrialAdvancedLeaveResponse({}));
    }
    async reverseTrialAdvancedLeave(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReverseTrialAdvancedLeaveHeaders({});
        return await this.reverseTrialAdvancedLeaveWithOptions(request, headers, runtime);
    }
    async saveCustomWaterMarkTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            body["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.layoutDesignId)) {
            body["layoutDesignId"] = request.layoutDesignId;
        }
        if (!tea_util_1.default.isUnset(request.sceneCode)) {
            body["sceneCode"] = request.sceneCode;
        }
        if (!tea_util_1.default.isUnset(request.schemaContent)) {
            body["schemaContent"] = request.schemaContent;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SaveCustomWaterMarkTemplate",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/watermarks/templates`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SaveCustomWaterMarkTemplateResponse({}));
    }
    async saveCustomWaterMarkTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SaveCustomWaterMarkTemplateHeaders({});
        return await this.saveCustomWaterMarkTemplateWithOptions(request, headers, runtime);
    }
    async syncScheduleInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleInfos)) {
            body["scheduleInfos"] = request.scheduleInfos;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SyncScheduleInfo",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/schedules/additionalInfo`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "none",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SyncScheduleInfoResponse({}));
    }
    async syncScheduleInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SyncScheduleInfoHeaders({});
        return await this.syncScheduleInfoWithOptions(request, headers, runtime);
    }
    async updateLeaveTypeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            body["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.extras)) {
            body["extras"] = request.extras;
        }
        if (!tea_util_1.default.isUnset(request.hoursInPerDay)) {
            body["hoursInPerDay"] = request.hoursInPerDay;
        }
        if (!tea_util_1.default.isUnset(request.leaveCertificate)) {
            body["leaveCertificate"] = request.leaveCertificate;
        }
        if (!tea_util_1.default.isUnset(request.leaveCode)) {
            body["leaveCode"] = request.leaveCode;
        }
        if (!tea_util_1.default.isUnset(request.leaveName)) {
            body["leaveName"] = request.leaveName;
        }
        if (!tea_util_1.default.isUnset(request.leaveViewUnit)) {
            body["leaveViewUnit"] = request.leaveViewUnit;
        }
        if (!tea_util_1.default.isUnset(request.naturalDayLeave)) {
            body["naturalDayLeave"] = request.naturalDayLeave;
        }
        if (!tea_util_1.default.isUnset(request.submitTimeRule)) {
            body["submitTimeRule"] = request.submitTimeRule;
        }
        if (!tea_util_1.default.isUnset(request.visibilityRules)) {
            body["visibilityRules"] = request.visibilityRules;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateLeaveType",
            version: "attendance_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/attendance/leaves/types`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateLeaveTypeResponse({}));
    }
    async updateLeaveType(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateLeaveTypeHeaders({});
        return await this.updateLeaveTypeWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map