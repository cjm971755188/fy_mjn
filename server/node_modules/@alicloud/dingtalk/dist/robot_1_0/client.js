"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class BatchOTOQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchOTOQueryHeaders = BatchOTOQueryHeaders;
class BatchOTOQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            processQueryKey: 'processQueryKey',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
            robotCode: 'string',
        };
    }
}
exports.BatchOTOQueryRequest = BatchOTOQueryRequest;
class BatchOTOQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageReadInfoList: 'messageReadInfoList',
            sendStatus: 'sendStatus',
        };
    }
    static types() {
        return {
            messageReadInfoList: { 'type': 'array', 'itemType': BatchOTOQueryResponseBodyMessageReadInfoList },
            sendStatus: 'string',
        };
    }
}
exports.BatchOTOQueryResponseBody = BatchOTOQueryResponseBody;
class BatchOTOQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchOTOQueryResponseBody,
        };
    }
}
exports.BatchOTOQueryResponse = BatchOTOQueryResponse;
class BatchRecallGroupHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchRecallGroupHeaders = BatchRecallGroupHeaders;
class BatchRecallGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatbotId: 'chatbotId',
            openConversationId: 'openConversationId',
            processQueryKeys: 'processQueryKeys',
        };
    }
    static types() {
        return {
            chatbotId: 'string',
            openConversationId: 'string',
            processQueryKeys: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchRecallGroupRequest = BatchRecallGroupRequest;
class BatchRecallGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedResult: 'failedResult',
            successResult: 'successResult',
        };
    }
    static types() {
        return {
            failedResult: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            successResult: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchRecallGroupResponseBody = BatchRecallGroupResponseBody;
class BatchRecallGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchRecallGroupResponseBody,
        };
    }
}
exports.BatchRecallGroupResponse = BatchRecallGroupResponse;
class BatchRecallOTOHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchRecallOTOHeaders = BatchRecallOTOHeaders;
class BatchRecallOTORequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            processQueryKeys: 'processQueryKeys',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            processQueryKeys: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
}
exports.BatchRecallOTORequest = BatchRecallOTORequest;
class BatchRecallOTOResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedResult: 'failedResult',
            successResult: 'successResult',
        };
    }
    static types() {
        return {
            failedResult: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            successResult: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchRecallOTOResponseBody = BatchRecallOTOResponseBody;
class BatchRecallOTOResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchRecallOTOResponseBody,
        };
    }
}
exports.BatchRecallOTOResponse = BatchRecallOTOResponse;
class BatchRecallPrivateChatHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchRecallPrivateChatHeaders = BatchRecallPrivateChatHeaders;
class BatchRecallPrivateChatRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
            processQueryKeys: 'processQueryKeys',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            processQueryKeys: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
}
exports.BatchRecallPrivateChatRequest = BatchRecallPrivateChatRequest;
class BatchRecallPrivateChatResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedResult: 'failedResult',
            successResult: 'successResult',
        };
    }
    static types() {
        return {
            failedResult: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            successResult: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchRecallPrivateChatResponseBody = BatchRecallPrivateChatResponseBody;
class BatchRecallPrivateChatResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchRecallPrivateChatResponseBody,
        };
    }
}
exports.BatchRecallPrivateChatResponse = BatchRecallPrivateChatResponse;
class BatchSendOTOHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchSendOTOHeaders = BatchSendOTOHeaders;
class BatchSendOTORequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            robotCode: 'robotCode',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            msgKey: 'string',
            msgParam: 'string',
            robotCode: 'string',
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchSendOTORequest = BatchSendOTORequest;
class BatchSendOTOResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            flowControlledStaffIdList: 'flowControlledStaffIdList',
            invalidStaffIdList: 'invalidStaffIdList',
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            flowControlledStaffIdList: { 'type': 'array', 'itemType': 'string' },
            invalidStaffIdList: { 'type': 'array', 'itemType': 'string' },
            processQueryKey: 'string',
        };
    }
}
exports.BatchSendOTOResponseBody = BatchSendOTOResponseBody;
class BatchSendOTOResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchSendOTOResponseBody,
        };
    }
}
exports.BatchSendOTOResponse = BatchSendOTOResponse;
class ClearRobotPluginHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ClearRobotPluginHeaders = ClearRobotPluginHeaders;
class ClearRobotPluginRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            robotCode: 'string',
        };
    }
}
exports.ClearRobotPluginRequest = ClearRobotPluginRequest;
class ClearRobotPluginResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.ClearRobotPluginResponseBody = ClearRobotPluginResponseBody;
class ClearRobotPluginResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ClearRobotPluginResponseBody,
        };
    }
}
exports.ClearRobotPluginResponse = ClearRobotPluginResponse;
class ExecuteRobotAiSkillHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ExecuteRobotAiSkillHeaders = ExecuteRobotAiSkillHeaders;
class ExecuteRobotAiSkillRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            context: 'context',
            input: 'input',
            robotCode: 'robotCode',
            skillId: 'skillId',
        };
    }
    static types() {
        return {
            context: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            input: 'string',
            robotCode: 'string',
            skillId: 'string',
        };
    }
}
exports.ExecuteRobotAiSkillRequest = ExecuteRobotAiSkillRequest;
class ExecuteRobotAiSkillResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            skillExecuteId: 'skillExecuteId',
        };
    }
    static types() {
        return {
            result: 'string',
            skillExecuteId: 'string',
        };
    }
}
exports.ExecuteRobotAiSkillResponseBody = ExecuteRobotAiSkillResponseBody;
class ExecuteRobotAiSkillResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ExecuteRobotAiSkillResponseBody,
        };
    }
}
exports.ExecuteRobotAiSkillResponse = ExecuteRobotAiSkillResponse;
class GetBotListInGroupHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetBotListInGroupHeaders = GetBotListInGroupHeaders;
class GetBotListInGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
}
exports.GetBotListInGroupRequest = GetBotListInGroupRequest;
class GetBotListInGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatbotInstanceVOList: 'chatbotInstanceVOList',
        };
    }
    static types() {
        return {
            chatbotInstanceVOList: { 'type': 'array', 'itemType': GetBotListInGroupResponseBodyChatbotInstanceVOList },
        };
    }
}
exports.GetBotListInGroupResponseBody = GetBotListInGroupResponseBody;
class GetBotListInGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetBotListInGroupResponseBody,
        };
    }
}
exports.GetBotListInGroupResponse = GetBotListInGroupResponse;
class ManageSingleChatRobotStatusHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ManageSingleChatRobotStatusHeaders = ManageSingleChatRobotStatusHeaders;
class ManageSingleChatRobotStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            robotCode: 'robotCode',
            status: 'status',
        };
    }
    static types() {
        return {
            robotCode: 'string',
            status: 'string',
        };
    }
}
exports.ManageSingleChatRobotStatusRequest = ManageSingleChatRobotStatusRequest;
class ManageSingleChatRobotStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.ManageSingleChatRobotStatusResponseBody = ManageSingleChatRobotStatusResponseBody;
class ManageSingleChatRobotStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ManageSingleChatRobotStatusResponseBody,
        };
    }
}
exports.ManageSingleChatRobotStatusResponse = ManageSingleChatRobotStatusResponse;
class OrgGroupQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.OrgGroupQueryHeaders = OrgGroupQueryHeaders;
class OrgGroupQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            processQueryKey: 'processQueryKey',
            robotCode: 'robotCode',
            token: 'token',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            processQueryKey: 'string',
            robotCode: 'string',
            token: 'string',
        };
    }
}
exports.OrgGroupQueryRequest = OrgGroupQueryRequest;
class OrgGroupQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            readUserIds: 'readUserIds',
            sendStatus: 'sendStatus',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            readUserIds: { 'type': 'array', 'itemType': 'string' },
            sendStatus: 'string',
        };
    }
}
exports.OrgGroupQueryResponseBody = OrgGroupQueryResponseBody;
class OrgGroupQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OrgGroupQueryResponseBody,
        };
    }
}
exports.OrgGroupQueryResponse = OrgGroupQueryResponse;
class OrgGroupRecallHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.OrgGroupRecallHeaders = OrgGroupRecallHeaders;
class OrgGroupRecallRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
            processQueryKeys: 'processQueryKeys',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            processQueryKeys: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
}
exports.OrgGroupRecallRequest = OrgGroupRecallRequest;
class OrgGroupRecallResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedResult: 'failedResult',
            successResult: 'successResult',
        };
    }
    static types() {
        return {
            failedResult: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            successResult: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.OrgGroupRecallResponseBody = OrgGroupRecallResponseBody;
class OrgGroupRecallResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OrgGroupRecallResponseBody,
        };
    }
}
exports.OrgGroupRecallResponse = OrgGroupRecallResponse;
class OrgGroupSendHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.OrgGroupSendHeaders = OrgGroupSendHeaders;
class OrgGroupSendRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            openConversationId: 'openConversationId',
            robotCode: 'robotCode',
            token: 'token',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            msgKey: 'string',
            msgParam: 'string',
            openConversationId: 'string',
            robotCode: 'string',
            token: 'string',
        };
    }
}
exports.OrgGroupSendRequest = OrgGroupSendRequest;
class OrgGroupSendResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
}
exports.OrgGroupSendResponseBody = OrgGroupSendResponseBody;
class OrgGroupSendResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: OrgGroupSendResponseBody,
        };
    }
}
exports.OrgGroupSendResponse = OrgGroupSendResponse;
class PrivateChatQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PrivateChatQueryHeaders = PrivateChatQueryHeaders;
class PrivateChatQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            openConversationId: 'openConversationId',
            processQueryKey: 'processQueryKey',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            openConversationId: 'string',
            processQueryKey: 'string',
            robotCode: 'string',
        };
    }
}
exports.PrivateChatQueryRequest = PrivateChatQueryRequest;
class PrivateChatQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            readUserIds: 'readUserIds',
            sendStatus: 'sendStatus',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            readUserIds: { 'type': 'array', 'itemType': 'string' },
            sendStatus: 'string',
        };
    }
}
exports.PrivateChatQueryResponseBody = PrivateChatQueryResponseBody;
class PrivateChatQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PrivateChatQueryResponseBody,
        };
    }
}
exports.PrivateChatQueryResponse = PrivateChatQueryResponse;
class PrivateChatSendHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PrivateChatSendHeaders = PrivateChatSendHeaders;
class PrivateChatSendRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            coolAppCode: 'coolAppCode',
            msgKey: 'msgKey',
            msgParam: 'msgParam',
            openConversationId: 'openConversationId',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            coolAppCode: 'string',
            msgKey: 'string',
            msgParam: 'string',
            openConversationId: 'string',
            robotCode: 'string',
        };
    }
}
exports.PrivateChatSendRequest = PrivateChatSendRequest;
class PrivateChatSendResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            processQueryKey: 'processQueryKey',
        };
    }
    static types() {
        return {
            processQueryKey: 'string',
        };
    }
}
exports.PrivateChatSendResponseBody = PrivateChatSendResponseBody;
class PrivateChatSendResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PrivateChatSendResponseBody,
        };
    }
}
exports.PrivateChatSendResponse = PrivateChatSendResponse;
class QueryBotInstanceInGroupInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryBotInstanceInGroupInfoHeaders = QueryBotInstanceInGroupInfoHeaders;
class QueryBotInstanceInGroupInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            pageNumber: 'number',
            pageSize: 'number',
            robotCode: 'string',
        };
    }
}
exports.QueryBotInstanceInGroupInfoRequest = QueryBotInstanceInGroupInfoRequest;
class QueryBotInstanceInGroupInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            openConversationIds: 'openConversationIds',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryBotInstanceInGroupInfoResponseBody = QueryBotInstanceInGroupInfoResponseBody;
class QueryBotInstanceInGroupInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryBotInstanceInGroupInfoResponseBody,
        };
    }
}
exports.QueryBotInstanceInGroupInfoResponse = QueryBotInstanceInGroupInfoResponse;
class QueryRobotPluginHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryRobotPluginHeaders = QueryRobotPluginHeaders;
class QueryRobotPluginRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            robotCode: 'string',
        };
    }
}
exports.QueryRobotPluginRequest = QueryRobotPluginRequest;
class QueryRobotPluginResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pluginInfoList: 'pluginInfoList',
        };
    }
    static types() {
        return {
            pluginInfoList: { 'type': 'array', 'itemType': QueryRobotPluginResponseBodyPluginInfoList },
        };
    }
}
exports.QueryRobotPluginResponseBody = QueryRobotPluginResponseBody;
class QueryRobotPluginResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRobotPluginResponseBody,
        };
    }
}
exports.QueryRobotPluginResponse = QueryRobotPluginResponse;
class RobotMessageFileDownloadHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RobotMessageFileDownloadHeaders = RobotMessageFileDownloadHeaders;
class RobotMessageFileDownloadRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadCode: 'downloadCode',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            downloadCode: 'string',
            robotCode: 'string',
        };
    }
}
exports.RobotMessageFileDownloadRequest = RobotMessageFileDownloadRequest;
class RobotMessageFileDownloadResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadUrl: 'downloadUrl',
        };
    }
    static types() {
        return {
            downloadUrl: 'string',
        };
    }
}
exports.RobotMessageFileDownloadResponseBody = RobotMessageFileDownloadResponseBody;
class RobotMessageFileDownloadResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RobotMessageFileDownloadResponseBody,
        };
    }
}
exports.RobotMessageFileDownloadResponse = RobotMessageFileDownloadResponse;
class RobotRecallDingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RobotRecallDingHeaders = RobotRecallDingHeaders;
class RobotRecallDingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openDingId: 'openDingId',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            openDingId: 'string',
            robotCode: 'string',
        };
    }
}
exports.RobotRecallDingRequest = RobotRecallDingRequest;
class RobotRecallDingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openDingId: 'openDingId',
        };
    }
    static types() {
        return {
            openDingId: 'string',
        };
    }
}
exports.RobotRecallDingResponseBody = RobotRecallDingResponseBody;
class RobotRecallDingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RobotRecallDingResponseBody,
        };
    }
}
exports.RobotRecallDingResponse = RobotRecallDingResponse;
class RobotSendDingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RobotSendDingHeaders = RobotSendDingHeaders;
class RobotSendDingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            receiverUserIdList: 'receiverUserIdList',
            remindType: 'remindType',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            content: 'string',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            remindType: 'number',
            robotCode: 'string',
        };
    }
}
exports.RobotSendDingRequest = RobotSendDingRequest;
class RobotSendDingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failedList: 'failedList',
            openDingId: 'openDingId',
        };
    }
    static types() {
        return {
            failedList: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            openDingId: 'string',
        };
    }
}
exports.RobotSendDingResponseBody = RobotSendDingResponseBody;
class RobotSendDingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RobotSendDingResponseBody,
        };
    }
}
exports.RobotSendDingResponse = RobotSendDingResponse;
class SendRobotDingMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendRobotDingMessageHeaders = SendRobotDingMessageHeaders;
class SendRobotDingMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentParams: 'contentParams',
            dingTemplateId: 'dingTemplateId',
            openConversationId: 'openConversationId',
            receiverUserIdList: 'receiverUserIdList',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            contentParams: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            dingTemplateId: 'string',
            openConversationId: 'string',
            receiverUserIdList: { 'type': 'array', 'itemType': 'string' },
            robotCode: 'string',
        };
    }
}
exports.SendRobotDingMessageRequest = SendRobotDingMessageRequest;
class SendRobotDingMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingSendResultId: 'dingSendResultId',
        };
    }
    static types() {
        return {
            dingSendResultId: 'string',
        };
    }
}
exports.SendRobotDingMessageResponseBody = SendRobotDingMessageResponseBody;
class SendRobotDingMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendRobotDingMessageResponseBody,
        };
    }
}
exports.SendRobotDingMessageResponse = SendRobotDingMessageResponse;
class SetRobotPluginHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SetRobotPluginHeaders = SetRobotPluginHeaders;
class SetRobotPluginRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            pluginInfoList: 'pluginInfoList',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            pluginInfoList: { 'type': 'array', 'itemType': SetRobotPluginRequestPluginInfoList },
            robotCode: 'string',
        };
    }
}
exports.SetRobotPluginRequest = SetRobotPluginRequest;
class SetRobotPluginResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.SetRobotPluginResponseBody = SetRobotPluginResponseBody;
class SetRobotPluginResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SetRobotPluginResponseBody,
        };
    }
}
exports.SetRobotPluginResponse = SetRobotPluginResponse;
class UpdateInstalledRobotHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateInstalledRobotHeaders = UpdateInstalledRobotHeaders;
class UpdateInstalledRobotRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            brief: 'brief',
            description: 'description',
            icon: 'icon',
            name: 'name',
            robotCode: 'robotCode',
            updateType: 'updateType',
        };
    }
    static types() {
        return {
            brief: 'string',
            description: 'string',
            icon: 'string',
            name: 'string',
            robotCode: 'string',
            updateType: 'number',
        };
    }
}
exports.UpdateInstalledRobotRequest = UpdateInstalledRobotRequest;
class UpdateInstalledRobotResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdateInstalledRobotResponseBody = UpdateInstalledRobotResponseBody;
class UpdateInstalledRobotResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateInstalledRobotResponseBody,
        };
    }
}
exports.UpdateInstalledRobotResponse = UpdateInstalledRobotResponse;
class BatchOTOQueryResponseBodyMessageReadInfoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            readStatus: 'readStatus',
            readTimestamp: 'readTimestamp',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            readStatus: 'string',
            readTimestamp: 'number',
            userId: 'string',
        };
    }
}
exports.BatchOTOQueryResponseBodyMessageReadInfoList = BatchOTOQueryResponseBodyMessageReadInfoList;
class GetBotListInGroupResponseBodyChatbotInstanceVOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadIconURL: 'downloadIconURL',
            name: 'name',
            openRobotType: 'openRobotType',
            robotCode: 'robotCode',
        };
    }
    static types() {
        return {
            downloadIconURL: 'string',
            name: 'string',
            openRobotType: 'number',
            robotCode: 'string',
        };
    }
}
exports.GetBotListInGroupResponseBodyChatbotInstanceVOList = GetBotListInGroupResponseBodyChatbotInstanceVOList;
class QueryRobotPluginResponseBodyPluginInfoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            mobileUrl: 'mobileUrl',
            name: 'name',
            pcUrl: 'pcUrl',
        };
    }
    static types() {
        return {
            icon: 'string',
            mobileUrl: 'string',
            name: 'string',
            pcUrl: 'string',
        };
    }
}
exports.QueryRobotPluginResponseBodyPluginInfoList = QueryRobotPluginResponseBodyPluginInfoList;
class SetRobotPluginRequestPluginInfoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            icon: 'icon',
            mobileUrl: 'mobileUrl',
            name: 'name',
            pcUrl: 'pcUrl',
        };
    }
    static types() {
        return {
            icon: 'string',
            mobileUrl: 'string',
            name: 'string',
            pcUrl: 'string',
        };
    }
}
exports.SetRobotPluginRequestPluginInfoList = SetRobotPluginRequestPluginInfoList;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async batchOTOQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.processQueryKey)) {
            query["processQueryKey"] = request.processQueryKey;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            query["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "BatchOTOQuery",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/oToMessages/readStatus`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchOTOQueryResponse({}));
    }
    async batchOTOQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchOTOQueryHeaders({});
        return await this.batchOTOQueryWithOptions(request, headers, runtime);
    }
    async batchRecallGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatbotId)) {
            body["chatbotId"] = request.chatbotId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKeys)) {
            body["processQueryKeys"] = request.processQueryKeys;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchRecallGroup",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/groupMessages/batchRecall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchRecallGroupResponse({}));
    }
    async batchRecallGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchRecallGroupHeaders({});
        return await this.batchRecallGroupWithOptions(request, headers, runtime);
    }
    async batchRecallOTOWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.processQueryKeys)) {
            body["processQueryKeys"] = request.processQueryKeys;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchRecallOTO",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/otoMessages/batchRecall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchRecallOTOResponse({}));
    }
    async batchRecallOTO(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchRecallOTOHeaders({});
        return await this.batchRecallOTOWithOptions(request, headers, runtime);
    }
    async batchRecallPrivateChatWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKeys)) {
            body["processQueryKeys"] = request.processQueryKeys;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchRecallPrivateChat",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/privateChatMessages/batchRecall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchRecallPrivateChatResponse({}));
    }
    async batchRecallPrivateChat(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchRecallPrivateChatHeaders({});
        return await this.batchRecallPrivateChatWithOptions(request, headers, runtime);
    }
    async batchSendOTOWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.userIds)) {
            body["userIds"] = request.userIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchSendOTO",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/oToMessages/batchSend`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchSendOTOResponse({}));
    }
    async batchSendOTO(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchSendOTOHeaders({});
        return await this.batchSendOTOWithOptions(request, headers, runtime);
    }
    async clearRobotPluginWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ClearRobotPlugin",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/plugins/clear`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ClearRobotPluginResponse({}));
    }
    async clearRobotPlugin(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ClearRobotPluginHeaders({});
        return await this.clearRobotPluginWithOptions(request, headers, runtime);
    }
    async executeRobotAiSkillWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.context)) {
            body["context"] = request.context;
        }
        if (!tea_util_1.default.isUnset(request.input)) {
            body["input"] = request.input;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.skillId)) {
            body["skillId"] = request.skillId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ExecuteRobotAiSkill",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/aiSkill/execute`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ExecuteRobotAiSkillResponse({}));
    }
    async executeRobotAiSkill(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ExecuteRobotAiSkillHeaders({});
        return await this.executeRobotAiSkillWithOptions(request, headers, runtime);
    }
    async getBotListInGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetBotListInGroup",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/groups/robots/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetBotListInGroupResponse({}));
    }
    async getBotListInGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetBotListInGroupHeaders({});
        return await this.getBotListInGroupWithOptions(request, headers, runtime);
    }
    async manageSingleChatRobotStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ManageSingleChatRobotStatus",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/statuses/manage`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ManageSingleChatRobotStatusResponse({}));
    }
    async manageSingleChatRobotStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ManageSingleChatRobotStatusHeaders({});
        return await this.manageSingleChatRobotStatusWithOptions(request, headers, runtime);
    }
    async orgGroupQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKey)) {
            body["processQueryKey"] = request.processQueryKey;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            body["token"] = request.token;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OrgGroupQuery",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/groupMessages/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OrgGroupQueryResponse({}));
    }
    async orgGroupQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OrgGroupQueryHeaders({});
        return await this.orgGroupQueryWithOptions(request, headers, runtime);
    }
    async orgGroupRecallWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKeys)) {
            body["processQueryKeys"] = request.processQueryKeys;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OrgGroupRecall",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/groupMessages/recall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OrgGroupRecallResponse({}));
    }
    async orgGroupRecall(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OrgGroupRecallHeaders({});
        return await this.orgGroupRecallWithOptions(request, headers, runtime);
    }
    async orgGroupSendWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.token)) {
            body["token"] = request.token;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "OrgGroupSend",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/groupMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new OrgGroupSendResponse({}));
    }
    async orgGroupSend(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new OrgGroupSendHeaders({});
        return await this.orgGroupSendWithOptions(request, headers, runtime);
    }
    async privateChatQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.processQueryKey)) {
            body["processQueryKey"] = request.processQueryKey;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PrivateChatQuery",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/privateChatMessages/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PrivateChatQueryResponse({}));
    }
    async privateChatQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PrivateChatQueryHeaders({});
        return await this.privateChatQueryWithOptions(request, headers, runtime);
    }
    async privateChatSendWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.coolAppCode)) {
            body["coolAppCode"] = request.coolAppCode;
        }
        if (!tea_util_1.default.isUnset(request.msgKey)) {
            body["msgKey"] = request.msgKey;
        }
        if (!tea_util_1.default.isUnset(request.msgParam)) {
            body["msgParam"] = request.msgParam;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "PrivateChatSend",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/privateChatMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PrivateChatSendResponse({}));
    }
    async privateChatSend(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PrivateChatSendHeaders({});
        return await this.privateChatSendWithOptions(request, headers, runtime);
    }
    async queryBotInstanceInGroupInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            body["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            body["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryBotInstanceInGroupInfo",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/groups/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryBotInstanceInGroupInfoResponse({}));
    }
    async queryBotInstanceInGroupInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryBotInstanceInGroupInfoHeaders({});
        return await this.queryBotInstanceInGroupInfoWithOptions(request, headers, runtime);
    }
    async queryRobotPluginWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryRobotPlugin",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/plugins/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryRobotPluginResponse({}));
    }
    async queryRobotPlugin(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryRobotPluginHeaders({});
        return await this.queryRobotPluginWithOptions(request, headers, runtime);
    }
    async robotMessageFileDownloadWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.downloadCode)) {
            body["downloadCode"] = request.downloadCode;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RobotMessageFileDownload",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/messageFiles/download`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RobotMessageFileDownloadResponse({}));
    }
    async robotMessageFileDownload(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RobotMessageFileDownloadHeaders({});
        return await this.robotMessageFileDownloadWithOptions(request, headers, runtime);
    }
    async robotRecallDingWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openDingId)) {
            body["openDingId"] = request.openDingId;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RobotRecallDing",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/ding/recall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RobotRecallDingResponse({}));
    }
    async robotRecallDing(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RobotRecallDingHeaders({});
        return await this.robotRecallDingWithOptions(request, headers, runtime);
    }
    async robotSendDingWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.remindType)) {
            body["remindType"] = request.remindType;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RobotSendDing",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/ding/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RobotSendDingResponse({}));
    }
    async robotSendDing(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RobotSendDingHeaders({});
        return await this.robotSendDingWithOptions(request, headers, runtime);
    }
    async sendRobotDingMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.contentParams)) {
            body["contentParams"] = request.contentParams;
        }
        if (!tea_util_1.default.isUnset(request.dingTemplateId)) {
            body["dingTemplateId"] = request.dingTemplateId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIdList)) {
            body["receiverUserIdList"] = request.receiverUserIdList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendRobotDingMessage",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/dingMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendRobotDingMessageResponse({}));
    }
    async sendRobotDingMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendRobotDingMessageHeaders({});
        return await this.sendRobotDingMessageWithOptions(request, headers, runtime);
    }
    async setRobotPluginWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.pluginInfoList)) {
            body["pluginInfoList"] = request.pluginInfoList;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SetRobotPlugin",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/plugins/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SetRobotPluginResponse({}));
    }
    async setRobotPlugin(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SetRobotPluginHeaders({});
        return await this.setRobotPluginWithOptions(request, headers, runtime);
    }
    async updateInstalledRobotWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.brief)) {
            body["brief"] = request.brief;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.icon)) {
            body["icon"] = request.icon;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.robotCode)) {
            body["robotCode"] = request.robotCode;
        }
        if (!tea_util_1.default.isUnset(request.updateType)) {
            body["updateType"] = request.updateType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateInstalledRobot",
            version: "robot_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/robot/managements/infos`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateInstalledRobotResponse({}));
    }
    async updateInstalledRobot(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateInstalledRobotHeaders({});
        return await this.updateInstalledRobotWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map