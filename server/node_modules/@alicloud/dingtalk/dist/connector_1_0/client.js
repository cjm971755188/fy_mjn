"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class CreateActionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateActionHeaders = CreateActionHeaders;
class CreateActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionInfo: 'actionInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            actionInfo: { 'type': 'array', 'itemType': CreateActionRequestActionInfo },
            integratorFlag: 'string',
        };
    }
}
exports.CreateActionRequest = CreateActionRequest;
class CreateActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': CreateActionResponseBodyItem },
        };
    }
}
exports.CreateActionResponseBody = CreateActionResponseBody;
class CreateActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateActionResponseBody,
        };
    }
}
exports.CreateActionResponse = CreateActionResponse;
class CreateConnectorHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateConnectorHeaders = CreateConnectorHeaders;
class CreateConnectorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectorInfo: 'connectorInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            connectorInfo: { 'type': 'array', 'itemType': CreateConnectorRequestConnectorInfo },
            integratorFlag: 'string',
        };
    }
}
exports.CreateConnectorRequest = CreateConnectorRequest;
class CreateConnectorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': CreateConnectorResponseBodyItem },
        };
    }
}
exports.CreateConnectorResponseBody = CreateConnectorResponseBody;
class CreateConnectorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateConnectorResponseBody,
        };
    }
}
exports.CreateConnectorResponse = CreateConnectorResponse;
class CreateInvocableInstanceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateInvocableInstanceHeaders = CreateInvocableInstanceHeaders;
class CreateInvocableInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectAssetUri: 'connectAssetUri',
            instanceKey: 'instanceKey',
        };
    }
    static types() {
        return {
            connectAssetUri: 'string',
            instanceKey: 'string',
        };
    }
}
exports.CreateInvocableInstanceRequest = CreateInvocableInstanceRequest;
class CreateInvocableInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectAssetUri: 'connectAssetUri',
            versionId: 'versionId',
        };
    }
    static types() {
        return {
            connectAssetUri: 'string',
            versionId: 'string',
        };
    }
}
exports.CreateInvocableInstanceResponseBody = CreateInvocableInstanceResponseBody;
class CreateInvocableInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateInvocableInstanceResponseBody,
        };
    }
}
exports.CreateInvocableInstanceResponse = CreateInvocableInstanceResponse;
class CreateTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateTriggerHeaders = CreateTriggerHeaders;
class CreateTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            integratorFlag: 'integratorFlag',
            triggerInfo: 'triggerInfo',
        };
    }
    static types() {
        return {
            integratorFlag: 'string',
            triggerInfo: { 'type': 'array', 'itemType': CreateTriggerRequestTriggerInfo },
        };
    }
}
exports.CreateTriggerRequest = CreateTriggerRequest;
class CreateTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': CreateTriggerResponseBodyItem },
        };
    }
}
exports.CreateTriggerResponseBody = CreateTriggerResponseBody;
class CreateTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateTriggerResponseBody,
        };
    }
}
exports.CreateTriggerResponse = CreateTriggerResponse;
class GetActionDetailHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetActionDetailHeaders = GetActionDetailHeaders;
class GetActionDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectAssetUri: 'connectAssetUri',
        };
    }
    static types() {
        return {
            connectAssetUri: 'string',
        };
    }
}
exports.GetActionDetailRequest = GetActionDetailRequest;
class GetActionDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectAssetUri: 'connectAssetUri',
            inputSchema: 'inputSchema',
            integrationConfig: 'integrationConfig',
            name: 'name',
            outputSchema: 'outputSchema',
            refId: 'refId',
            refProviderCorpId: 'refProviderCorpId',
            refType: 'refType',
        };
    }
    static types() {
        return {
            connectAssetUri: 'string',
            inputSchema: 'string',
            integrationConfig: GetActionDetailResponseBodyIntegrationConfig,
            name: 'string',
            outputSchema: 'string',
            refId: 'string',
            refProviderCorpId: 'string',
            refType: 'string',
        };
    }
}
exports.GetActionDetailResponseBody = GetActionDetailResponseBody;
class GetActionDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetActionDetailResponseBody,
        };
    }
}
exports.GetActionDetailResponse = GetActionDetailResponse;
class InvokeInstanceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.InvokeInstanceHeaders = InvokeInstanceHeaders;
class InvokeInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectAssetUri: 'connectAssetUri',
            inputJsonString: 'inputJsonString',
            instanceKey: 'instanceKey',
        };
    }
    static types() {
        return {
            connectAssetUri: 'string',
            inputJsonString: 'string',
            instanceKey: 'string',
        };
    }
}
exports.InvokeInstanceRequest = InvokeInstanceRequest;
class InvokeInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cost: 'cost',
            errorCode: 'errorCode',
            errorMessage: 'errorMessage',
            instanceId: 'instanceId',
            outputJson: 'outputJson',
        };
    }
    static types() {
        return {
            cost: 'number',
            errorCode: 'string',
            errorMessage: 'string',
            instanceId: 'string',
            outputJson: 'string',
        };
    }
}
exports.InvokeInstanceResponseBody = InvokeInstanceResponseBody;
class InvokeInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InvokeInstanceResponseBody,
        };
    }
}
exports.InvokeInstanceResponse = InvokeInstanceResponse;
class PullDataByPageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PullDataByPageHeaders = PullDataByPageHeaders;
class PullDataByPageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            dataModelId: 'dataModelId',
            datetimeFilterField: 'datetimeFilterField',
            maxDatetime: 'maxDatetime',
            maxResults: 'maxResults',
            minDatetime: 'minDatetime',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            appId: 'string',
            dataModelId: 'string',
            datetimeFilterField: 'string',
            maxDatetime: 'number',
            maxResults: 'number',
            minDatetime: 'number',
            nextToken: 'string',
        };
    }
}
exports.PullDataByPageRequest = PullDataByPageRequest;
class PullDataByPageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': PullDataByPageResponseBodyList },
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.PullDataByPageResponseBody = PullDataByPageResponseBody;
class PullDataByPageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PullDataByPageResponseBody,
        };
    }
}
exports.PullDataByPageResponse = PullDataByPageResponse;
class PullDataByPkHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.PullDataByPkHeaders = PullDataByPkHeaders;
class PullDataByPkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            primaryKey: 'primaryKey',
        };
    }
    static types() {
        return {
            appId: 'string',
            primaryKey: 'string',
        };
    }
}
exports.PullDataByPkRequest = PullDataByPkRequest;
class PullDataByPkResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataCreateAppId: 'dataCreateAppId',
            dataCreateAppType: 'dataCreateAppType',
            dataGmtCreate: 'dataGmtCreate',
            dataGmtModified: 'dataGmtModified',
            dataModifiedAppId: 'dataModifiedAppId',
            dataModifiedAppType: 'dataModifiedAppType',
            jsonData: 'jsonData',
        };
    }
    static types() {
        return {
            dataCreateAppId: 'string',
            dataCreateAppType: 'string',
            dataGmtCreate: 'number',
            dataGmtModified: 'number',
            dataModifiedAppId: 'string',
            dataModifiedAppType: 'string',
            jsonData: 'string',
        };
    }
}
exports.PullDataByPkResponseBody = PullDataByPkResponseBody;
class PullDataByPkResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: PullDataByPkResponseBody,
        };
    }
}
exports.PullDataByPkResponse = PullDataByPkResponse;
class SearchActionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SearchActionsHeaders = SearchActionsHeaders;
class SearchActionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectorId: 'connectorId',
            connectorProviderCorpId: 'connectorProviderCorpId',
            integrationTypes: 'integrationTypes',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            connectorId: 'string',
            connectorProviderCorpId: 'string',
            integrationTypes: { 'type': 'array', 'itemType': 'string' },
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.SearchActionsRequest = SearchActionsRequest;
class SearchActionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': SearchActionsResponseBodyList },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.SearchActionsResponseBody = SearchActionsResponseBody;
class SearchActionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SearchActionsResponseBody,
        };
    }
}
exports.SearchActionsResponse = SearchActionsResponse;
class SearchConnectorsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SearchConnectorsHeaders = SearchConnectorsHeaders;
class SearchConnectorsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            type: 'type',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            type: 'string',
        };
    }
}
exports.SearchConnectorsRequest = SearchConnectorsRequest;
class SearchConnectorsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': SearchConnectorsResponseBodyList },
            nextToken: 'string',
            totalCount: 'string',
        };
    }
}
exports.SearchConnectorsResponseBody = SearchConnectorsResponseBody;
class SearchConnectorsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SearchConnectorsResponseBody,
        };
    }
}
exports.SearchConnectorsResponse = SearchConnectorsResponse;
class SyncDataHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SyncDataHeaders = SyncDataHeaders;
class SyncDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            triggerDataList: 'triggerDataList',
        };
    }
    static types() {
        return {
            appId: 'string',
            triggerDataList: { 'type': 'array', 'itemType': SyncDataRequestTriggerDataList },
        };
    }
}
exports.SyncDataRequest = SyncDataRequest;
class SyncDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': SyncDataResponseBodyList },
        };
    }
}
exports.SyncDataResponseBody = SyncDataResponseBody;
class SyncDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SyncDataResponseBody,
        };
    }
}
exports.SyncDataResponse = SyncDataResponse;
class UpdateActionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateActionHeaders = UpdateActionHeaders;
class UpdateActionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionInfo: 'actionInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            actionInfo: { 'type': 'array', 'itemType': UpdateActionRequestActionInfo },
            integratorFlag: 'string',
        };
    }
}
exports.UpdateActionRequest = UpdateActionRequest;
class UpdateActionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': UpdateActionResponseBodyItem },
        };
    }
}
exports.UpdateActionResponseBody = UpdateActionResponseBody;
class UpdateActionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateActionResponseBody,
        };
    }
}
exports.UpdateActionResponse = UpdateActionResponse;
class UpdateConnectorHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateConnectorHeaders = UpdateConnectorHeaders;
class UpdateConnectorRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            connectorInfo: 'connectorInfo',
            integratorFlag: 'integratorFlag',
        };
    }
    static types() {
        return {
            connectorInfo: { 'type': 'array', 'itemType': UpdateConnectorRequestConnectorInfo },
            integratorFlag: 'string',
        };
    }
}
exports.UpdateConnectorRequest = UpdateConnectorRequest;
class UpdateConnectorResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': UpdateConnectorResponseBodyItem },
        };
    }
}
exports.UpdateConnectorResponseBody = UpdateConnectorResponseBody;
class UpdateConnectorResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateConnectorResponseBody,
        };
    }
}
exports.UpdateConnectorResponse = UpdateConnectorResponse;
class UpdateTriggerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateTriggerHeaders = UpdateTriggerHeaders;
class UpdateTriggerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            integratorFlag: 'integratorFlag',
            triggerInfo: 'triggerInfo',
        };
    }
    static types() {
        return {
            integratorFlag: 'string',
            triggerInfo: { 'type': 'array', 'itemType': UpdateTriggerRequestTriggerInfo },
        };
    }
}
exports.UpdateTriggerRequest = UpdateTriggerRequest;
class UpdateTriggerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: { 'type': 'array', 'itemType': UpdateTriggerResponseBodyItem },
        };
    }
}
exports.UpdateTriggerResponseBody = UpdateTriggerResponseBody;
class UpdateTriggerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateTriggerResponseBody,
        };
    }
}
exports.UpdateTriggerResponse = UpdateTriggerResponse;
class CreateActionRequestActionInfoInputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.CreateActionRequestActionInfoInputMappingConfig = CreateActionRequestActionInfoInputMappingConfig;
class CreateActionRequestActionInfoOutputDataRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expectValue: 'expectValue',
            operate: 'operate',
            propertyPath: 'propertyPath',
        };
    }
    static types() {
        return {
            expectValue: 'string',
            operate: 'string',
            propertyPath: 'string',
        };
    }
}
exports.CreateActionRequestActionInfoOutputDataRules = CreateActionRequestActionInfoOutputDataRules;
class CreateActionRequestActionInfoOutputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.CreateActionRequestActionInfoOutputMappingConfig = CreateActionRequestActionInfoOutputMappingConfig;
class CreateActionRequestActionInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiPath: 'apiPath',
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            inputMappingConfig: 'inputMappingConfig',
            inputSchema: 'inputSchema',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
            outputDataRules: 'outputDataRules',
            outputMappingConfig: 'outputMappingConfig',
            outputSchema: 'outputSchema',
        };
    }
    static types() {
        return {
            apiPath: 'string',
            description: 'string',
            dingConnectorId: 'string',
            inputMappingConfig: CreateActionRequestActionInfoInputMappingConfig,
            inputSchema: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
            outputDataRules: { 'type': 'array', 'itemType': CreateActionRequestActionInfoOutputDataRules },
            outputMappingConfig: CreateActionRequestActionInfoOutputMappingConfig,
            outputSchema: 'string',
        };
    }
}
exports.CreateActionRequestActionInfo = CreateActionRequestActionInfo;
class CreateActionResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingActionId: 'dingActionId',
            dingConnectorId: 'dingConnectorId',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingActionId: 'string',
            dingConnectorId: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'string',
        };
    }
}
exports.CreateActionResponseBodyItem = CreateActionResponseBodyItem;
class CreateConnectorRequestConnectorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiDomain: 'apiDomain',
            apiSecret: 'apiSecret',
            appId: 'appId',
            authValueEnv: 'authValueEnv',
            description: 'description',
            domainEnv: 'domainEnv',
            iconMediaId: 'iconMediaId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
        };
    }
    static types() {
        return {
            apiDomain: 'string',
            apiSecret: 'string',
            appId: 'number',
            authValueEnv: 'boolean',
            description: 'string',
            domainEnv: 'boolean',
            iconMediaId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
        };
    }
}
exports.CreateConnectorRequestConnectorInfo = CreateConnectorRequestConnectorInfo;
class CreateConnectorResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateConnectorResponseBodyItem = CreateConnectorResponseBodyItem;
class CreateTriggerRequestTriggerInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            inputSchema: 'inputSchema',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            name: 'name',
        };
    }
    static types() {
        return {
            description: 'string',
            dingConnectorId: 'string',
            inputSchema: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            name: 'string',
        };
    }
}
exports.CreateTriggerRequestTriggerInfo = CreateTriggerRequestTriggerInfo;
class CreateTriggerResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            dingTriggerId: 'dingTriggerId',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            dingTriggerId: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.CreateTriggerResponseBodyItem = CreateTriggerResponseBodyItem;
class GetActionDetailResponseBodyIntegrationConfigCategoryNames extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            value: 'value',
        };
    }
    static types() {
        return {
            value: 'string',
        };
    }
}
exports.GetActionDetailResponseBodyIntegrationConfigCategoryNames = GetActionDetailResponseBodyIntegrationConfigCategoryNames;
class GetActionDetailResponseBodyIntegrationConfigProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.GetActionDetailResponseBodyIntegrationConfigProps = GetActionDetailResponseBodyIntegrationConfigProps;
class GetActionDetailResponseBodyIntegrationConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            categoryNames: 'categoryNames',
            entityName: 'entityName',
            props: 'props',
        };
    }
    static types() {
        return {
            categoryNames: { 'type': 'array', 'itemType': GetActionDetailResponseBodyIntegrationConfigCategoryNames },
            entityName: 'string',
            props: { 'type': 'array', 'itemType': GetActionDetailResponseBodyIntegrationConfigProps },
        };
    }
}
exports.GetActionDetailResponseBodyIntegrationConfig = GetActionDetailResponseBodyIntegrationConfig;
class PullDataByPageResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataCreateAppId: 'dataCreateAppId',
            dataCreateAppType: 'dataCreateAppType',
            dataGmtCreate: 'dataGmtCreate',
            dataGmtModified: 'dataGmtModified',
            dataModifiedAppId: 'dataModifiedAppId',
            dataModifiedAppType: 'dataModifiedAppType',
            jsonData: 'jsonData',
        };
    }
    static types() {
        return {
            dataCreateAppId: 'string',
            dataCreateAppType: 'string',
            dataGmtCreate: 'number',
            dataGmtModified: 'number',
            dataModifiedAppId: 'string',
            dataModifiedAppType: 'string',
            jsonData: 'string',
        };
    }
}
exports.PullDataByPageResponseBodyList = PullDataByPageResponseBodyList;
class SearchActionsResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authorityUrl: 'authorityUrl',
            authorized: 'authorized',
            connectAssetUri: 'connectAssetUri',
            connectorId: 'connectorId',
            description: 'description',
            icon: 'icon',
            id: 'id',
            integrationType: 'integrationType',
            name: 'name',
            providerCorpId: 'providerCorpId',
        };
    }
    static types() {
        return {
            authorityUrl: 'string',
            authorized: 'boolean',
            connectAssetUri: 'string',
            connectorId: 'string',
            description: 'string',
            icon: 'string',
            id: 'string',
            integrationType: 'string',
            name: 'string',
            providerCorpId: 'string',
        };
    }
}
exports.SearchActionsResponseBodyList = SearchActionsResponseBodyList;
class SearchConnectorsResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            icon: 'icon',
            id: 'id',
            name: 'name',
            providerCorpId: 'providerCorpId',
        };
    }
    static types() {
        return {
            description: 'string',
            icon: 'string',
            id: 'string',
            name: 'string',
            providerCorpId: 'string',
        };
    }
}
exports.SearchConnectorsResponseBodyList = SearchConnectorsResponseBodyList;
class SyncDataRequestTriggerDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            customTriggerId: 'customTriggerId',
            dataGmtCreate: 'dataGmtCreate',
            dataGmtModified: 'dataGmtModified',
            integrationObject: 'integrationObject',
            jsonData: 'jsonData',
            triggerCondition: 'triggerCondition',
            triggerId: 'triggerId',
        };
    }
    static types() {
        return {
            action: 'string',
            customTriggerId: 'string',
            dataGmtCreate: 'number',
            dataGmtModified: 'number',
            integrationObject: 'string',
            jsonData: 'string',
            triggerCondition: 'string',
            triggerId: 'string',
        };
    }
}
exports.SyncDataRequestTriggerDataList = SyncDataRequestTriggerDataList;
class SyncDataResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizPrimaryKey: 'bizPrimaryKey',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
            triggerId: 'triggerId',
        };
    }
    static types() {
        return {
            bizPrimaryKey: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
            triggerId: 'string',
        };
    }
}
exports.SyncDataResponseBodyList = SyncDataResponseBodyList;
class UpdateActionRequestActionInfoInputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfoInputMappingConfig = UpdateActionRequestActionInfoInputMappingConfig;
class UpdateActionRequestActionInfoOutputDataRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expectValue: 'expectValue',
            operate: 'operate',
            propertyPath: 'propertyPath',
        };
    }
    static types() {
        return {
            expectValue: 'string',
            operate: 'string',
            propertyPath: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfoOutputDataRules = UpdateActionRequestActionInfoOutputDataRules;
class UpdateActionRequestActionInfoOutputMappingConfig extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customSchemaMapping: 'customSchemaMapping',
            rules: 'rules',
        };
    }
    static types() {
        return {
            customSchemaMapping: 'string',
            rules: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfoOutputMappingConfig = UpdateActionRequestActionInfoOutputMappingConfig;
class UpdateActionRequestActionInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiPath: 'apiPath',
            description: 'description',
            dingActionId: 'dingActionId',
            dingConnectorId: 'dingConnectorId',
            inputMappingConfig: 'inputMappingConfig',
            inputSchema: 'inputSchema',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
            outputDataRules: 'outputDataRules',
            outputMappingConfig: 'outputMappingConfig',
            outputSchema: 'outputSchema',
        };
    }
    static types() {
        return {
            apiPath: 'string',
            description: 'string',
            dingActionId: 'string',
            dingConnectorId: 'string',
            inputMappingConfig: UpdateActionRequestActionInfoInputMappingConfig,
            inputSchema: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
            outputDataRules: { 'type': 'array', 'itemType': UpdateActionRequestActionInfoOutputDataRules },
            outputMappingConfig: UpdateActionRequestActionInfoOutputMappingConfig,
            outputSchema: 'string',
        };
    }
}
exports.UpdateActionRequestActionInfo = UpdateActionRequestActionInfo;
class UpdateActionResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingActionId: 'dingActionId',
            dingConnectorId: 'dingConnectorId',
            integratorActionId: 'integratorActionId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingActionId: 'string',
            dingConnectorId: 'string',
            integratorActionId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'string',
        };
    }
}
exports.UpdateActionResponseBodyItem = UpdateActionResponseBodyItem;
class UpdateConnectorRequestConnectorInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            apiDomain: 'apiDomain',
            apiSecret: 'apiSecret',
            appId: 'appId',
            authValueEnv: 'authValueEnv',
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            domainEnv: 'domainEnv',
            iconMediaId: 'iconMediaId',
            integratorConnectorId: 'integratorConnectorId',
            name: 'name',
        };
    }
    static types() {
        return {
            apiDomain: 'string',
            apiSecret: 'string',
            appId: 'number',
            authValueEnv: 'boolean',
            description: 'string',
            dingConnectorId: 'string',
            domainEnv: 'boolean',
            iconMediaId: 'string',
            integratorConnectorId: 'string',
            name: 'string',
        };
    }
}
exports.UpdateConnectorRequestConnectorInfo = UpdateConnectorRequestConnectorInfo;
class UpdateConnectorResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            integratorConnectorId: 'integratorConnectorId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            integratorConnectorId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateConnectorResponseBodyItem = UpdateConnectorResponseBodyItem;
class UpdateTriggerRequestTriggerInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            dingConnectorId: 'dingConnectorId',
            dingTriggerId: 'dingTriggerId',
            inputSchema: 'inputSchema',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            name: 'name',
        };
    }
    static types() {
        return {
            description: 'string',
            dingConnectorId: 'string',
            dingTriggerId: 'string',
            inputSchema: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            name: 'string',
        };
    }
}
exports.UpdateTriggerRequestTriggerInfo = UpdateTriggerRequestTriggerInfo;
class UpdateTriggerResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dingConnectorId: 'dingConnectorId',
            dingTriggerId: 'dingTriggerId',
            integratorConnectorId: 'integratorConnectorId',
            integratorTriggerId: 'integratorTriggerId',
            subErrCode: 'subErrCode',
            subErrMsg: 'subErrMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            dingConnectorId: 'string',
            dingTriggerId: 'string',
            integratorConnectorId: 'string',
            integratorTriggerId: 'string',
            subErrCode: 'string',
            subErrMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateTriggerResponseBodyItem = UpdateTriggerResponseBodyItem;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async createActionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.actionInfo)) {
            body["actionInfo"] = request.actionInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateAction",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/actions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateActionResponse({}));
    }
    async createAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateActionHeaders({});
        return await this.createActionWithOptions(request, headers, runtime);
    }
    async createConnectorWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectorInfo)) {
            body["connectorInfo"] = request.connectorInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateConnector",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/connectors`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateConnectorResponse({}));
    }
    async createConnector(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateConnectorHeaders({});
        return await this.createConnectorWithOptions(request, headers, runtime);
    }
    async createInvocableInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectAssetUri)) {
            body["connectAssetUri"] = request.connectAssetUri;
        }
        if (!tea_util_1.default.isUnset(request.instanceKey)) {
            body["instanceKey"] = request.instanceKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateInvocableInstance",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/instances`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateInvocableInstanceResponse({}));
    }
    async createInvocableInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateInvocableInstanceHeaders({});
        return await this.createInvocableInstanceWithOptions(request, headers, runtime);
    }
    async createTriggerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        if (!tea_util_1.default.isUnset(request.triggerInfo)) {
            body["triggerInfo"] = request.triggerInfo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateTrigger",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/triggers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateTriggerResponse({}));
    }
    async createTrigger(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateTriggerHeaders({});
        return await this.createTriggerWithOptions(request, headers, runtime);
    }
    async getActionDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectAssetUri)) {
            body["connectAssetUri"] = request.connectAssetUri;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetActionDetail",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/assets/actions/details/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetActionDetailResponse({}));
    }
    async getActionDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetActionDetailHeaders({});
        return await this.getActionDetailWithOptions(request, headers, runtime);
    }
    async invokeInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectAssetUri)) {
            body["connectAssetUri"] = request.connectAssetUri;
        }
        if (!tea_util_1.default.isUnset(request.inputJsonString)) {
            body["inputJsonString"] = request.inputJsonString;
        }
        if (!tea_util_1.default.isUnset(request.instanceKey)) {
            body["instanceKey"] = request.instanceKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InvokeInstance",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/instances/invoke`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InvokeInstanceResponse({}));
    }
    async invokeInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InvokeInstanceHeaders({});
        return await this.invokeInstanceWithOptions(request, headers, runtime);
    }
    async pullDataByPageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            query["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.dataModelId)) {
            query["dataModelId"] = request.dataModelId;
        }
        if (!tea_util_1.default.isUnset(request.datetimeFilterField)) {
            query["datetimeFilterField"] = request.datetimeFilterField;
        }
        if (!tea_util_1.default.isUnset(request.maxDatetime)) {
            query["maxDatetime"] = request.maxDatetime;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.minDatetime)) {
            query["minDatetime"] = request.minDatetime;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PullDataByPage",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/data`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PullDataByPageResponse({}));
    }
    async pullDataByPage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PullDataByPageHeaders({});
        return await this.pullDataByPageWithOptions(request, headers, runtime);
    }
    async pullDataByPkWithOptions(dataModelId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            query["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.primaryKey)) {
            query["primaryKey"] = request.primaryKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "PullDataByPk",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/data/${dataModelId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new PullDataByPkResponse({}));
    }
    async pullDataByPk(dataModelId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new PullDataByPkHeaders({});
        return await this.pullDataByPkWithOptions(dataModelId, request, headers, runtime);
    }
    async searchActionsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectorId)) {
            body["connectorId"] = request.connectorId;
        }
        if (!tea_util_1.default.isUnset(request.connectorProviderCorpId)) {
            body["connectorProviderCorpId"] = request.connectorProviderCorpId;
        }
        if (!tea_util_1.default.isUnset(request.integrationTypes)) {
            body["integrationTypes"] = request.integrationTypes;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SearchActions",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/assets/actions/search`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SearchActionsResponse({}));
    }
    async searchActions(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchActionsHeaders({});
        return await this.searchActionsWithOptions(request, headers, runtime);
    }
    async searchConnectorsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            query["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "SearchConnectors",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/assets/connectors`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SearchConnectorsResponse({}));
    }
    async searchConnectors(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SearchConnectorsHeaders({});
        return await this.searchConnectorsWithOptions(request, headers, runtime);
    }
    async syncDataWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.appId)) {
            body["appId"] = request.appId;
        }
        if (!tea_util_1.default.isUnset(request.triggerDataList)) {
            body["triggerDataList"] = request.triggerDataList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SyncData",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/triggers/data/sync`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SyncDataResponse({}));
    }
    async syncData(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SyncDataHeaders({});
        return await this.syncDataWithOptions(request, headers, runtime);
    }
    async updateActionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.actionInfo)) {
            body["actionInfo"] = request.actionInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateAction",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/actions`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateActionResponse({}));
    }
    async updateAction(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateActionHeaders({});
        return await this.updateActionWithOptions(request, headers, runtime);
    }
    async updateConnectorWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.connectorInfo)) {
            body["connectorInfo"] = request.connectorInfo;
        }
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateConnector",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/connectors`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateConnectorResponse({}));
    }
    async updateConnector(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateConnectorHeaders({});
        return await this.updateConnectorWithOptions(request, headers, runtime);
    }
    async updateTriggerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.integratorFlag)) {
            body["integratorFlag"] = request.integratorFlag;
        }
        if (!tea_util_1.default.isUnset(request.triggerInfo)) {
            body["triggerInfo"] = request.triggerInfo;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateTrigger",
            version: "connector_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/connector/triggers`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateTriggerResponse({}));
    }
    async updateTrigger(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateTriggerHeaders({});
        return await this.updateTriggerWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map