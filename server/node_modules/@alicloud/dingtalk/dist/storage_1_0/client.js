"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class DentryAppPropertiesValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.DentryAppPropertiesValue = DentryAppPropertiesValue;
class ResultItemsDentryAppPropertiesValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.ResultItemsDentryAppPropertiesValue = ResultItemsDentryAppPropertiesValue;
class DentriesAppPropertiesValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.DentriesAppPropertiesValue = DentriesAppPropertiesValue;
class AddFolderHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddFolderHeaders = AddFolderHeaders;
class AddFolderRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            option: AddFolderRequestOption,
            unionId: 'string',
        };
    }
}
exports.AddFolderRequest = AddFolderRequest;
class AddFolderResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: AddFolderResponseBodyDentry,
        };
    }
}
exports.AddFolderResponseBody = AddFolderResponseBody;
class AddFolderResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddFolderResponseBody,
        };
    }
}
exports.AddFolderResponse = AddFolderResponse;
class AddPermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddPermissionHeaders = AddPermissionHeaders;
class AddPermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            option: 'option',
            roleId: 'roleId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': AddPermissionRequestMembers },
            option: AddPermissionRequestOption,
            roleId: 'string',
            unionId: 'string',
        };
    }
}
exports.AddPermissionRequest = AddPermissionRequest;
class AddPermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.AddPermissionResponseBody = AddPermissionResponseBody;
class AddPermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddPermissionResponseBody,
        };
    }
}
exports.AddPermissionResponse = AddPermissionResponse;
class AddSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddSpaceHeaders = AddSpaceHeaders;
class AddSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: AddSpaceRequestOption,
            unionId: 'string',
        };
    }
}
exports.AddSpaceRequest = AddSpaceRequest;
class AddSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            space: 'space',
        };
    }
    static types() {
        return {
            space: AddSpaceResponseBodySpace,
        };
    }
}
exports.AddSpaceResponseBody = AddSpaceResponseBody;
class AddSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddSpaceResponseBody,
        };
    }
}
exports.AddSpaceResponse = AddSpaceResponse;
class ClearRecycleBinHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ClearRecycleBinHeaders = ClearRecycleBinHeaders;
class ClearRecycleBinRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.ClearRecycleBinRequest = ClearRecycleBinRequest;
class ClearRecycleBinResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.ClearRecycleBinResponseBody = ClearRecycleBinResponseBody;
class ClearRecycleBinResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ClearRecycleBinResponseBody,
        };
    }
}
exports.ClearRecycleBinResponse = ClearRecycleBinResponse;
class CommitFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CommitFileHeaders = CommitFileHeaders;
class CommitFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            option: 'option',
            parentId: 'parentId',
            uploadKey: 'uploadKey',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            name: 'string',
            option: CommitFileRequestOption,
            parentId: 'string',
            uploadKey: 'string',
            unionId: 'string',
        };
    }
}
exports.CommitFileRequest = CommitFileRequest;
class CommitFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: CommitFileResponseBodyDentry,
        };
    }
}
exports.CommitFileResponseBody = CommitFileResponseBody;
class CommitFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CommitFileResponseBody,
        };
    }
}
exports.CommitFileResponse = CommitFileResponse;
class CopyDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CopyDentriesHeaders = CopyDentriesHeaders;
class CopyDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryIds: 'dentryIds',
            option: 'option',
            targetFolderId: 'targetFolderId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            dentryIds: { 'type': 'array', 'itemType': 'string' },
            option: CopyDentriesRequestOption,
            targetFolderId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.CopyDentriesRequest = CopyDentriesRequest;
class CopyDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resultItems: 'resultItems',
        };
    }
    static types() {
        return {
            resultItems: { 'type': 'array', 'itemType': CopyDentriesResponseBodyResultItems },
        };
    }
}
exports.CopyDentriesResponseBody = CopyDentriesResponseBody;
class CopyDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CopyDentriesResponseBody,
        };
    }
}
exports.CopyDentriesResponse = CopyDentriesResponse;
class CopyDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CopyDentryHeaders = CopyDentryHeaders;
class CopyDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            targetFolderId: 'targetFolderId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: CopyDentryRequestOption,
            targetFolderId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.CopyDentryRequest = CopyDentryRequest;
class CopyDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentry: 'dentry',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentry: CopyDentryResponseBodyDentry,
            taskId: 'string',
        };
    }
}
exports.CopyDentryResponseBody = CopyDentryResponseBody;
class CopyDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CopyDentryResponseBody,
        };
    }
}
exports.CopyDentryResponse = CopyDentryResponse;
class DeleteDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteDentriesHeaders = DeleteDentriesHeaders;
class DeleteDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryIds: 'dentryIds',
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            dentryIds: { 'type': 'array', 'itemType': 'string' },
            option: DeleteDentriesRequestOption,
            unionId: 'string',
        };
    }
}
exports.DeleteDentriesRequest = DeleteDentriesRequest;
class DeleteDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resultItems: 'resultItems',
        };
    }
    static types() {
        return {
            resultItems: { 'type': 'array', 'itemType': DeleteDentriesResponseBodyResultItems },
        };
    }
}
exports.DeleteDentriesResponseBody = DeleteDentriesResponseBody;
class DeleteDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDentriesResponseBody,
        };
    }
}
exports.DeleteDentriesResponse = DeleteDentriesResponse;
class DeleteDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteDentryHeaders = DeleteDentryHeaders;
class DeleteDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            toRecycleBin: 'toRecycleBin',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            toRecycleBin: 'boolean',
            unionId: 'string',
        };
    }
}
exports.DeleteDentryRequest = DeleteDentryRequest;
class DeleteDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            taskId: 'string',
        };
    }
}
exports.DeleteDentryResponseBody = DeleteDentryResponseBody;
class DeleteDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDentryResponseBody,
        };
    }
}
exports.DeleteDentryResponse = DeleteDentryResponse;
class DeleteDentryAppPropertiesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteDentryAppPropertiesHeaders = DeleteDentryAppPropertiesHeaders;
class DeleteDentryAppPropertiesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            propertyNames: 'propertyNames',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            propertyNames: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.DeleteDentryAppPropertiesRequest = DeleteDentryAppPropertiesRequest;
class DeleteDentryAppPropertiesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeleteDentryAppPropertiesResponseBody = DeleteDentryAppPropertiesResponseBody;
class DeleteDentryAppPropertiesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteDentryAppPropertiesResponseBody,
        };
    }
}
exports.DeleteDentryAppPropertiesResponse = DeleteDentryAppPropertiesResponse;
class DeletePermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeletePermissionHeaders = DeletePermissionHeaders;
class DeletePermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            roleId: 'roleId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': DeletePermissionRequestMembers },
            roleId: 'string',
            unionId: 'string',
        };
    }
}
exports.DeletePermissionRequest = DeletePermissionRequest;
class DeletePermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeletePermissionResponseBody = DeletePermissionResponseBody;
class DeletePermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeletePermissionResponseBody,
        };
    }
}
exports.DeletePermissionResponse = DeletePermissionResponse;
class DeleteRecycleItemHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteRecycleItemHeaders = DeleteRecycleItemHeaders;
class DeleteRecycleItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.DeleteRecycleItemRequest = DeleteRecycleItemRequest;
class DeleteRecycleItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeleteRecycleItemResponseBody = DeleteRecycleItemResponseBody;
class DeleteRecycleItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteRecycleItemResponseBody,
        };
    }
}
exports.DeleteRecycleItemResponse = DeleteRecycleItemResponse;
class DeleteRecycleItemsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteRecycleItemsHeaders = DeleteRecycleItemsHeaders;
class DeleteRecycleItemsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleItemIds: 'recycleItemIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            recycleItemIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.DeleteRecycleItemsRequest = DeleteRecycleItemsRequest;
class DeleteRecycleItemsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeleteRecycleItemsResponseBody = DeleteRecycleItemsResponseBody;
class DeleteRecycleItemsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteRecycleItemsResponseBody,
        };
    }
}
exports.DeleteRecycleItemsResponse = DeleteRecycleItemsResponse;
class GetCurrentAppHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCurrentAppHeaders = GetCurrentAppHeaders;
class GetCurrentAppRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetCurrentAppRequest = GetCurrentAppRequest;
class GetCurrentAppResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            app: 'app',
        };
    }
    static types() {
        return {
            app: GetCurrentAppResponseBodyApp,
        };
    }
}
exports.GetCurrentAppResponseBody = GetCurrentAppResponseBody;
class GetCurrentAppResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCurrentAppResponseBody,
        };
    }
}
exports.GetCurrentAppResponse = GetCurrentAppResponse;
class GetDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetDentriesHeaders = GetDentriesHeaders;
class GetDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryIds: 'dentryIds',
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            dentryIds: { 'type': 'array', 'itemType': 'string' },
            option: GetDentriesRequestOption,
            unionId: 'string',
        };
    }
}
exports.GetDentriesRequest = GetDentriesRequest;
class GetDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resultItems: 'resultItems',
        };
    }
    static types() {
        return {
            resultItems: { 'type': 'array', 'itemType': GetDentriesResponseBodyResultItems },
        };
    }
}
exports.GetDentriesResponseBody = GetDentriesResponseBody;
class GetDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDentriesResponseBody,
        };
    }
}
exports.GetDentriesResponse = GetDentriesResponse;
class GetDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetDentryHeaders = GetDentryHeaders;
class GetDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: GetDentryRequestOption,
            unionId: 'string',
        };
    }
}
exports.GetDentryRequest = GetDentryRequest;
class GetDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: GetDentryResponseBodyDentry,
        };
    }
}
exports.GetDentryResponseBody = GetDentryResponseBody;
class GetDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDentryResponseBody,
        };
    }
}
exports.GetDentryResponse = GetDentryResponse;
class GetDentryOpenInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetDentryOpenInfoHeaders = GetDentryOpenInfoHeaders;
class GetDentryOpenInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: GetDentryOpenInfoRequestOption,
            unionId: 'string',
        };
    }
}
exports.GetDentryOpenInfoRequest = GetDentryOpenInfoRequest;
class GetDentryOpenInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasWaterMark: 'hasWaterMark',
            url: 'url',
        };
    }
    static types() {
        return {
            hasWaterMark: 'boolean',
            url: 'string',
        };
    }
}
exports.GetDentryOpenInfoResponseBody = GetDentryOpenInfoResponseBody;
class GetDentryOpenInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDentryOpenInfoResponseBody,
        };
    }
}
exports.GetDentryOpenInfoResponse = GetDentryOpenInfoResponse;
class GetDentryThumbnailsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetDentryThumbnailsHeaders = GetDentryThumbnailsHeaders;
class GetDentryThumbnailsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryIds: 'dentryIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            dentryIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.GetDentryThumbnailsRequest = GetDentryThumbnailsRequest;
class GetDentryThumbnailsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resultItems: 'resultItems',
        };
    }
    static types() {
        return {
            resultItems: { 'type': 'array', 'itemType': GetDentryThumbnailsResponseBodyResultItems },
        };
    }
}
exports.GetDentryThumbnailsResponseBody = GetDentryThumbnailsResponseBody;
class GetDentryThumbnailsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetDentryThumbnailsResponseBody,
        };
    }
}
exports.GetDentryThumbnailsResponse = GetDentryThumbnailsResponse;
class GetFileDownloadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileDownloadInfoHeaders = GetFileDownloadInfoHeaders;
class GetFileDownloadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: GetFileDownloadInfoRequestOption,
            unionId: 'string',
        };
    }
}
exports.GetFileDownloadInfoRequest = GetFileDownloadInfoRequest;
class GetFileDownloadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headerSignatureInfo: 'headerSignatureInfo',
            protocol: 'protocol',
        };
    }
    static types() {
        return {
            headerSignatureInfo: GetFileDownloadInfoResponseBodyHeaderSignatureInfo,
            protocol: 'string',
        };
    }
}
exports.GetFileDownloadInfoResponseBody = GetFileDownloadInfoResponseBody;
class GetFileDownloadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFileDownloadInfoResponseBody,
        };
    }
}
exports.GetFileDownloadInfoResponse = GetFileDownloadInfoResponse;
class GetFileUploadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileUploadInfoHeaders = GetFileUploadInfoHeaders;
class GetFileUploadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            multipart: 'multipart',
            option: 'option',
            protocol: 'protocol',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            multipart: 'boolean',
            option: GetFileUploadInfoRequestOption,
            protocol: 'string',
            unionId: 'string',
        };
    }
}
exports.GetFileUploadInfoRequest = GetFileUploadInfoRequest;
class GetFileUploadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headerSignatureInfo: 'headerSignatureInfo',
            protocol: 'protocol',
            storageDriver: 'storageDriver',
            uploadKey: 'uploadKey',
        };
    }
    static types() {
        return {
            headerSignatureInfo: GetFileUploadInfoResponseBodyHeaderSignatureInfo,
            protocol: 'string',
            storageDriver: 'string',
            uploadKey: 'string',
        };
    }
}
exports.GetFileUploadInfoResponseBody = GetFileUploadInfoResponseBody;
class GetFileUploadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFileUploadInfoResponseBody,
        };
    }
}
exports.GetFileUploadInfoResponse = GetFileUploadInfoResponse;
class GetMultipartFileUploadInfosHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetMultipartFileUploadInfosHeaders = GetMultipartFileUploadInfosHeaders;
class GetMultipartFileUploadInfosRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            partNumbers: 'partNumbers',
            uploadKey: 'uploadKey',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: GetMultipartFileUploadInfosRequestOption,
            partNumbers: { 'type': 'array', 'itemType': 'number' },
            uploadKey: 'string',
            unionId: 'string',
        };
    }
}
exports.GetMultipartFileUploadInfosRequest = GetMultipartFileUploadInfosRequest;
class GetMultipartFileUploadInfosResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            multipartHeaderSignatureInfos: 'multipartHeaderSignatureInfos',
        };
    }
    static types() {
        return {
            multipartHeaderSignatureInfos: { 'type': 'array', 'itemType': GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos },
        };
    }
}
exports.GetMultipartFileUploadInfosResponseBody = GetMultipartFileUploadInfosResponseBody;
class GetMultipartFileUploadInfosResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMultipartFileUploadInfosResponseBody,
        };
    }
}
exports.GetMultipartFileUploadInfosResponse = GetMultipartFileUploadInfosResponse;
class GetOrgHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetOrgHeaders = GetOrgHeaders;
class GetOrgRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetOrgRequest = GetOrgRequest;
class GetOrgResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            org: 'org',
        };
    }
    static types() {
        return {
            org: GetOrgResponseBodyOrg,
        };
    }
}
exports.GetOrgResponseBody = GetOrgResponseBody;
class GetOrgResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOrgResponseBody,
        };
    }
}
exports.GetOrgResponse = GetOrgResponse;
class GetRecycleBinHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetRecycleBinHeaders = GetRecycleBinHeaders;
class GetRecycleBinRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleBinScope: 'recycleBinScope',
            scopeId: 'scopeId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            recycleBinScope: 'string',
            scopeId: 'string',
            unionId: 'string',
        };
    }
}
exports.GetRecycleBinRequest = GetRecycleBinRequest;
class GetRecycleBinResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            recycleBin: 'recycleBin',
        };
    }
    static types() {
        return {
            recycleBin: GetRecycleBinResponseBodyRecycleBin,
        };
    }
}
exports.GetRecycleBinResponseBody = GetRecycleBinResponseBody;
class GetRecycleBinResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRecycleBinResponseBody,
        };
    }
}
exports.GetRecycleBinResponse = GetRecycleBinResponse;
class GetRecycleItemHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetRecycleItemHeaders = GetRecycleItemHeaders;
class GetRecycleItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetRecycleItemRequest = GetRecycleItemRequest;
class GetRecycleItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            item: 'item',
        };
    }
    static types() {
        return {
            item: GetRecycleItemResponseBodyItem,
        };
    }
}
exports.GetRecycleItemResponseBody = GetRecycleItemResponseBody;
class GetRecycleItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRecycleItemResponseBody,
        };
    }
}
exports.GetRecycleItemResponse = GetRecycleItemResponse;
class GetSpaceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSpaceHeaders = GetSpaceHeaders;
class GetSpaceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetSpaceRequest = GetSpaceRequest;
class GetSpaceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            space: 'space',
        };
    }
    static types() {
        return {
            space: GetSpaceResponseBodySpace,
        };
    }
}
exports.GetSpaceResponseBody = GetSpaceResponseBody;
class GetSpaceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSpaceResponseBody,
        };
    }
}
exports.GetSpaceResponse = GetSpaceResponse;
class GetTaskHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetTaskHeaders = GetTaskHeaders;
class GetTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.GetTaskRequest = GetTaskRequest;
class GetTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            task: 'task',
        };
    }
    static types() {
        return {
            task: GetTaskResponseBodyTask,
        };
    }
}
exports.GetTaskResponseBody = GetTaskResponseBody;
class GetTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetTaskResponseBody,
        };
    }
}
exports.GetTaskResponse = GetTaskResponse;
class InitMultipartFileUploadHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.InitMultipartFileUploadHeaders = InitMultipartFileUploadHeaders;
class InitMultipartFileUploadRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: InitMultipartFileUploadRequestOption,
            unionId: 'string',
        };
    }
}
exports.InitMultipartFileUploadRequest = InitMultipartFileUploadRequest;
class InitMultipartFileUploadResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            storageDriver: 'storageDriver',
            uploadKey: 'uploadKey',
        };
    }
    static types() {
        return {
            storageDriver: 'string',
            uploadKey: 'string',
        };
    }
}
exports.InitMultipartFileUploadResponseBody = InitMultipartFileUploadResponseBody;
class InitMultipartFileUploadResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InitMultipartFileUploadResponseBody,
        };
    }
}
exports.InitMultipartFileUploadResponse = InitMultipartFileUploadResponse;
class ListAllDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListAllDentriesHeaders = ListAllDentriesHeaders;
class ListAllDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: ListAllDentriesRequestOption,
            unionId: 'string',
        };
    }
}
exports.ListAllDentriesRequest = ListAllDentriesRequest;
class ListAllDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentries: 'dentries',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            dentries: { 'type': 'array', 'itemType': ListAllDentriesResponseBodyDentries },
            nextToken: 'string',
        };
    }
}
exports.ListAllDentriesResponseBody = ListAllDentriesResponseBody;
class ListAllDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListAllDentriesResponseBody,
        };
    }
}
exports.ListAllDentriesResponse = ListAllDentriesResponse;
class ListDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListDentriesHeaders = ListDentriesHeaders;
class ListDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            order: 'order',
            orderBy: 'orderBy',
            parentId: 'parentId',
            unionId: 'unionId',
            withThumbnail: 'withThumbnail',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            order: 'string',
            orderBy: 'string',
            parentId: 'string',
            unionId: 'string',
            withThumbnail: 'boolean',
        };
    }
}
exports.ListDentriesRequest = ListDentriesRequest;
class ListDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentries: 'dentries',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            dentries: { 'type': 'array', 'itemType': ListDentriesResponseBodyDentries },
            nextToken: 'string',
        };
    }
}
exports.ListDentriesResponseBody = ListDentriesResponseBody;
class ListDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListDentriesResponseBody,
        };
    }
}
exports.ListDentriesResponse = ListDentriesResponse;
class ListDentryVersionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListDentryVersionsHeaders = ListDentryVersionsHeaders;
class ListDentryVersionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            unionId: 'string',
        };
    }
}
exports.ListDentryVersionsRequest = ListDentryVersionsRequest;
class ListDentryVersionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentries: 'dentries',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            dentries: { 'type': 'array', 'itemType': ListDentryVersionsResponseBodyDentries },
            nextToken: 'string',
        };
    }
}
exports.ListDentryVersionsResponseBody = ListDentryVersionsResponseBody;
class ListDentryVersionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListDentryVersionsResponseBody,
        };
    }
}
exports.ListDentryVersionsResponse = ListDentryVersionsResponse;
class ListPermissionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListPermissionsHeaders = ListPermissionsHeaders;
class ListPermissionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: ListPermissionsRequestOption,
            unionId: 'string',
        };
    }
}
exports.ListPermissionsRequest = ListPermissionsRequest;
class ListPermissionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            permissions: 'permissions',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            permissions: { 'type': 'array', 'itemType': ListPermissionsResponseBodyPermissions },
        };
    }
}
exports.ListPermissionsResponseBody = ListPermissionsResponseBody;
class ListPermissionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListPermissionsResponseBody,
        };
    }
}
exports.ListPermissionsResponse = ListPermissionsResponse;
class ListRecycleItemsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListRecycleItemsHeaders = ListRecycleItemsHeaders;
class ListRecycleItemsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            unionId: 'string',
        };
    }
}
exports.ListRecycleItemsRequest = ListRecycleItemsRequest;
class ListRecycleItemsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nextToken: 'nextToken',
            recycleItems: 'recycleItems',
        };
    }
    static types() {
        return {
            nextToken: 'string',
            recycleItems: { 'type': 'array', 'itemType': ListRecycleItemsResponseBodyRecycleItems },
        };
    }
}
exports.ListRecycleItemsResponseBody = ListRecycleItemsResponseBody;
class ListRecycleItemsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListRecycleItemsResponseBody,
        };
    }
}
exports.ListRecycleItemsResponse = ListRecycleItemsResponse;
class MoveDentriesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MoveDentriesHeaders = MoveDentriesHeaders;
class MoveDentriesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryIds: 'dentryIds',
            option: 'option',
            targetFolderId: 'targetFolderId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            dentryIds: { 'type': 'array', 'itemType': 'string' },
            option: MoveDentriesRequestOption,
            targetFolderId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.MoveDentriesRequest = MoveDentriesRequest;
class MoveDentriesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resultItems: 'resultItems',
        };
    }
    static types() {
        return {
            resultItems: { 'type': 'array', 'itemType': MoveDentriesResponseBodyResultItems },
        };
    }
}
exports.MoveDentriesResponseBody = MoveDentriesResponseBody;
class MoveDentriesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MoveDentriesResponseBody,
        };
    }
}
exports.MoveDentriesResponse = MoveDentriesResponse;
class MoveDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MoveDentryHeaders = MoveDentryHeaders;
class MoveDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            targetFolderId: 'targetFolderId',
            targetSpaceId: 'targetSpaceId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: MoveDentryRequestOption,
            targetFolderId: 'string',
            targetSpaceId: 'string',
            unionId: 'string',
        };
    }
}
exports.MoveDentryRequest = MoveDentryRequest;
class MoveDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentry: 'dentry',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentry: MoveDentryResponseBodyDentry,
            taskId: 'string',
        };
    }
}
exports.MoveDentryResponseBody = MoveDentryResponseBody;
class MoveDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MoveDentryResponseBody,
        };
    }
}
exports.MoveDentryResponse = MoveDentryResponse;
class RegisterOpenInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RegisterOpenInfoHeaders = RegisterOpenInfoHeaders;
class RegisterOpenInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openInfos: 'openInfos',
            provider: 'provider',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            openInfos: { 'type': 'array', 'itemType': RegisterOpenInfoRequestOpenInfos },
            provider: 'string',
            unionId: 'string',
        };
    }
}
exports.RegisterOpenInfoRequest = RegisterOpenInfoRequest;
class RegisterOpenInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.RegisterOpenInfoResponseBody = RegisterOpenInfoResponseBody;
class RegisterOpenInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RegisterOpenInfoResponseBody,
        };
    }
}
exports.RegisterOpenInfoResponse = RegisterOpenInfoResponse;
class RenameDentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RenameDentryHeaders = RenameDentryHeaders;
class RenameDentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            newName: 'newName',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            newName: 'string',
            unionId: 'string',
        };
    }
}
exports.RenameDentryRequest = RenameDentryRequest;
class RenameDentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
        };
    }
    static types() {
        return {
            dentry: RenameDentryResponseBodyDentry,
        };
    }
}
exports.RenameDentryResponseBody = RenameDentryResponseBody;
class RenameDentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RenameDentryResponseBody,
        };
    }
}
exports.RenameDentryResponse = RenameDentryResponse;
class RestoreRecycleItemHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RestoreRecycleItemHeaders = RestoreRecycleItemHeaders;
class RestoreRecycleItemRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: RestoreRecycleItemRequestOption,
            unionId: 'string',
        };
    }
}
exports.RestoreRecycleItemRequest = RestoreRecycleItemRequest;
class RestoreRecycleItemResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentryId: 'dentryId',
            spaceId: 'spaceId',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentryId: 'string',
            spaceId: 'string',
            taskId: 'string',
        };
    }
}
exports.RestoreRecycleItemResponseBody = RestoreRecycleItemResponseBody;
class RestoreRecycleItemResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RestoreRecycleItemResponseBody,
        };
    }
}
exports.RestoreRecycleItemResponse = RestoreRecycleItemResponse;
class RestoreRecycleItemsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RestoreRecycleItemsHeaders = RestoreRecycleItemsHeaders;
class RestoreRecycleItemsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            option: 'option',
            recycleItemIds: 'recycleItemIds',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            option: RestoreRecycleItemsRequestOption,
            recycleItemIds: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.RestoreRecycleItemsRequest = RestoreRecycleItemsRequest;
class RestoreRecycleItemsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resultItems: 'resultItems',
        };
    }
    static types() {
        return {
            resultItems: { 'type': 'array', 'itemType': RestoreRecycleItemsResponseBodyResultItems },
        };
    }
}
exports.RestoreRecycleItemsResponseBody = RestoreRecycleItemsResponseBody;
class RestoreRecycleItemsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RestoreRecycleItemsResponseBody,
        };
    }
}
exports.RestoreRecycleItemsResponse = RestoreRecycleItemsResponse;
class RevertDentryVersionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RevertDentryVersionHeaders = RevertDentryVersionHeaders;
class RevertDentryVersionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.RevertDentryVersionRequest = RevertDentryVersionRequest;
class RevertDentryVersionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.RevertDentryVersionResponseBody = RevertDentryVersionResponseBody;
class RevertDentryVersionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RevertDentryVersionResponseBody,
        };
    }
}
exports.RevertDentryVersionResponse = RevertDentryVersionResponse;
class SubscribeEventHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SubscribeEventHeaders = SubscribeEventHeaders;
class SubscribeEventRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scope: 'scope',
            scopeId: 'scopeId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            scope: 'string',
            scopeId: 'string',
            unionId: 'string',
        };
    }
}
exports.SubscribeEventRequest = SubscribeEventRequest;
class SubscribeEventResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.SubscribeEventResponseBody = SubscribeEventResponseBody;
class SubscribeEventResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SubscribeEventResponseBody,
        };
    }
}
exports.SubscribeEventResponse = SubscribeEventResponse;
class UnsubscribeEventHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UnsubscribeEventHeaders = UnsubscribeEventHeaders;
class UnsubscribeEventRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scope: 'scope',
            scopeId: 'scopeId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            scope: 'string',
            scopeId: 'string',
            unionId: 'string',
        };
    }
}
exports.UnsubscribeEventRequest = UnsubscribeEventRequest;
class UnsubscribeEventResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UnsubscribeEventResponseBody = UnsubscribeEventResponseBody;
class UnsubscribeEventResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UnsubscribeEventResponseBody,
        };
    }
}
exports.UnsubscribeEventResponse = UnsubscribeEventResponse;
class UpdateDentryAppPropertiesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateDentryAppPropertiesHeaders = UpdateDentryAppPropertiesHeaders;
class UpdateDentryAppPropertiesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'array', 'itemType': UpdateDentryAppPropertiesRequestAppProperties },
            unionId: 'string',
        };
    }
}
exports.UpdateDentryAppPropertiesRequest = UpdateDentryAppPropertiesRequest;
class UpdateDentryAppPropertiesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdateDentryAppPropertiesResponseBody = UpdateDentryAppPropertiesResponseBody;
class UpdateDentryAppPropertiesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateDentryAppPropertiesResponseBody,
        };
    }
}
exports.UpdateDentryAppPropertiesResponse = UpdateDentryAppPropertiesResponse;
class UpdatePermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdatePermissionHeaders = UpdatePermissionHeaders;
class UpdatePermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            members: 'members',
            option: 'option',
            roleId: 'roleId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            members: { 'type': 'array', 'itemType': UpdatePermissionRequestMembers },
            option: UpdatePermissionRequestOption,
            roleId: 'string',
            unionId: 'string',
        };
    }
}
exports.UpdatePermissionRequest = UpdatePermissionRequest;
class UpdatePermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdatePermissionResponseBody = UpdatePermissionResponseBody;
class UpdatePermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdatePermissionResponseBody,
        };
    }
}
exports.UpdatePermissionResponse = UpdatePermissionResponse;
class AddFolderRequestOptionAppProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.AddFolderRequestOptionAppProperties = AddFolderRequestOptionAppProperties;
class AddFolderRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'array', 'itemType': AddFolderRequestOptionAppProperties },
            conflictStrategy: 'string',
        };
    }
}
exports.AddFolderRequestOption = AddFolderRequestOption;
class AddFolderResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.AddFolderResponseBodyDentryProperties = AddFolderResponseBodyDentryProperties;
class AddFolderResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: AddFolderResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.AddFolderResponseBodyDentry = AddFolderResponseBodyDentry;
class AddPermissionRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            id: 'id',
            type: 'type',
        };
    }
    static types() {
        return {
            corpId: 'string',
            id: 'string',
            type: 'string',
        };
    }
}
exports.AddPermissionRequestMembers = AddPermissionRequestMembers;
class AddPermissionRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
        };
    }
    static types() {
        return {
            duration: 'number',
        };
    }
}
exports.AddPermissionRequestOption = AddPermissionRequestOption;
class AddSpaceRequestOptionCapabilities extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            canRecordRecentFile: 'canRecordRecentFile',
            canRename: 'canRename',
            canSearch: 'canSearch',
        };
    }
    static types() {
        return {
            canRecordRecentFile: 'boolean',
            canRename: 'boolean',
            canSearch: 'boolean',
        };
    }
}
exports.AddSpaceRequestOptionCapabilities = AddSpaceRequestOptionCapabilities;
class AddSpaceRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            capabilities: 'capabilities',
            name: 'name',
            ownerType: 'ownerType',
            quota: 'quota',
            scene: 'scene',
            sceneId: 'sceneId',
        };
    }
    static types() {
        return {
            capabilities: AddSpaceRequestOptionCapabilities,
            name: 'string',
            ownerType: 'string',
            quota: 'number',
            scene: 'string',
            sceneId: 'string',
        };
    }
}
exports.AddSpaceRequestOption = AddSpaceRequestOption;
class AddSpaceResponseBodySpaceCapabilities extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            canRecordRecentFile: 'canRecordRecentFile',
            canRename: 'canRename',
            canSearch: 'canSearch',
        };
    }
    static types() {
        return {
            canRecordRecentFile: 'boolean',
            canRename: 'boolean',
            canSearch: 'boolean',
        };
    }
}
exports.AddSpaceResponseBodySpaceCapabilities = AddSpaceResponseBodySpaceCapabilities;
class AddSpaceResponseBodySpacePartitionsQuota extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            max: 'max',
            reserved: 'reserved',
            type: 'type',
            used: 'used',
        };
    }
    static types() {
        return {
            max: 'number',
            reserved: 'number',
            type: 'string',
            used: 'number',
        };
    }
}
exports.AddSpaceResponseBodySpacePartitionsQuota = AddSpaceResponseBodySpacePartitionsQuota;
class AddSpaceResponseBodySpacePartitions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partitionType: 'partitionType',
            quota: 'quota',
        };
    }
    static types() {
        return {
            partitionType: 'string',
            quota: AddSpaceResponseBodySpacePartitionsQuota,
        };
    }
}
exports.AddSpaceResponseBodySpacePartitions = AddSpaceResponseBodySpacePartitions;
class AddSpaceResponseBodySpace extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            capabilities: 'capabilities',
            corpId: 'corpId',
            createTime: 'createTime',
            creatorId: 'creatorId',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            ownerId: 'ownerId',
            ownerType: 'ownerType',
            partitions: 'partitions',
            quota: 'quota',
            scene: 'scene',
            sceneId: 'sceneId',
            status: 'status',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            appId: 'string',
            capabilities: AddSpaceResponseBodySpaceCapabilities,
            corpId: 'string',
            createTime: 'string',
            creatorId: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            ownerId: 'string',
            ownerType: 'string',
            partitions: { 'type': 'array', 'itemType': AddSpaceResponseBodySpacePartitions },
            quota: 'number',
            scene: 'string',
            sceneId: 'string',
            status: 'string',
            usedQuota: 'number',
        };
    }
}
exports.AddSpaceResponseBodySpace = AddSpaceResponseBodySpace;
class CommitFileRequestOptionAppProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.CommitFileRequestOptionAppProperties = CommitFileRequestOptionAppProperties;
class CommitFileRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            conflictStrategy: 'conflictStrategy',
            size: 'size',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'array', 'itemType': CommitFileRequestOptionAppProperties },
            conflictStrategy: 'string',
            size: 'number',
        };
    }
}
exports.CommitFileRequestOption = CommitFileRequestOption;
class CommitFileResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.CommitFileResponseBodyDentryProperties = CommitFileResponseBodyDentryProperties;
class CommitFileResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: CommitFileResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.CommitFileResponseBodyDentry = CommitFileResponseBodyDentry;
class CopyDentriesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
        };
    }
}
exports.CopyDentriesRequestOption = CopyDentriesRequestOption;
class CopyDentriesResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentryId: 'dentryId',
            errorCode: 'errorCode',
            spaceId: 'spaceId',
            success: 'success',
            targetDentryId: 'targetDentryId',
            targetSpaceId: 'targetSpaceId',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentryId: 'string',
            errorCode: 'string',
            spaceId: 'string',
            success: 'boolean',
            targetDentryId: 'string',
            targetSpaceId: 'string',
            taskId: 'string',
        };
    }
}
exports.CopyDentriesResponseBodyResultItems = CopyDentriesResponseBodyResultItems;
class CopyDentryRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
        };
    }
}
exports.CopyDentryRequestOption = CopyDentryRequestOption;
class CopyDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.CopyDentryResponseBodyDentryProperties = CopyDentryResponseBodyDentryProperties;
class CopyDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: CopyDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.CopyDentryResponseBodyDentry = CopyDentryResponseBodyDentry;
class DeleteDentriesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            toRecycleBin: 'toRecycleBin',
        };
    }
    static types() {
        return {
            toRecycleBin: 'boolean',
        };
    }
}
exports.DeleteDentriesRequestOption = DeleteDentriesRequestOption;
class DeleteDentriesResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentryId: 'dentryId',
            errorCode: 'errorCode',
            spaceId: 'spaceId',
            success: 'success',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentryId: 'string',
            errorCode: 'string',
            spaceId: 'string',
            success: 'boolean',
            taskId: 'string',
        };
    }
}
exports.DeleteDentriesResponseBodyResultItems = DeleteDentriesResponseBodyResultItems;
class DeletePermissionRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            id: 'id',
            type: 'type',
        };
    }
    static types() {
        return {
            corpId: 'string',
            id: 'string',
            type: 'string',
        };
    }
}
exports.DeletePermissionRequestMembers = DeletePermissionRequestMembers;
class GetCurrentAppResponseBodyAppPartitionsQuota extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            max: 'max',
            reserved: 'reserved',
            type: 'type',
            used: 'used',
        };
    }
    static types() {
        return {
            max: 'number',
            reserved: 'number',
            type: 'string',
            used: 'number',
        };
    }
}
exports.GetCurrentAppResponseBodyAppPartitionsQuota = GetCurrentAppResponseBodyAppPartitionsQuota;
class GetCurrentAppResponseBodyAppPartitions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partitionType: 'partitionType',
            quota: 'quota',
        };
    }
    static types() {
        return {
            partitionType: 'string',
            quota: GetCurrentAppResponseBodyAppPartitionsQuota,
        };
    }
}
exports.GetCurrentAppResponseBodyAppPartitions = GetCurrentAppResponseBodyAppPartitions;
class GetCurrentAppResponseBodyApp extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            corpId: 'corpId',
            createTime: 'createTime',
            modifiedTime: 'modifiedTime',
            name: 'name',
            partitions: 'partitions',
        };
    }
    static types() {
        return {
            appId: 'string',
            corpId: 'string',
            createTime: 'string',
            modifiedTime: 'string',
            name: 'string',
            partitions: { 'type': 'array', 'itemType': GetCurrentAppResponseBodyAppPartitions },
        };
    }
}
exports.GetCurrentAppResponseBodyApp = GetCurrentAppResponseBodyApp;
class GetDentriesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appIdsForAppProperties: 'appIdsForAppProperties',
            withThumbnail: 'withThumbnail',
        };
    }
    static types() {
        return {
            appIdsForAppProperties: { 'type': 'array', 'itemType': 'string' },
            withThumbnail: 'boolean',
        };
    }
}
exports.GetDentriesRequestOption = GetDentriesRequestOption;
class GetDentriesResponseBodyResultItemsDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.GetDentriesResponseBodyResultItemsDentryProperties = GetDentriesResponseBodyResultItemsDentryProperties;
class GetDentriesResponseBodyResultItemsDentryThumbnail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'height',
            url: 'url',
            width: 'width',
        };
    }
    static types() {
        return {
            height: 'number',
            url: 'string',
            width: 'number',
        };
    }
}
exports.GetDentriesResponseBodyResultItemsDentryThumbnail = GetDentriesResponseBodyResultItemsDentryThumbnail;
class GetDentriesResponseBodyResultItemsDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            thumbnail: 'thumbnail',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': ResultItemsDentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: GetDentriesResponseBodyResultItemsDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            thumbnail: GetDentriesResponseBodyResultItemsDentryThumbnail,
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.GetDentriesResponseBodyResultItemsDentry = GetDentriesResponseBodyResultItemsDentry;
class GetDentriesResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentry: 'dentry',
            dentryId: 'dentryId',
            errorCode: 'errorCode',
            spaceId: 'spaceId',
            success: 'success',
        };
    }
    static types() {
        return {
            dentry: GetDentriesResponseBodyResultItemsDentry,
            dentryId: 'string',
            errorCode: 'string',
            spaceId: 'string',
            success: 'boolean',
        };
    }
}
exports.GetDentriesResponseBodyResultItems = GetDentriesResponseBodyResultItems;
class GetDentryRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appIdsForAppProperties: 'appIdsForAppProperties',
            withThumbnail: 'withThumbnail',
        };
    }
    static types() {
        return {
            appIdsForAppProperties: { 'type': 'array', 'itemType': 'string' },
            withThumbnail: 'boolean',
        };
    }
}
exports.GetDentryRequestOption = GetDentryRequestOption;
class GetDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.GetDentryResponseBodyDentryProperties = GetDentryResponseBodyDentryProperties;
class GetDentryResponseBodyDentryThumbnail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'height',
            url: 'url',
            width: 'width',
        };
    }
    static types() {
        return {
            height: 'number',
            url: 'string',
            width: 'number',
        };
    }
}
exports.GetDentryResponseBodyDentryThumbnail = GetDentryResponseBodyDentryThumbnail;
class GetDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            thumbnail: 'thumbnail',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: GetDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            thumbnail: GetDentryResponseBodyDentryThumbnail,
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.GetDentryResponseBodyDentry = GetDentryResponseBodyDentry;
class GetDentryOpenInfoRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            checkLogin: 'checkLogin',
            type: 'type',
            version: 'version',
            waterMark: 'waterMark',
        };
    }
    static types() {
        return {
            checkLogin: 'boolean',
            type: 'string',
            version: 'number',
            waterMark: 'boolean',
        };
    }
}
exports.GetDentryOpenInfoRequestOption = GetDentryOpenInfoRequestOption;
class GetDentryThumbnailsResponseBodyResultItemsThumbnail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'height',
            url: 'url',
            width: 'width',
        };
    }
    static types() {
        return {
            height: 'number',
            url: 'string',
            width: 'number',
        };
    }
}
exports.GetDentryThumbnailsResponseBodyResultItemsThumbnail = GetDentryThumbnailsResponseBodyResultItemsThumbnail;
class GetDentryThumbnailsResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryId: 'dentryId',
            errorCode: 'errorCode',
            spaceId: 'spaceId',
            success: 'success',
            thumbnail: 'thumbnail',
        };
    }
    static types() {
        return {
            dentryId: 'string',
            errorCode: 'string',
            spaceId: 'string',
            success: 'boolean',
            thumbnail: GetDentryThumbnailsResponseBodyResultItemsThumbnail,
        };
    }
}
exports.GetDentryThumbnailsResponseBodyResultItems = GetDentryThumbnailsResponseBodyResultItems;
class GetFileDownloadInfoRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            preferIntranet: 'preferIntranet',
            version: 'version',
        };
    }
    static types() {
        return {
            preferIntranet: 'boolean',
            version: 'number',
        };
    }
}
exports.GetFileDownloadInfoRequestOption = GetFileDownloadInfoRequestOption;
class GetFileDownloadInfoResponseBodyHeaderSignatureInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationSeconds: 'expirationSeconds',
            headers: 'headers',
            internalResourceUrls: 'internalResourceUrls',
            region: 'region',
            resourceUrls: 'resourceUrls',
        };
    }
    static types() {
        return {
            expirationSeconds: 'number',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            internalResourceUrls: { 'type': 'array', 'itemType': 'string' },
            region: 'string',
            resourceUrls: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetFileDownloadInfoResponseBodyHeaderSignatureInfo = GetFileDownloadInfoResponseBodyHeaderSignatureInfo;
class GetFileUploadInfoRequestOptionPreCheckParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            md5: 'md5',
            name: 'name',
            parentId: 'parentId',
            size: 'size',
        };
    }
    static types() {
        return {
            md5: 'string',
            name: 'string',
            parentId: 'string',
            size: 'number',
        };
    }
}
exports.GetFileUploadInfoRequestOptionPreCheckParam = GetFileUploadInfoRequestOptionPreCheckParam;
class GetFileUploadInfoRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            preCheckParam: 'preCheckParam',
            preferIntranet: 'preferIntranet',
            preferRegion: 'preferRegion',
            storageDriver: 'storageDriver',
        };
    }
    static types() {
        return {
            preCheckParam: GetFileUploadInfoRequestOptionPreCheckParam,
            preferIntranet: 'boolean',
            preferRegion: 'string',
            storageDriver: 'string',
        };
    }
}
exports.GetFileUploadInfoRequestOption = GetFileUploadInfoRequestOption;
class GetFileUploadInfoResponseBodyHeaderSignatureInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationSeconds: 'expirationSeconds',
            headers: 'headers',
            internalResourceUrls: 'internalResourceUrls',
            region: 'region',
            resourceUrls: 'resourceUrls',
        };
    }
    static types() {
        return {
            expirationSeconds: 'number',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            internalResourceUrls: { 'type': 'array', 'itemType': 'string' },
            region: 'string',
            resourceUrls: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetFileUploadInfoResponseBodyHeaderSignatureInfo = GetFileUploadInfoResponseBodyHeaderSignatureInfo;
class GetMultipartFileUploadInfosRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            preferIntranet: 'preferIntranet',
        };
    }
    static types() {
        return {
            preferIntranet: 'boolean',
        };
    }
}
exports.GetMultipartFileUploadInfosRequestOption = GetMultipartFileUploadInfosRequestOption;
class GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            expirationSeconds: 'expirationSeconds',
            headers: 'headers',
            internalResourceUrls: 'internalResourceUrls',
            region: 'region',
            resourceUrls: 'resourceUrls',
        };
    }
    static types() {
        return {
            expirationSeconds: 'number',
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            internalResourceUrls: { 'type': 'array', 'itemType': 'string' },
            region: 'string',
            resourceUrls: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo = GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo;
class GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headerSignatureInfo: 'headerSignatureInfo',
            partNumber: 'partNumber',
        };
    }
    static types() {
        return {
            headerSignatureInfo: GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfosHeaderSignatureInfo,
            partNumber: 'number',
        };
    }
}
exports.GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos = GetMultipartFileUploadInfosResponseBodyMultipartHeaderSignatureInfos;
class GetOrgResponseBodyOrgPartitionsQuota extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            max: 'max',
            reserved: 'reserved',
            type: 'type',
            used: 'used',
        };
    }
    static types() {
        return {
            max: 'number',
            reserved: 'number',
            type: 'string',
            used: 'number',
        };
    }
}
exports.GetOrgResponseBodyOrgPartitionsQuota = GetOrgResponseBodyOrgPartitionsQuota;
class GetOrgResponseBodyOrgPartitions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partitionType: 'partitionType',
            quota: 'quota',
        };
    }
    static types() {
        return {
            partitionType: 'string',
            quota: GetOrgResponseBodyOrgPartitionsQuota,
        };
    }
}
exports.GetOrgResponseBodyOrgPartitions = GetOrgResponseBodyOrgPartitions;
class GetOrgResponseBodyOrg extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            partitions: 'partitions',
        };
    }
    static types() {
        return {
            corpId: 'string',
            partitions: { 'type': 'array', 'itemType': GetOrgResponseBodyOrgPartitions },
        };
    }
}
exports.GetOrgResponseBodyOrg = GetOrgResponseBodyOrg;
class GetRecycleBinResponseBodyRecycleBin extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            scope: 'scope',
            scopeId: 'scopeId',
        };
    }
    static types() {
        return {
            id: 'string',
            scope: 'string',
            scopeId: 'string',
        };
    }
}
exports.GetRecycleBinResponseBodyRecycleBin = GetRecycleBinResponseBodyRecycleBin;
class GetRecycleItemResponseBodyItem extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryId: 'dentryId',
            id: 'id',
            operatorId: 'operatorId',
            operatorTime: 'operatorTime',
            originalName: 'originalName',
            originalPath: 'originalPath',
            size: 'size',
            spaceId: 'spaceId',
            type: 'type',
        };
    }
    static types() {
        return {
            dentryId: 'string',
            id: 'string',
            operatorId: 'string',
            operatorTime: 'string',
            originalName: 'string',
            originalPath: 'string',
            size: 'number',
            spaceId: 'string',
            type: 'string',
        };
    }
}
exports.GetRecycleItemResponseBodyItem = GetRecycleItemResponseBodyItem;
class GetSpaceResponseBodySpaceCapabilities extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            canRecordRecentFile: 'canRecordRecentFile',
            canRename: 'canRename',
            canSearch: 'canSearch',
        };
    }
    static types() {
        return {
            canRecordRecentFile: 'boolean',
            canRename: 'boolean',
            canSearch: 'boolean',
        };
    }
}
exports.GetSpaceResponseBodySpaceCapabilities = GetSpaceResponseBodySpaceCapabilities;
class GetSpaceResponseBodySpacePartitionsQuota extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            max: 'max',
            reserved: 'reserved',
            type: 'type',
            used: 'used',
        };
    }
    static types() {
        return {
            max: 'number',
            reserved: 'number',
            type: 'string',
            used: 'number',
        };
    }
}
exports.GetSpaceResponseBodySpacePartitionsQuota = GetSpaceResponseBodySpacePartitionsQuota;
class GetSpaceResponseBodySpacePartitions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            partitionType: 'partitionType',
            quota: 'quota',
        };
    }
    static types() {
        return {
            partitionType: 'string',
            quota: GetSpaceResponseBodySpacePartitionsQuota,
        };
    }
}
exports.GetSpaceResponseBodySpacePartitions = GetSpaceResponseBodySpacePartitions;
class GetSpaceResponseBodySpace extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appId: 'appId',
            capabilities: 'capabilities',
            corpId: 'corpId',
            createTime: 'createTime',
            creatorId: 'creatorId',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            ownerId: 'ownerId',
            ownerType: 'ownerType',
            partitions: 'partitions',
            quota: 'quota',
            scene: 'scene',
            sceneId: 'sceneId',
            status: 'status',
            usedQuota: 'usedQuota',
        };
    }
    static types() {
        return {
            appId: 'string',
            capabilities: GetSpaceResponseBodySpaceCapabilities,
            corpId: 'string',
            createTime: 'string',
            creatorId: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            ownerId: 'string',
            ownerType: 'string',
            partitions: { 'type': 'array', 'itemType': GetSpaceResponseBodySpacePartitions },
            quota: 'number',
            scene: 'string',
            sceneId: 'string',
            status: 'string',
            usedQuota: 'number',
        };
    }
}
exports.GetSpaceResponseBodySpace = GetSpaceResponseBodySpace;
class GetTaskResponseBodyTask extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            beginTime: 'beginTime',
            endTime: 'endTime',
            failCount: 'failCount',
            failMessage: 'failMessage',
            id: 'id',
            status: 'status',
            successCount: 'successCount',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            beginTime: 'string',
            endTime: 'string',
            failCount: 'number',
            failMessage: 'string',
            id: 'string',
            status: 'string',
            successCount: 'number',
            totalCount: 'number',
        };
    }
}
exports.GetTaskResponseBodyTask = GetTaskResponseBodyTask;
class InitMultipartFileUploadRequestOptionPreCheckParam extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            md5: 'md5',
            name: 'name',
            parentId: 'parentId',
            size: 'size',
        };
    }
    static types() {
        return {
            md5: 'string',
            name: 'string',
            parentId: 'string',
            size: 'number',
        };
    }
}
exports.InitMultipartFileUploadRequestOptionPreCheckParam = InitMultipartFileUploadRequestOptionPreCheckParam;
class InitMultipartFileUploadRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            preCheckParam: 'preCheckParam',
            preferRegion: 'preferRegion',
            storageDriver: 'storageDriver',
        };
    }
    static types() {
        return {
            preCheckParam: InitMultipartFileUploadRequestOptionPreCheckParam,
            preferRegion: 'string',
            storageDriver: 'string',
        };
    }
}
exports.InitMultipartFileUploadRequestOption = InitMultipartFileUploadRequestOption;
class ListAllDentriesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            order: 'order',
            withThumbnail: 'withThumbnail',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            order: 'string',
            withThumbnail: 'boolean',
        };
    }
}
exports.ListAllDentriesRequestOption = ListAllDentriesRequestOption;
class ListAllDentriesResponseBodyDentriesProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.ListAllDentriesResponseBodyDentriesProperties = ListAllDentriesResponseBodyDentriesProperties;
class ListAllDentriesResponseBodyDentriesThumbnail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'height',
            url: 'url',
            width: 'width',
        };
    }
    static types() {
        return {
            height: 'number',
            url: 'string',
            width: 'number',
        };
    }
}
exports.ListAllDentriesResponseBodyDentriesThumbnail = ListAllDentriesResponseBodyDentriesThumbnail;
class ListAllDentriesResponseBodyDentries extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            thumbnail: 'thumbnail',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentriesAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: ListAllDentriesResponseBodyDentriesProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            thumbnail: ListAllDentriesResponseBodyDentriesThumbnail,
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.ListAllDentriesResponseBodyDentries = ListAllDentriesResponseBodyDentries;
class ListDentriesResponseBodyDentriesProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.ListDentriesResponseBodyDentriesProperties = ListDentriesResponseBodyDentriesProperties;
class ListDentriesResponseBodyDentriesThumbnail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            height: 'height',
            url: 'url',
            width: 'width',
        };
    }
    static types() {
        return {
            height: 'number',
            url: 'string',
            width: 'number',
        };
    }
}
exports.ListDentriesResponseBodyDentriesThumbnail = ListDentriesResponseBodyDentriesThumbnail;
class ListDentriesResponseBodyDentries extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            thumbnail: 'thumbnail',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentriesAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: ListDentriesResponseBodyDentriesProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            thumbnail: ListDentriesResponseBodyDentriesThumbnail,
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.ListDentriesResponseBodyDentries = ListDentriesResponseBodyDentries;
class ListDentryVersionsResponseBodyDentriesProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.ListDentryVersionsResponseBodyDentriesProperties = ListDentryVersionsResponseBodyDentriesProperties;
class ListDentryVersionsResponseBodyDentries extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentriesAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: ListDentryVersionsResponseBodyDentriesProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.ListDentryVersionsResponseBodyDentries = ListDentryVersionsResponseBodyDentries;
class ListPermissionsRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            filterRoleIds: 'filterRoleIds',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            filterRoleIds: { 'type': 'array', 'itemType': 'string' },
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.ListPermissionsRequestOption = ListPermissionsRequestOption;
class ListPermissionsResponseBodyPermissionsMember extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            id: 'id',
            type: 'type',
        };
    }
    static types() {
        return {
            corpId: 'string',
            id: 'string',
            type: 'string',
        };
    }
}
exports.ListPermissionsResponseBodyPermissionsMember = ListPermissionsResponseBodyPermissionsMember;
class ListPermissionsResponseBodyPermissionsRole extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.ListPermissionsResponseBodyPermissionsRole = ListPermissionsResponseBodyPermissionsRole;
class ListPermissionsResponseBodyPermissions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            dentryId: 'dentryId',
            duration: 'duration',
            member: 'member',
            modifiedTime: 'modifiedTime',
            operatorId: 'operatorId',
            role: 'role',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            createTime: 'string',
            dentryId: 'string',
            duration: 'number',
            member: ListPermissionsResponseBodyPermissionsMember,
            modifiedTime: 'string',
            operatorId: 'string',
            role: ListPermissionsResponseBodyPermissionsRole,
            spaceId: 'string',
        };
    }
}
exports.ListPermissionsResponseBodyPermissions = ListPermissionsResponseBodyPermissions;
class ListRecycleItemsResponseBodyRecycleItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dentryId: 'dentryId',
            id: 'id',
            operatorId: 'operatorId',
            operatorTime: 'operatorTime',
            originalName: 'originalName',
            originalPath: 'originalPath',
            size: 'size',
            spaceId: 'spaceId',
            type: 'type',
        };
    }
    static types() {
        return {
            dentryId: 'string',
            id: 'string',
            operatorId: 'string',
            operatorTime: 'string',
            originalName: 'string',
            originalPath: 'string',
            size: 'number',
            spaceId: 'string',
            type: 'string',
        };
    }
}
exports.ListRecycleItemsResponseBodyRecycleItems = ListRecycleItemsResponseBodyRecycleItems;
class MoveDentriesRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
            preservePermissions: 'preservePermissions',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
            preservePermissions: 'boolean',
        };
    }
}
exports.MoveDentriesRequestOption = MoveDentriesRequestOption;
class MoveDentriesResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentryId: 'dentryId',
            errorCode: 'errorCode',
            spaceId: 'spaceId',
            success: 'success',
            targetDentryId: 'targetDentryId',
            targetSpaceId: 'targetSpaceId',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentryId: 'string',
            errorCode: 'string',
            spaceId: 'string',
            success: 'boolean',
            targetDentryId: 'string',
            targetSpaceId: 'string',
            taskId: 'string',
        };
    }
}
exports.MoveDentriesResponseBodyResultItems = MoveDentriesResponseBodyResultItems;
class MoveDentryRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
            presevePermissions: 'presevePermissions',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
            presevePermissions: 'boolean',
        };
    }
}
exports.MoveDentryRequestOption = MoveDentryRequestOption;
class MoveDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.MoveDentryResponseBodyDentryProperties = MoveDentryResponseBodyDentryProperties;
class MoveDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: MoveDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.MoveDentryResponseBodyDentry = MoveDentryResponseBodyDentry;
class RegisterOpenInfoRequestOpenInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openType: 'openType',
            url: 'url',
        };
    }
    static types() {
        return {
            openType: 'string',
            url: 'string',
        };
    }
}
exports.RegisterOpenInfoRequestOpenInfos = RegisterOpenInfoRequestOpenInfos;
class RenameDentryResponseBodyDentryProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readOnly: 'readOnly',
        };
    }
    static types() {
        return {
            readOnly: 'boolean',
        };
    }
}
exports.RenameDentryResponseBodyDentryProperties = RenameDentryResponseBodyDentryProperties;
class RenameDentryResponseBodyDentry extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appProperties: 'appProperties',
            createTime: 'createTime',
            creatorId: 'creatorId',
            extension: 'extension',
            id: 'id',
            modifiedTime: 'modifiedTime',
            modifierId: 'modifierId',
            name: 'name',
            parentId: 'parentId',
            partitionType: 'partitionType',
            path: 'path',
            properties: 'properties',
            size: 'size',
            spaceId: 'spaceId',
            status: 'status',
            storageDriver: 'storageDriver',
            type: 'type',
            uuid: 'uuid',
            version: 'version',
        };
    }
    static types() {
        return {
            appProperties: { 'type': 'map', 'keyType': 'string', 'valueType': { 'type': 'array', 'itemType': DentryAppPropertiesValue } },
            createTime: 'string',
            creatorId: 'string',
            extension: 'string',
            id: 'string',
            modifiedTime: 'string',
            modifierId: 'string',
            name: 'string',
            parentId: 'string',
            partitionType: 'string',
            path: 'string',
            properties: RenameDentryResponseBodyDentryProperties,
            size: 'number',
            spaceId: 'string',
            status: 'string',
            storageDriver: 'string',
            type: 'string',
            uuid: 'string',
            version: 'number',
        };
    }
}
exports.RenameDentryResponseBodyDentry = RenameDentryResponseBodyDentry;
class RestoreRecycleItemRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
        };
    }
}
exports.RestoreRecycleItemRequestOption = RestoreRecycleItemRequestOption;
class RestoreRecycleItemsRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conflictStrategy: 'conflictStrategy',
        };
    }
    static types() {
        return {
            conflictStrategy: 'string',
        };
    }
}
exports.RestoreRecycleItemsRequestOption = RestoreRecycleItemsRequestOption;
class RestoreRecycleItemsResponseBodyResultItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            async: 'async',
            dentryId: 'dentryId',
            errorCode: 'errorCode',
            recycleBinId: 'recycleBinId',
            recycleItemId: 'recycleItemId',
            spaceId: 'spaceId',
            success: 'success',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            async: 'boolean',
            dentryId: 'string',
            errorCode: 'string',
            recycleBinId: 'string',
            recycleItemId: 'string',
            spaceId: 'string',
            success: 'boolean',
            taskId: 'string',
        };
    }
}
exports.RestoreRecycleItemsResponseBodyResultItems = RestoreRecycleItemsResponseBodyResultItems;
class UpdateDentryAppPropertiesRequestAppProperties extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            value: 'value',
            visibility: 'visibility',
        };
    }
    static types() {
        return {
            name: 'string',
            value: 'string',
            visibility: 'string',
        };
    }
}
exports.UpdateDentryAppPropertiesRequestAppProperties = UpdateDentryAppPropertiesRequestAppProperties;
class UpdatePermissionRequestMembers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            id: 'id',
            type: 'type',
        };
    }
    static types() {
        return {
            corpId: 'string',
            id: 'string',
            type: 'string',
        };
    }
}
exports.UpdatePermissionRequestMembers = UpdatePermissionRequestMembers;
class UpdatePermissionRequestOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
        };
    }
    static types() {
        return {
            duration: 'number',
        };
    }
}
exports.UpdatePermissionRequestOption = UpdatePermissionRequestOption;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addFolderWithOptions(spaceId, parentId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddFolder",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${parentId}/folders`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddFolderResponse({}));
    }
    async addFolder(spaceId, parentId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddFolderHeaders({});
        return await this.addFolderWithOptions(spaceId, parentId, request, headers, runtime);
    }
    async addPermissionWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.roleId)) {
            body["roleId"] = request.roleId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddPermission",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/permissions`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddPermissionResponse({}));
    }
    async addPermission(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddPermissionHeaders({});
        return await this.addPermissionWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async addSpaceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddSpace",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddSpaceResponse({}));
    }
    async addSpace(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddSpaceHeaders({});
        return await this.addSpaceWithOptions(request, headers, runtime);
    }
    async clearRecycleBinWithOptions(recycleBinId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ClearRecycleBin",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins/${recycleBinId}/clear`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ClearRecycleBinResponse({}));
    }
    async clearRecycleBin(recycleBinId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ClearRecycleBinHeaders({});
        return await this.clearRecycleBinWithOptions(recycleBinId, request, headers, runtime);
    }
    async commitFileWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.parentId)) {
            body["parentId"] = request.parentId;
        }
        if (!tea_util_1.default.isUnset(request.uploadKey)) {
            body["uploadKey"] = request.uploadKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CommitFile",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/files/commit`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CommitFileResponse({}));
    }
    async commitFile(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CommitFileHeaders({});
        return await this.commitFileWithOptions(spaceId, request, headers, runtime);
    }
    async copyDentriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryIds)) {
            body["dentryIds"] = request.dentryIds;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.targetFolderId)) {
            body["targetFolderId"] = request.targetFolderId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CopyDentries",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/batchCopy`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CopyDentriesResponse({}));
    }
    async copyDentries(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CopyDentriesHeaders({});
        return await this.copyDentriesWithOptions(spaceId, request, headers, runtime);
    }
    async copyDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.targetFolderId)) {
            body["targetFolderId"] = request.targetFolderId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CopyDentry",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/copy`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CopyDentryResponse({}));
    }
    async copyDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CopyDentryHeaders({});
        return await this.copyDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async deleteDentriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryIds)) {
            body["dentryIds"] = request.dentryIds;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDentries",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/batchRemove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteDentriesResponse({}));
    }
    async deleteDentries(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteDentriesHeaders({});
        return await this.deleteDentriesWithOptions(spaceId, request, headers, runtime);
    }
    async deleteDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.toRecycleBin)) {
            query["toRecycleBin"] = request.toRecycleBin;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDentry",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteDentryResponse({}));
    }
    async deleteDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteDentryHeaders({});
        return await this.deleteDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async deleteDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.propertyNames)) {
            body["propertyNames"] = request.propertyNames;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteDentryAppProperties",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/appProperties/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteDentryAppPropertiesResponse({}));
    }
    async deleteDentryAppProperties(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteDentryAppPropertiesHeaders({});
        return await this.deleteDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async deletePermissionWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.roleId)) {
            body["roleId"] = request.roleId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeletePermission",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/permissions/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeletePermissionResponse({}));
    }
    async deletePermission(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeletePermissionHeaders({});
        return await this.deletePermissionWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async deleteRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteRecycleItem",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/${recycleItemId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteRecycleItemResponse({}));
    }
    async deleteRecycleItem(recycleBinId, recycleItemId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRecycleItemHeaders({});
        return await this.deleteRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime);
    }
    async deleteRecycleItemsWithOptions(recycleBinId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.recycleItemIds)) {
            body["recycleItemIds"] = request.recycleItemIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteRecycleItems",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/batchRemove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteRecycleItemsResponse({}));
    }
    async deleteRecycleItems(recycleBinId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRecycleItemsHeaders({});
        return await this.deleteRecycleItemsWithOptions(recycleBinId, request, headers, runtime);
    }
    async getCurrentAppWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetCurrentApp",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/currentApps/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCurrentAppResponse({}));
    }
    async getCurrentApp(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCurrentAppHeaders({});
        return await this.getCurrentAppWithOptions(request, headers, runtime);
    }
    async getDentriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryIds)) {
            body["dentryIds"] = request.dentryIds;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetDentries",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDentriesResponse({}));
    }
    async getDentries(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDentriesHeaders({});
        return await this.getDentriesWithOptions(spaceId, request, headers, runtime);
    }
    async getDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetDentry",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDentryResponse({}));
    }
    async getDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDentryHeaders({});
        return await this.getDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async getDentryOpenInfoWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetDentryOpenInfo",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/openInfos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDentryOpenInfoResponse({}));
    }
    async getDentryOpenInfo(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDentryOpenInfoHeaders({});
        return await this.getDentryOpenInfoWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async getDentryThumbnailsWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryIds)) {
            body["dentryIds"] = request.dentryIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetDentryThumbnails",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/thumbnails/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetDentryThumbnailsResponse({}));
    }
    async getDentryThumbnails(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetDentryThumbnailsHeaders({});
        return await this.getDentryThumbnailsWithOptions(spaceId, request, headers, runtime);
    }
    async getFileDownloadInfoWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetFileDownloadInfo",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/downloadInfos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFileDownloadInfoResponse({}));
    }
    async getFileDownloadInfo(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileDownloadInfoHeaders({});
        return await this.getFileDownloadInfoWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async getFileUploadInfoWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.multipart)) {
            body["multipart"] = request.multipart;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.protocol)) {
            body["protocol"] = request.protocol;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetFileUploadInfo",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/files/uploadInfos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFileUploadInfoResponse({}));
    }
    async getFileUploadInfo(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileUploadInfoHeaders({});
        return await this.getFileUploadInfoWithOptions(spaceId, request, headers, runtime);
    }
    async getMultipartFileUploadInfosWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.partNumbers)) {
            body["partNumbers"] = request.partNumbers;
        }
        if (!tea_util_1.default.isUnset(request.uploadKey)) {
            body["uploadKey"] = request.uploadKey;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetMultipartFileUploadInfos",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/files/multiPartUploadInfos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetMultipartFileUploadInfosResponse({}));
    }
    async getMultipartFileUploadInfos(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetMultipartFileUploadInfosHeaders({});
        return await this.getMultipartFileUploadInfosWithOptions(request, headers, runtime);
    }
    async getOrgWithOptions(corpId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetOrg",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/orgs/${corpId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetOrgResponse({}));
    }
    async getOrg(corpId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetOrgHeaders({});
        return await this.getOrgWithOptions(corpId, request, headers, runtime);
    }
    async getRecycleBinWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.recycleBinScope)) {
            query["recycleBinScope"] = request.recycleBinScope;
        }
        if (!tea_util_1.default.isUnset(request.scopeId)) {
            query["scopeId"] = request.scopeId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRecycleBin",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetRecycleBinResponse({}));
    }
    async getRecycleBin(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRecycleBinHeaders({});
        return await this.getRecycleBinWithOptions(request, headers, runtime);
    }
    async getRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRecycleItem",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/${recycleItemId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetRecycleItemResponse({}));
    }
    async getRecycleItem(recycleBinId, recycleItemId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRecycleItemHeaders({});
        return await this.getRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime);
    }
    async getSpaceWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetSpace",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSpaceResponse({}));
    }
    async getSpace(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSpaceHeaders({});
        return await this.getSpaceWithOptions(spaceId, request, headers, runtime);
    }
    async getTaskWithOptions(taskId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetTask",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/tasks/${taskId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetTaskResponse({}));
    }
    async getTask(taskId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetTaskHeaders({});
        return await this.getTaskWithOptions(taskId, request, headers, runtime);
    }
    async initMultipartFileUploadWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InitMultipartFileUpload",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/files/multiPartUploadInfos/init`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InitMultipartFileUploadResponse({}));
    }
    async initMultipartFileUpload(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InitMultipartFileUploadHeaders({});
        return await this.initMultipartFileUploadWithOptions(spaceId, request, headers, runtime);
    }
    async listAllDentriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListAllDentries",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/listAll`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListAllDentriesResponse({}));
    }
    async listAllDentries(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListAllDentriesHeaders({});
        return await this.listAllDentriesWithOptions(spaceId, request, headers, runtime);
    }
    async listDentriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.order)) {
            query["order"] = request.order;
        }
        if (!tea_util_1.default.isUnset(request.orderBy)) {
            query["orderBy"] = request.orderBy;
        }
        if (!tea_util_1.default.isUnset(request.parentId)) {
            query["parentId"] = request.parentId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        if (!tea_util_1.default.isUnset(request.withThumbnail)) {
            query["withThumbnail"] = request.withThumbnail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListDentries",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListDentriesResponse({}));
    }
    async listDentries(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListDentriesHeaders({});
        return await this.listDentriesWithOptions(spaceId, request, headers, runtime);
    }
    async listDentryVersionsWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListDentryVersions",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/versions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListDentryVersionsResponse({}));
    }
    async listDentryVersions(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListDentryVersionsHeaders({});
        return await this.listDentryVersionsWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async listPermissionsWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ListPermissions",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/permissions/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListPermissionsResponse({}));
    }
    async listPermissions(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListPermissionsHeaders({});
        return await this.listPermissionsWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async listRecycleItemsWithOptions(recycleBinId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListRecycleItems",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListRecycleItemsResponse({}));
    }
    async listRecycleItems(recycleBinId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListRecycleItemsHeaders({});
        return await this.listRecycleItemsWithOptions(recycleBinId, request, headers, runtime);
    }
    async moveDentriesWithOptions(spaceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.dentryIds)) {
            body["dentryIds"] = request.dentryIds;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.targetFolderId)) {
            body["targetFolderId"] = request.targetFolderId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MoveDentries",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/batchMove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MoveDentriesResponse({}));
    }
    async moveDentries(spaceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MoveDentriesHeaders({});
        return await this.moveDentriesWithOptions(spaceId, request, headers, runtime);
    }
    async moveDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.targetFolderId)) {
            body["targetFolderId"] = request.targetFolderId;
        }
        if (!tea_util_1.default.isUnset(request.targetSpaceId)) {
            body["targetSpaceId"] = request.targetSpaceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MoveDentry",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/move`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MoveDentryResponse({}));
    }
    async moveDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MoveDentryHeaders({});
        return await this.moveDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async registerOpenInfoWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.openInfos)) {
            body["openInfos"] = request.openInfos;
        }
        if (!tea_util_1.default.isUnset(request.provider)) {
            body["provider"] = request.provider;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RegisterOpenInfo",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/openInfos/register`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RegisterOpenInfoResponse({}));
    }
    async registerOpenInfo(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RegisterOpenInfoHeaders({});
        return await this.registerOpenInfoWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async renameDentryWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.newName)) {
            body["newName"] = request.newName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RenameDentry",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/rename`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RenameDentryResponse({}));
    }
    async renameDentry(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RenameDentryHeaders({});
        return await this.renameDentryWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async restoreRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RestoreRecycleItem",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/${recycleItemId}/restore`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RestoreRecycleItemResponse({}));
    }
    async restoreRecycleItem(recycleBinId, recycleItemId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RestoreRecycleItemHeaders({});
        return await this.restoreRecycleItemWithOptions(recycleBinId, recycleItemId, request, headers, runtime);
    }
    async restoreRecycleItemsWithOptions(recycleBinId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.recycleItemIds)) {
            body["recycleItemIds"] = request.recycleItemIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RestoreRecycleItems",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/recycleBins/${recycleBinId}/recycleItems/batchRestore`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RestoreRecycleItemsResponse({}));
    }
    async restoreRecycleItems(recycleBinId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RestoreRecycleItemsHeaders({});
        return await this.restoreRecycleItemsWithOptions(recycleBinId, request, headers, runtime);
    }
    async revertDentryVersionWithOptions(spaceId, dentryId, version, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RevertDentryVersion",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/versions/${version}/revert`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RevertDentryVersionResponse({}));
    }
    async revertDentryVersion(spaceId, dentryId, version, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RevertDentryVersionHeaders({});
        return await this.revertDentryVersionWithOptions(spaceId, dentryId, version, request, headers, runtime);
    }
    async subscribeEventWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.scope)) {
            body["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.scopeId)) {
            body["scopeId"] = request.scopeId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SubscribeEvent",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/events/subscribe`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SubscribeEventResponse({}));
    }
    async subscribeEvent(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SubscribeEventHeaders({});
        return await this.subscribeEventWithOptions(request, headers, runtime);
    }
    async unsubscribeEventWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.scope)) {
            body["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.scopeId)) {
            body["scopeId"] = request.scopeId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UnsubscribeEvent",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/events/unsubscribe`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UnsubscribeEventResponse({}));
    }
    async unsubscribeEvent(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UnsubscribeEventHeaders({});
        return await this.unsubscribeEventWithOptions(request, headers, runtime);
    }
    async updateDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.appProperties)) {
            body["appProperties"] = request.appProperties;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateDentryAppProperties",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/appProperties`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateDentryAppPropertiesResponse({}));
    }
    async updateDentryAppProperties(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateDentryAppPropertiesHeaders({});
        return await this.updateDentryAppPropertiesWithOptions(spaceId, dentryId, request, headers, runtime);
    }
    async updatePermissionWithOptions(spaceId, dentryId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.members)) {
            body["members"] = request.members;
        }
        if (!tea_util_1.default.isUnset(request.option)) {
            body["option"] = request.option;
        }
        if (!tea_util_1.default.isUnset(request.roleId)) {
            body["roleId"] = request.roleId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdatePermission",
            version: "storage_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/storage/spaces/${spaceId}/dentries/${dentryId}/permissions`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdatePermissionResponse({}));
    }
    async updatePermission(spaceId, dentryId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdatePermissionHeaders({});
        return await this.updatePermissionWithOptions(spaceId, dentryId, request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map