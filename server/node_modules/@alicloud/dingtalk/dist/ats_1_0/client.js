"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddApplicationRegFormTemplateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddApplicationRegFormTemplateHeaders = AddApplicationRegFormTemplateHeaders;
class AddApplicationRegFormTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            content: 'content',
            name: 'name',
            outerId: 'outerId',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            content: 'string',
            name: 'string',
            outerId: 'string',
            opUserId: 'string',
        };
    }
}
exports.AddApplicationRegFormTemplateRequest = AddApplicationRegFormTemplateRequest;
class AddApplicationRegFormTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            templateId: 'templateId',
            version: 'version',
        };
    }
    static types() {
        return {
            templateId: 'string',
            version: 'number',
        };
    }
}
exports.AddApplicationRegFormTemplateResponseBody = AddApplicationRegFormTemplateResponseBody;
class AddApplicationRegFormTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddApplicationRegFormTemplateResponseBody,
        };
    }
}
exports.AddApplicationRegFormTemplateResponse = AddApplicationRegFormTemplateResponse;
class AddFileHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddFileHeaders = AddFileHeaders;
class AddFileRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            fileName: 'fileName',
            mediaId: 'mediaId',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            fileName: 'string',
            mediaId: 'string',
            opUserId: 'string',
        };
    }
}
exports.AddFileRequest = AddFileRequest;
class AddFileResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            fileName: 'fileName',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            fileId: 'string',
            fileName: 'string',
            spaceId: 'number',
        };
    }
}
exports.AddFileResponseBody = AddFileResponseBody;
class AddFileResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddFileResponseBody,
        };
    }
}
exports.AddFileResponse = AddFileResponse;
class AddUserAccountHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddUserAccountHeaders = AddUserAccountHeaders;
class AddUserAccountRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            channelAccountName: 'channelAccountName',
            channelUserIdentify: 'channelUserIdentify',
            phoneNumber: 'phoneNumber',
            corpId: 'corpId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            channelAccountName: 'string',
            channelUserIdentify: 'string',
            phoneNumber: 'string',
            corpId: 'string',
            userId: 'string',
        };
    }
}
exports.AddUserAccountRequest = AddUserAccountRequest;
class AddUserAccountResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.AddUserAccountResponseBody = AddUserAccountResponseBody;
class AddUserAccountResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddUserAccountResponseBody,
        };
    }
}
exports.AddUserAccountResponse = AddUserAccountResponse;
class CollectRecruitJobDetailHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CollectRecruitJobDetailHeaders = CollectRecruitJobDetailHeaders;
class CollectRecruitJobDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            channel: 'channel',
            jobInfo: 'jobInfo',
            outCorpId: 'outCorpId',
            outCorpName: 'outCorpName',
            recruitUserInfo: 'recruitUserInfo',
            source: 'source',
            updateTime: 'updateTime',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            channel: 'string',
            jobInfo: CollectRecruitJobDetailRequestJobInfo,
            outCorpId: 'string',
            outCorpName: 'string',
            recruitUserInfo: CollectRecruitJobDetailRequestRecruitUserInfo,
            source: 'string',
            updateTime: 'number',
        };
    }
}
exports.CollectRecruitJobDetailRequest = CollectRecruitJobDetailRequest;
class CollectRecruitJobDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.CollectRecruitJobDetailResponseBody = CollectRecruitJobDetailResponseBody;
class CollectRecruitJobDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CollectRecruitJobDetailResponseBody,
        };
    }
}
exports.CollectRecruitJobDetailResponse = CollectRecruitJobDetailResponse;
class CollectResumeDetailHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CollectResumeDetailHeaders = CollectResumeDetailHeaders;
class CollectResumeDetailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            channelCode: 'channelCode',
            channelOuterId: 'channelOuterId',
            channelTalentId: 'channelTalentId',
            deliverJobId: 'deliverJobId',
            optUserId: 'optUserId',
            resumeChannelUrl: 'resumeChannelUrl',
            resumeData: 'resumeData',
            resumeFile: 'resumeFile',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            channelCode: 'string',
            channelOuterId: 'string',
            channelTalentId: 'string',
            deliverJobId: 'string',
            optUserId: 'string',
            resumeChannelUrl: 'string',
            resumeData: CollectResumeDetailRequestResumeData,
            resumeFile: CollectResumeDetailRequestResumeFile,
        };
    }
}
exports.CollectResumeDetailRequest = CollectResumeDetailRequest;
class CollectResumeDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resumeId: 'resumeId',
        };
    }
    static types() {
        return {
            resumeId: 'string',
        };
    }
}
exports.CollectResumeDetailResponseBody = CollectResumeDetailResponseBody;
class CollectResumeDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CollectResumeDetailResponseBody,
        };
    }
}
exports.CollectResumeDetailResponse = CollectResumeDetailResponse;
class CollectResumeMailHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CollectResumeMailHeaders = CollectResumeMailHeaders;
class CollectResumeMailRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            channelCode: 'channelCode',
            deliverJobId: 'deliverJobId',
            fromMailAddress: 'fromMailAddress',
            historyMailImport: 'historyMailImport',
            mailId: 'mailId',
            mailTitle: 'mailTitle',
            optUserId: 'optUserId',
            receiveMailAddress: 'receiveMailAddress',
            receiveMailType: 'receiveMailType',
            receivedTime: 'receivedTime',
            resumeChannelUrl: 'resumeChannelUrl',
            resumeFile: 'resumeFile',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            channelCode: 'string',
            deliverJobId: 'string',
            fromMailAddress: 'string',
            historyMailImport: 'boolean',
            mailId: 'string',
            mailTitle: 'string',
            optUserId: 'string',
            receiveMailAddress: 'string',
            receiveMailType: 'number',
            receivedTime: 'number',
            resumeChannelUrl: 'string',
            resumeFile: CollectResumeMailRequestResumeFile,
        };
    }
}
exports.CollectResumeMailRequest = CollectResumeMailRequest;
class CollectResumeMailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            resumeId: 'resumeId',
        };
    }
    static types() {
        return {
            resumeId: 'string',
        };
    }
}
exports.CollectResumeMailResponseBody = CollectResumeMailResponseBody;
class CollectResumeMailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CollectResumeMailResponseBody,
        };
    }
}
exports.CollectResumeMailResponse = CollectResumeMailResponse;
class ConfirmRightsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ConfirmRightsHeaders = ConfirmRightsHeaders;
class ConfirmRightsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
        };
    }
    static types() {
        return {
            bizCode: 'string',
        };
    }
}
exports.ConfirmRightsRequest = ConfirmRightsRequest;
class ConfirmRightsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.ConfirmRightsResponseBody = ConfirmRightsResponseBody;
class ConfirmRightsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ConfirmRightsResponseBody,
        };
    }
}
exports.ConfirmRightsResponse = ConfirmRightsResponse;
class FinishBeginnerTaskHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.FinishBeginnerTaskHeaders = FinishBeginnerTaskHeaders;
class FinishBeginnerTaskRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scope: 'scope',
            userId: 'userId',
        };
    }
    static types() {
        return {
            scope: 'string',
            userId: 'string',
        };
    }
}
exports.FinishBeginnerTaskRequest = FinishBeginnerTaskRequest;
class FinishBeginnerTaskResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.FinishBeginnerTaskResponseBody = FinishBeginnerTaskResponseBody;
class FinishBeginnerTaskResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: FinishBeginnerTaskResponseBody,
        };
    }
}
exports.FinishBeginnerTaskResponse = FinishBeginnerTaskResponse;
class GetApplicationRegFormByFlowIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetApplicationRegFormByFlowIdHeaders = GetApplicationRegFormByFlowIdHeaders;
class GetApplicationRegFormByFlowIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
        };
    }
    static types() {
        return {
            bizCode: 'string',
        };
    }
}
exports.GetApplicationRegFormByFlowIdRequest = GetApplicationRegFormByFlowIdRequest;
class GetApplicationRegFormByFlowIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            candidateId: 'candidateId',
            creatorUserId: 'creatorUserId',
            flowId: 'flowId',
            formId: 'formId',
            gmtCreateMillis: 'gmtCreateMillis',
            gmtModifiedMillis: 'gmtModifiedMillis',
            jobId: 'jobId',
            status: 'status',
            templateId: 'templateId',
            templateVersion: 'templateVersion',
        };
    }
    static types() {
        return {
            candidateId: 'string',
            creatorUserId: 'string',
            flowId: 'string',
            formId: 'string',
            gmtCreateMillis: 'number',
            gmtModifiedMillis: 'number',
            jobId: 'string',
            status: 'number',
            templateId: 'string',
            templateVersion: 'number',
        };
    }
}
exports.GetApplicationRegFormByFlowIdResponseBody = GetApplicationRegFormByFlowIdResponseBody;
class GetApplicationRegFormByFlowIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetApplicationRegFormByFlowIdResponseBody,
        };
    }
}
exports.GetApplicationRegFormByFlowIdResponse = GetApplicationRegFormByFlowIdResponse;
class GetCandidateByPhoneNumberHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCandidateByPhoneNumberHeaders = GetCandidateByPhoneNumberHeaders;
class GetCandidateByPhoneNumberRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            phoneNumber: 'phoneNumber',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            phoneNumber: 'string',
        };
    }
}
exports.GetCandidateByPhoneNumberRequest = GetCandidateByPhoneNumberRequest;
class GetCandidateByPhoneNumberResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            candidateId: 'candidateId',
            name: 'name',
        };
    }
    static types() {
        return {
            candidateId: 'string',
            name: 'string',
        };
    }
}
exports.GetCandidateByPhoneNumberResponseBody = GetCandidateByPhoneNumberResponseBody;
class GetCandidateByPhoneNumberResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCandidateByPhoneNumberResponseBody,
        };
    }
}
exports.GetCandidateByPhoneNumberResponse = GetCandidateByPhoneNumberResponse;
class GetFileUploadInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileUploadInfoHeaders = GetFileUploadInfoHeaders;
class GetFileUploadInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            fileName: 'fileName',
            fileSize: 'fileSize',
            md5: 'md5',
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            fileName: 'string',
            fileSize: 'number',
            md5: 'string',
            opUserId: 'string',
        };
    }
}
exports.GetFileUploadInfoRequest = GetFileUploadInfoRequest;
class GetFileUploadInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accessKeyId: 'accessKeyId',
            accessKeySecret: 'accessKeySecret',
            accessToken: 'accessToken',
            accessTokenExpirationMillis: 'accessTokenExpirationMillis',
            bucket: 'bucket',
            endPoint: 'endPoint',
            mediaId: 'mediaId',
        };
    }
    static types() {
        return {
            accessKeyId: 'string',
            accessKeySecret: 'string',
            accessToken: 'string',
            accessTokenExpirationMillis: 'number',
            bucket: 'string',
            endPoint: 'string',
            mediaId: 'string',
        };
    }
}
exports.GetFileUploadInfoResponseBody = GetFileUploadInfoResponseBody;
class GetFileUploadInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFileUploadInfoResponseBody,
        };
    }
}
exports.GetFileUploadInfoResponse = GetFileUploadInfoResponse;
class GetFlowIdByRelationEntityIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFlowIdByRelationEntityIdHeaders = GetFlowIdByRelationEntityIdHeaders;
class GetFlowIdByRelationEntityIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            relationEntity: 'relationEntity',
            relationEntityId: 'relationEntityId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            relationEntity: 'string',
            relationEntityId: 'string',
        };
    }
}
exports.GetFlowIdByRelationEntityIdRequest = GetFlowIdByRelationEntityIdRequest;
class GetFlowIdByRelationEntityIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            flowId: 'flowId',
        };
    }
    static types() {
        return {
            flowId: 'string',
        };
    }
}
exports.GetFlowIdByRelationEntityIdResponseBody = GetFlowIdByRelationEntityIdResponseBody;
class GetFlowIdByRelationEntityIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFlowIdByRelationEntityIdResponseBody,
        };
    }
}
exports.GetFlowIdByRelationEntityIdResponse = GetFlowIdByRelationEntityIdResponse;
class GetJobAuthHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetJobAuthHeaders = GetJobAuthHeaders;
class GetJobAuthRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            opUserId: 'opUserId',
        };
    }
    static types() {
        return {
            opUserId: 'string',
        };
    }
}
exports.GetJobAuthRequest = GetJobAuthRequest;
class GetJobAuthResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'jobId',
            jobOwners: 'jobOwners',
        };
    }
    static types() {
        return {
            jobId: 'string',
            jobOwners: { 'type': 'array', 'itemType': GetJobAuthResponseBodyJobOwners },
        };
    }
}
exports.GetJobAuthResponseBody = GetJobAuthResponseBody;
class GetJobAuthResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetJobAuthResponseBody,
        };
    }
}
exports.GetJobAuthResponse = GetJobAuthResponse;
class QueryInterviewsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryInterviewsHeaders = QueryInterviewsHeaders;
class QueryInterviewsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            candidateId: 'candidateId',
            startTimeBeginMillis: 'startTimeBeginMillis',
            startTimeEndMillis: 'startTimeEndMillis',
            nextToken: 'nextToken',
            size: 'size',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            candidateId: 'string',
            startTimeBeginMillis: 'number',
            startTimeEndMillis: 'number',
            nextToken: 'string',
            size: 'number',
        };
    }
}
exports.QueryInterviewsRequest = QueryInterviewsRequest;
class QueryInterviewsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryInterviewsResponseBodyList },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.QueryInterviewsResponseBody = QueryInterviewsResponseBody;
class QueryInterviewsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryInterviewsResponseBody,
        };
    }
}
exports.QueryInterviewsResponse = QueryInterviewsResponse;
class ReportMessageStatusHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ReportMessageStatusHeaders = ReportMessageStatusHeaders;
class ReportMessageStatusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            channel: 'channel',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            messageId: 'messageId',
            receiverUserId: 'receiverUserId',
            senderUserId: 'senderUserId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            channel: 'string',
            errorCode: 'string',
            errorMsg: 'string',
            messageId: 'string',
            receiverUserId: 'string',
            senderUserId: 'string',
        };
    }
}
exports.ReportMessageStatusRequest = ReportMessageStatusRequest;
class ReportMessageStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.ReportMessageStatusResponseBody = ReportMessageStatusResponseBody;
class ReportMessageStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ReportMessageStatusResponseBody,
        };
    }
}
exports.ReportMessageStatusResponse = ReportMessageStatusResponse;
class SyncChannelMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SyncChannelMessageHeaders = SyncChannelMessageHeaders;
class SyncChannelMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            channel: 'channel',
            content: 'content',
            createTime: 'createTime',
            receiverUserId: 'receiverUserId',
            senderUserId: 'senderUserId',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            channel: 'string',
            content: 'string',
            createTime: 'number',
            receiverUserId: 'string',
            senderUserId: 'string',
            uuid: 'string',
        };
    }
}
exports.SyncChannelMessageRequest = SyncChannelMessageRequest;
class SyncChannelMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.SyncChannelMessageResponseBody = SyncChannelMessageResponseBody;
class SyncChannelMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SyncChannelMessageResponseBody,
        };
    }
}
exports.SyncChannelMessageResponse = SyncChannelMessageResponse;
class UpdateApplicationRegFormHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateApplicationRegFormHeaders = UpdateApplicationRegFormHeaders;
class UpdateApplicationRegFormRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            content: 'content',
            dingPanFile: 'dingPanFile',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            content: 'string',
            dingPanFile: UpdateApplicationRegFormRequestDingPanFile,
        };
    }
}
exports.UpdateApplicationRegFormRequest = UpdateApplicationRegFormRequest;
class UpdateApplicationRegFormResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorUserId: 'creatorUserId',
            formId: 'formId',
            gmtCreateMillis: 'gmtCreateMillis',
            gmtModifiedMillis: 'gmtModifiedMillis',
            status: 'status',
            templateId: 'templateId',
            templateVersion: 'templateVersion',
        };
    }
    static types() {
        return {
            creatorUserId: 'string',
            formId: 'string',
            gmtCreateMillis: 'number',
            gmtModifiedMillis: 'number',
            status: 'number',
            templateId: 'string',
            templateVersion: 'number',
        };
    }
}
exports.UpdateApplicationRegFormResponseBody = UpdateApplicationRegFormResponseBody;
class UpdateApplicationRegFormResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateApplicationRegFormResponseBody,
        };
    }
}
exports.UpdateApplicationRegFormResponse = UpdateApplicationRegFormResponse;
class UpdateInterviewSignInInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateInterviewSignInInfoHeaders = UpdateInterviewSignInInfoHeaders;
class UpdateInterviewSignInInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            signInTimeMillis: 'signInTimeMillis',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            signInTimeMillis: 'number',
        };
    }
}
exports.UpdateInterviewSignInInfoRequest = UpdateInterviewSignInInfoRequest;
class UpdateInterviewSignInInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
        };
    }
}
exports.UpdateInterviewSignInInfoResponse = UpdateInterviewSignInInfoResponse;
class UpdateJobDeliverHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateJobDeliverHeaders = UpdateJobDeliverHeaders;
class UpdateJobDeliverRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizCode: 'bizCode',
            channelOuterId: 'channelOuterId',
            deliverUserId: 'deliverUserId',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            opTime: 'opTime',
            opUserId: 'opUserId',
            status: 'status',
            jobId: 'jobId',
        };
    }
    static types() {
        return {
            bizCode: 'string',
            channelOuterId: 'string',
            deliverUserId: 'string',
            errorCode: 'string',
            errorMsg: 'string',
            opTime: 'number',
            opUserId: 'string',
            status: 'number',
            jobId: 'string',
        };
    }
}
exports.UpdateJobDeliverRequest = UpdateJobDeliverRequest;
class UpdateJobDeliverResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdateJobDeliverResponseBody = UpdateJobDeliverResponseBody;
class UpdateJobDeliverResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateJobDeliverResponseBody,
        };
    }
}
exports.UpdateJobDeliverResponse = UpdateJobDeliverResponse;
class CollectRecruitJobDetailRequestJobInfoAddress extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cityCode: 'cityCode',
            detail: 'detail',
            districtCode: 'districtCode',
            latitude: 'latitude',
            longitude: 'longitude',
            name: 'name',
            provinceCode: 'provinceCode',
        };
    }
    static types() {
        return {
            cityCode: 'string',
            detail: 'string',
            districtCode: 'string',
            latitude: 'string',
            longitude: 'string',
            name: 'string',
            provinceCode: 'string',
        };
    }
}
exports.CollectRecruitJobDetailRequestJobInfoAddress = CollectRecruitJobDetailRequestJobInfoAddress;
class CollectRecruitJobDetailRequestJobInfoFullTimeInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxJobExperience: 'maxJobExperience',
            minJobExperience: 'minJobExperience',
            salaryMonth: 'salaryMonth',
        };
    }
    static types() {
        return {
            maxJobExperience: 'string',
            minJobExperience: 'string',
            salaryMonth: 'string',
        };
    }
}
exports.CollectRecruitJobDetailRequestJobInfoFullTimeInfo = CollectRecruitJobDetailRequestJobInfoFullTimeInfo;
class CollectRecruitJobDetailRequestJobInfoPartTimeInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contactNumber: 'contactNumber',
            salaryPeriod: 'salaryPeriod',
            settleType: 'settleType',
            specifyWorkDate: 'specifyWorkDate',
            specifyWorkTime: 'specifyWorkTime',
            workBeginTimeMin: 'workBeginTimeMin',
            workDateType: 'workDateType',
            workEndDate: 'workEndDate',
            workEndTimeMin: 'workEndTimeMin',
            workStartDate: 'workStartDate',
        };
    }
    static types() {
        return {
            contactNumber: 'string',
            salaryPeriod: 'string',
            settleType: 'string',
            specifyWorkDate: 'string',
            specifyWorkTime: 'string',
            workBeginTimeMin: 'string',
            workDateType: 'string',
            workEndDate: 'string',
            workEndTimeMin: 'string',
            workStartDate: 'string',
        };
    }
}
exports.CollectRecruitJobDetailRequestJobInfoPartTimeInfo = CollectRecruitJobDetailRequestJobInfoPartTimeInfo;
class CollectRecruitJobDetailRequestJobInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            address: 'address',
            category: 'category',
            description: 'description',
            extInfo: 'extInfo',
            fullTimeInfo: 'fullTimeInfo',
            headCount: 'headCount',
            jobNature: 'jobNature',
            jobTags: 'jobTags',
            maxSalary: 'maxSalary',
            minSalary: 'minSalary',
            name: 'name',
            outJobId: 'outJobId',
            partTimeInfo: 'partTimeInfo',
            requiredEdu: 'requiredEdu',
        };
    }
    static types() {
        return {
            address: CollectRecruitJobDetailRequestJobInfoAddress,
            category: 'string',
            description: 'string',
            extInfo: 'string',
            fullTimeInfo: CollectRecruitJobDetailRequestJobInfoFullTimeInfo,
            headCount: 'string',
            jobNature: 'string',
            jobTags: { 'type': 'array', 'itemType': 'string' },
            maxSalary: 'string',
            minSalary: 'string',
            name: 'string',
            outJobId: 'string',
            partTimeInfo: CollectRecruitJobDetailRequestJobInfoPartTimeInfo,
            requiredEdu: 'string',
        };
    }
}
exports.CollectRecruitJobDetailRequestJobInfo = CollectRecruitJobDetailRequestJobInfo;
class CollectRecruitJobDetailRequestRecruitUserInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extInfo: 'extInfo',
            outUserId: 'outUserId',
            userMobile: 'userMobile',
            userName: 'userName',
        };
    }
    static types() {
        return {
            extInfo: 'string',
            outUserId: 'string',
            userMobile: 'string',
            userName: 'string',
        };
    }
}
exports.CollectRecruitJobDetailRequestRecruitUserInfo = CollectRecruitJobDetailRequestRecruitUserInfo;
class CollectResumeDetailRequestResumeDataBaseInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            age: 'age',
            avatar: 'avatar',
            beginWorkTime: 'beginWorkTime',
            birthday: 'birthday',
            email: 'email',
            englishName: 'englishName',
            graduateTime: 'graduateTime',
            highestEducation: 'highestEducation',
            jobTitle: 'jobTitle',
            lastSchoolName: 'lastSchoolName',
            married: 'married',
            name: 'name',
            nativePlace: 'nativePlace',
            nowLocation: 'nowLocation',
            personalHonor: 'personalHonor',
            phoneNum: 'phoneNum',
            politicalStatus: 'politicalStatus',
            selfEvaluation: 'selfEvaluation',
            sex: 'sex',
            virtualPhoneNum: 'virtualPhoneNum',
            workingYears: 'workingYears',
        };
    }
    static types() {
        return {
            age: 'number',
            avatar: 'string',
            beginWorkTime: 'string',
            birthday: 'string',
            email: 'string',
            englishName: 'string',
            graduateTime: 'string',
            highestEducation: 'number',
            jobTitle: 'string',
            lastSchoolName: 'string',
            married: 'number',
            name: 'string',
            nativePlace: 'string',
            nowLocation: 'string',
            personalHonor: 'string',
            phoneNum: 'string',
            politicalStatus: 'number',
            selfEvaluation: 'string',
            sex: 'number',
            virtualPhoneNum: 'string',
            workingYears: 'number',
        };
    }
}
exports.CollectResumeDetailRequestResumeDataBaseInfo = CollectResumeDetailRequestResumeDataBaseInfo;
class CollectResumeDetailRequestResumeDataCertificates extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certificateName: 'certificateName',
            grantTime: 'grantTime',
        };
    }
    static types() {
        return {
            certificateName: 'string',
            grantTime: 'string',
        };
    }
}
exports.CollectResumeDetailRequestResumeDataCertificates = CollectResumeDetailRequestResumeDataCertificates;
class CollectResumeDetailRequestResumeDataEducationExperiences extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            degree: 'degree',
            department: 'department',
            description: 'description',
            endDate: 'endDate',
            major: 'major',
            schoolName: 'schoolName',
            startDate: 'startDate',
        };
    }
    static types() {
        return {
            degree: 'number',
            department: 'string',
            description: 'string',
            endDate: 'string',
            major: 'string',
            schoolName: 'string',
            startDate: 'string',
        };
    }
}
exports.CollectResumeDetailRequestResumeDataEducationExperiences = CollectResumeDetailRequestResumeDataEducationExperiences;
class CollectResumeDetailRequestResumeDataJobExpect extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobName: 'jobName',
            locations: 'locations',
            maxSalary: 'maxSalary',
            minSalary: 'minSalary',
            onboardTime: 'onboardTime',
        };
    }
    static types() {
        return {
            jobName: 'string',
            locations: { 'type': 'array', 'itemType': 'string' },
            maxSalary: 'string',
            minSalary: 'string',
            onboardTime: 'string',
        };
    }
}
exports.CollectResumeDetailRequestResumeDataJobExpect = CollectResumeDetailRequestResumeDataJobExpect;
class CollectResumeDetailRequestResumeDataLanguageSkill extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certificateName: 'certificateName',
            languageName: 'languageName',
        };
    }
    static types() {
        return {
            certificateName: 'string',
            languageName: 'string',
        };
    }
}
exports.CollectResumeDetailRequestResumeDataLanguageSkill = CollectResumeDetailRequestResumeDataLanguageSkill;
class CollectResumeDetailRequestResumeDataTrainingExperiences extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            description: 'description',
            endDate: 'endDate',
            institutionName: 'institutionName',
            location: 'location',
            name: 'name',
            startDate: 'startDate',
        };
    }
    static types() {
        return {
            description: 'string',
            endDate: 'string',
            institutionName: 'string',
            location: 'string',
            name: 'string',
            startDate: 'string',
        };
    }
}
exports.CollectResumeDetailRequestResumeDataTrainingExperiences = CollectResumeDetailRequestResumeDataTrainingExperiences;
class CollectResumeDetailRequestResumeDataWorkExperiences extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            companyName: 'companyName',
            department: 'department',
            description: 'description',
            endDate: 'endDate',
            jobTitle: 'jobTitle',
            location: 'location',
            responsibility: 'responsibility',
            startDate: 'startDate',
        };
    }
    static types() {
        return {
            companyName: 'string',
            department: 'string',
            description: 'string',
            endDate: 'string',
            jobTitle: 'string',
            location: 'string',
            responsibility: 'string',
            startDate: 'string',
        };
    }
}
exports.CollectResumeDetailRequestResumeDataWorkExperiences = CollectResumeDetailRequestResumeDataWorkExperiences;
class CollectResumeDetailRequestResumeData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            baseInfo: 'baseInfo',
            certificates: 'certificates',
            educationExperiences: 'educationExperiences',
            jobExpect: 'jobExpect',
            languageSkill: 'languageSkill',
            trainingExperiences: 'trainingExperiences',
            workExperiences: 'workExperiences',
        };
    }
    static types() {
        return {
            baseInfo: CollectResumeDetailRequestResumeDataBaseInfo,
            certificates: { 'type': 'array', 'itemType': CollectResumeDetailRequestResumeDataCertificates },
            educationExperiences: { 'type': 'array', 'itemType': CollectResumeDetailRequestResumeDataEducationExperiences },
            jobExpect: CollectResumeDetailRequestResumeDataJobExpect,
            languageSkill: { 'type': 'array', 'itemType': CollectResumeDetailRequestResumeDataLanguageSkill },
            trainingExperiences: { 'type': 'array', 'itemType': CollectResumeDetailRequestResumeDataTrainingExperiences },
            workExperiences: { 'type': 'array', 'itemType': CollectResumeDetailRequestResumeDataWorkExperiences },
        };
    }
}
exports.CollectResumeDetailRequestResumeData = CollectResumeDetailRequestResumeData;
class CollectResumeDetailRequestResumeFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadUrl: 'downloadUrl',
            fileName: 'fileName',
            fileType: 'fileType',
        };
    }
    static types() {
        return {
            downloadUrl: 'string',
            fileName: 'string',
            fileType: 'string',
        };
    }
}
exports.CollectResumeDetailRequestResumeFile = CollectResumeDetailRequestResumeFile;
class CollectResumeMailRequestResumeFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadUrl: 'downloadUrl',
            fileName: 'fileName',
            fileType: 'fileType',
        };
    }
    static types() {
        return {
            downloadUrl: 'string',
            fileName: 'string',
            fileType: 'string',
        };
    }
}
exports.CollectResumeMailRequestResumeFile = CollectResumeMailRequestResumeFile;
class GetJobAuthResponseBodyJobOwners extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.GetJobAuthResponseBodyJobOwners = GetJobAuthResponseBodyJobOwners;
class QueryInterviewsResponseBodyListInterviewers extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.QueryInterviewsResponseBodyListInterviewers = QueryInterviewsResponseBodyListInterviewers;
class QueryInterviewsResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cancelled: 'cancelled',
            creatorUserId: 'creatorUserId',
            endTimeMillis: 'endTimeMillis',
            interviewId: 'interviewId',
            interviewers: 'interviewers',
            jobId: 'jobId',
            startTimeMillis: 'startTimeMillis',
        };
    }
    static types() {
        return {
            cancelled: 'boolean',
            creatorUserId: 'string',
            endTimeMillis: 'number',
            interviewId: 'string',
            interviewers: { 'type': 'array', 'itemType': QueryInterviewsResponseBodyListInterviewers },
            jobId: 'string',
            startTimeMillis: 'number',
        };
    }
}
exports.QueryInterviewsResponseBodyList = QueryInterviewsResponseBodyList;
class UpdateApplicationRegFormRequestDingPanFile extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            fileName: 'fileName',
            fileSize: 'fileSize',
            fileType: 'fileType',
            spaceId: 'spaceId',
        };
    }
    static types() {
        return {
            fileId: 'string',
            fileName: 'string',
            fileSize: 'number',
            fileType: 'string',
            spaceId: 'number',
        };
    }
}
exports.UpdateApplicationRegFormRequestDingPanFile = UpdateApplicationRegFormRequestDingPanFile;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addApplicationRegFormTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddApplicationRegFormTemplate",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/flows/applicationRegForms/templates`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddApplicationRegFormTemplateResponse({}));
    }
    async addApplicationRegFormTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddApplicationRegFormTemplateHeaders({});
        return await this.addApplicationRegFormTemplateWithOptions(request, headers, runtime);
    }
    async addFileWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.fileName)) {
            body["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            body["mediaId"] = request.mediaId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddFile",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/files`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddFileResponse({}));
    }
    async addFile(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddFileHeaders({});
        return await this.addFileWithOptions(request, headers, runtime);
    }
    async addUserAccountWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.corpId)) {
            query["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.channelAccountName)) {
            body["channelAccountName"] = request.channelAccountName;
        }
        if (!tea_util_1.default.isUnset(request.channelUserIdentify)) {
            body["channelUserIdentify"] = request.channelUserIdentify;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            body["phoneNumber"] = request.phoneNumber;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddUserAccount",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/channels/users/accounts`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddUserAccountResponse({}));
    }
    async addUserAccount(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddUserAccountHeaders({});
        return await this.addUserAccountWithOptions(request, headers, runtime);
    }
    async collectRecruitJobDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.channel)) {
            body["channel"] = request.channel;
        }
        if (!tea_util_1.default.isUnset(request.jobInfo)) {
            body["jobInfo"] = request.jobInfo;
        }
        if (!tea_util_1.default.isUnset(request.outCorpId)) {
            body["outCorpId"] = request.outCorpId;
        }
        if (!tea_util_1.default.isUnset(request.outCorpName)) {
            body["outCorpName"] = request.outCorpName;
        }
        if (!tea_util_1.default.isUnset(request.recruitUserInfo)) {
            body["recruitUserInfo"] = request.recruitUserInfo;
        }
        if (!tea_util_1.default.isUnset(request.source)) {
            body["source"] = request.source;
        }
        if (!tea_util_1.default.isUnset(request.updateTime)) {
            body["updateTime"] = request.updateTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CollectRecruitJobDetail",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/channels/jobs/import`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CollectRecruitJobDetailResponse({}));
    }
    async collectRecruitJobDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CollectRecruitJobDetailHeaders({});
        return await this.collectRecruitJobDetailWithOptions(request, headers, runtime);
    }
    async collectResumeDetailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.channelCode)) {
            body["channelCode"] = request.channelCode;
        }
        if (!tea_util_1.default.isUnset(request.channelOuterId)) {
            body["channelOuterId"] = request.channelOuterId;
        }
        if (!tea_util_1.default.isUnset(request.channelTalentId)) {
            body["channelTalentId"] = request.channelTalentId;
        }
        if (!tea_util_1.default.isUnset(request.deliverJobId)) {
            body["deliverJobId"] = request.deliverJobId;
        }
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            body["optUserId"] = request.optUserId;
        }
        if (!tea_util_1.default.isUnset(request.resumeChannelUrl)) {
            body["resumeChannelUrl"] = request.resumeChannelUrl;
        }
        if (!tea_util_1.default.isUnset(request.resumeData)) {
            body["resumeData"] = request.resumeData;
        }
        if (!tea_util_1.default.isUnset(request.resumeFile)) {
            body["resumeFile"] = request.resumeFile;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CollectResumeDetail",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/resumes/details`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CollectResumeDetailResponse({}));
    }
    async collectResumeDetail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CollectResumeDetailHeaders({});
        return await this.collectResumeDetailWithOptions(request, headers, runtime);
    }
    async collectResumeMailWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.channelCode)) {
            body["channelCode"] = request.channelCode;
        }
        if (!tea_util_1.default.isUnset(request.deliverJobId)) {
            body["deliverJobId"] = request.deliverJobId;
        }
        if (!tea_util_1.default.isUnset(request.fromMailAddress)) {
            body["fromMailAddress"] = request.fromMailAddress;
        }
        if (!tea_util_1.default.isUnset(request.historyMailImport)) {
            body["historyMailImport"] = request.historyMailImport;
        }
        if (!tea_util_1.default.isUnset(request.mailId)) {
            body["mailId"] = request.mailId;
        }
        if (!tea_util_1.default.isUnset(request.mailTitle)) {
            body["mailTitle"] = request.mailTitle;
        }
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            body["optUserId"] = request.optUserId;
        }
        if (!tea_util_1.default.isUnset(request.receiveMailAddress)) {
            body["receiveMailAddress"] = request.receiveMailAddress;
        }
        if (!tea_util_1.default.isUnset(request.receiveMailType)) {
            body["receiveMailType"] = request.receiveMailType;
        }
        if (!tea_util_1.default.isUnset(request.receivedTime)) {
            body["receivedTime"] = request.receivedTime;
        }
        if (!tea_util_1.default.isUnset(request.resumeChannelUrl)) {
            body["resumeChannelUrl"] = request.resumeChannelUrl;
        }
        if (!tea_util_1.default.isUnset(request.resumeFile)) {
            body["resumeFile"] = request.resumeFile;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CollectResumeMail",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/resumes/mails`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CollectResumeMailResponse({}));
    }
    async collectResumeMail(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CollectResumeMailHeaders({});
        return await this.collectResumeMailWithOptions(request, headers, runtime);
    }
    async confirmRightsWithOptions(rightsCode, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ConfirmRights",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/rights/${rightsCode}/confirm`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ConfirmRightsResponse({}));
    }
    async confirmRights(rightsCode, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ConfirmRightsHeaders({});
        return await this.confirmRightsWithOptions(rightsCode, request, headers, runtime);
    }
    async finishBeginnerTaskWithOptions(taskCode, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.scope)) {
            query["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "FinishBeginnerTask",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/beginnerTasks/${taskCode}/finish`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new FinishBeginnerTaskResponse({}));
    }
    async finishBeginnerTask(taskCode, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new FinishBeginnerTaskHeaders({});
        return await this.finishBeginnerTaskWithOptions(taskCode, request, headers, runtime);
    }
    async getApplicationRegFormByFlowIdWithOptions(flowId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetApplicationRegFormByFlowId",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/flows/${flowId}/applicationRegForms`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetApplicationRegFormByFlowIdResponse({}));
    }
    async getApplicationRegFormByFlowId(flowId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetApplicationRegFormByFlowIdHeaders({});
        return await this.getApplicationRegFormByFlowIdWithOptions(flowId, request, headers, runtime);
    }
    async getCandidateByPhoneNumberWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.phoneNumber)) {
            query["phoneNumber"] = request.phoneNumber;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetCandidateByPhoneNumber",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/candidates`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCandidateByPhoneNumberResponse({}));
    }
    async getCandidateByPhoneNumber(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCandidateByPhoneNumberHeaders({});
        return await this.getCandidateByPhoneNumberWithOptions(request, headers, runtime);
    }
    async getFileUploadInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            query["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.fileSize)) {
            query["fileSize"] = request.fileSize;
        }
        if (!tea_util_1.default.isUnset(request.md5)) {
            query["md5"] = request.md5;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFileUploadInfo",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/files/uploadInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFileUploadInfoResponse({}));
    }
    async getFileUploadInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileUploadInfoHeaders({});
        return await this.getFileUploadInfoWithOptions(request, headers, runtime);
    }
    async getFlowIdByRelationEntityIdWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.relationEntity)) {
            query["relationEntity"] = request.relationEntity;
        }
        if (!tea_util_1.default.isUnset(request.relationEntityId)) {
            query["relationEntityId"] = request.relationEntityId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetFlowIdByRelationEntityId",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/flows/ids`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFlowIdByRelationEntityIdResponse({}));
    }
    async getFlowIdByRelationEntityId(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFlowIdByRelationEntityIdHeaders({});
        return await this.getFlowIdByRelationEntityIdWithOptions(request, headers, runtime);
    }
    async getJobAuthWithOptions(jobId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            query["opUserId"] = request.opUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetJobAuth",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/auths/jobs/${jobId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetJobAuthResponse({}));
    }
    async getJobAuth(jobId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetJobAuthHeaders({});
        return await this.getJobAuthWithOptions(jobId, request, headers, runtime);
    }
    async queryInterviewsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.size)) {
            query["size"] = request.size;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.candidateId)) {
            body["candidateId"] = request.candidateId;
        }
        if (!tea_util_1.default.isUnset(request.startTimeBeginMillis)) {
            body["startTimeBeginMillis"] = request.startTimeBeginMillis;
        }
        if (!tea_util_1.default.isUnset(request.startTimeEndMillis)) {
            body["startTimeEndMillis"] = request.startTimeEndMillis;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryInterviews",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/interviews/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryInterviewsResponse({}));
    }
    async queryInterviews(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryInterviewsHeaders({});
        return await this.queryInterviewsWithOptions(request, headers, runtime);
    }
    async reportMessageStatusWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.channel)) {
            body["channel"] = request.channel;
        }
        if (!tea_util_1.default.isUnset(request.errorCode)) {
            body["errorCode"] = request.errorCode;
        }
        if (!tea_util_1.default.isUnset(request.errorMsg)) {
            body["errorMsg"] = request.errorMsg;
        }
        if (!tea_util_1.default.isUnset(request.messageId)) {
            body["messageId"] = request.messageId;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserId)) {
            body["receiverUserId"] = request.receiverUserId;
        }
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            body["senderUserId"] = request.senderUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ReportMessageStatus",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/channels/messages/statuses/report`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ReportMessageStatusResponse({}));
    }
    async reportMessageStatus(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ReportMessageStatusHeaders({});
        return await this.reportMessageStatusWithOptions(request, headers, runtime);
    }
    async syncChannelMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.channel)) {
            body["channel"] = request.channel;
        }
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.createTime)) {
            body["createTime"] = request.createTime;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserId)) {
            body["receiverUserId"] = request.receiverUserId;
        }
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            body["senderUserId"] = request.senderUserId;
        }
        if (!tea_util_1.default.isUnset(request.uuid)) {
            body["uuid"] = request.uuid;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SyncChannelMessage",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/channels/messages/sync`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SyncChannelMessageResponse({}));
    }
    async syncChannelMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SyncChannelMessageHeaders({});
        return await this.syncChannelMessageWithOptions(request, headers, runtime);
    }
    async updateApplicationRegFormWithOptions(flowId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.dingPanFile)) {
            body["dingPanFile"] = request.dingPanFile;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateApplicationRegForm",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/flows/${flowId}/applicationRegForms`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateApplicationRegFormResponse({}));
    }
    async updateApplicationRegForm(flowId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateApplicationRegFormHeaders({});
        return await this.updateApplicationRegFormWithOptions(flowId, request, headers, runtime);
    }
    async updateInterviewSignInInfoWithOptions(interviewId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.signInTimeMillis)) {
            body["signInTimeMillis"] = request.signInTimeMillis;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateInterviewSignInInfo",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/interviews/${interviewId}/signInInfos`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateInterviewSignInInfoResponse({}));
    }
    async updateInterviewSignInInfo(interviewId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateInterviewSignInInfoHeaders({});
        return await this.updateInterviewSignInInfoWithOptions(interviewId, request, headers, runtime);
    }
    async updateJobDeliverWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizCode)) {
            query["bizCode"] = request.bizCode;
        }
        if (!tea_util_1.default.isUnset(request.jobId)) {
            query["jobId"] = request.jobId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.channelOuterId)) {
            body["channelOuterId"] = request.channelOuterId;
        }
        if (!tea_util_1.default.isUnset(request.deliverUserId)) {
            body["deliverUserId"] = request.deliverUserId;
        }
        if (!tea_util_1.default.isUnset(request.errorCode)) {
            body["errorCode"] = request.errorCode;
        }
        if (!tea_util_1.default.isUnset(request.errorMsg)) {
            body["errorMsg"] = request.errorMsg;
        }
        if (!tea_util_1.default.isUnset(request.opTime)) {
            body["opTime"] = request.opTime;
        }
        if (!tea_util_1.default.isUnset(request.opUserId)) {
            body["opUserId"] = request.opUserId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateJobDeliver",
            version: "ats_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/ats/jobs/deliveryStatus`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateJobDeliverResponse({}));
    }
    async updateJobDeliver(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateJobDeliverHeaders({});
        return await this.updateJobDeliverWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map