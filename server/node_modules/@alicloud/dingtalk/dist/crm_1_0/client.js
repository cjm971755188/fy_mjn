"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AbandonCustomerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AbandonCustomerHeaders = AbandonCustomerHeaders;
class AbandonCustomerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customTrackDesc: 'customTrackDesc',
            instanceIdList: 'instanceIdList',
            operatorUserId: 'operatorUserId',
            optType: 'optType',
        };
    }
    static types() {
        return {
            customTrackDesc: 'string',
            instanceIdList: { 'type': 'array', 'itemType': 'string' },
            operatorUserId: 'string',
            optType: 'string',
        };
    }
}
exports.AbandonCustomerRequest = AbandonCustomerRequest;
class AbandonCustomerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceIdList: 'instanceIdList',
        };
    }
    static types() {
        return {
            instanceIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.AbandonCustomerResponseBody = AbandonCustomerResponseBody;
class AbandonCustomerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AbandonCustomerResponseBody,
        };
    }
}
exports.AbandonCustomerResponse = AbandonCustomerResponse;
class AddCrmPersonalCustomerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddCrmPersonalCustomerHeaders = AddCrmPersonalCustomerHeaders;
class AddCrmPersonalCustomerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            creatorNick: 'creatorNick',
            creatorUserId: 'creatorUserId',
            data: 'data',
            extendData: 'extendData',
            permission: 'permission',
            relationType: 'relationType',
            skipDuplicateCheck: 'skipDuplicateCheck',
        };
    }
    static types() {
        return {
            action: 'string',
            creatorNick: 'string',
            creatorUserId: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            permission: AddCrmPersonalCustomerRequestPermission,
            relationType: 'string',
            skipDuplicateCheck: 'boolean',
        };
    }
}
exports.AddCrmPersonalCustomerRequest = AddCrmPersonalCustomerRequest;
class AddCrmPersonalCustomerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'instanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
        };
    }
}
exports.AddCrmPersonalCustomerResponseBody = AddCrmPersonalCustomerResponseBody;
class AddCrmPersonalCustomerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddCrmPersonalCustomerResponseBody,
        };
    }
}
exports.AddCrmPersonalCustomerResponse = AddCrmPersonalCustomerResponse;
class AddCustomerTrackHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddCustomerTrackHeaders = AddCustomerTrackHeaders;
class AddCustomerTrackRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            customerId: 'customerId',
            extraBizInfo: 'extraBizInfo',
            idempotentKey: 'idempotentKey',
            maskedContent: 'maskedContent',
            operatorUserId: 'operatorUserId',
            relationType: 'relationType',
            title: 'title',
            type: 'type',
        };
    }
    static types() {
        return {
            content: 'string',
            customerId: 'string',
            extraBizInfo: 'string',
            idempotentKey: 'string',
            maskedContent: 'string',
            operatorUserId: 'string',
            relationType: 'string',
            title: 'string',
            type: 'number',
        };
    }
}
exports.AddCustomerTrackRequest = AddCustomerTrackRequest;
class AddCustomerTrackResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.AddCustomerTrackResponseBody = AddCustomerTrackResponseBody;
class AddCustomerTrackResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddCustomerTrackResponseBody,
        };
    }
}
exports.AddCustomerTrackResponse = AddCustomerTrackResponse;
class AddLeadsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddLeadsHeaders = AddLeadsHeaders;
class AddLeadsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            assignTimestamp: 'assignTimestamp',
            assignUserId: 'assignUserId',
            assignedUserId: 'assignedUserId',
            leads: 'leads',
            outTaskId: 'outTaskId',
        };
    }
    static types() {
        return {
            assignTimestamp: 'number',
            assignUserId: 'string',
            assignedUserId: 'string',
            leads: { 'type': 'array', 'itemType': AddLeadsRequestLeads },
            outTaskId: 'string',
        };
    }
}
exports.AddLeadsRequest = AddLeadsRequest;
class AddLeadsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            outTaskId: 'outTaskId',
        };
    }
    static types() {
        return {
            outTaskId: 'string',
        };
    }
}
exports.AddLeadsResponseBody = AddLeadsResponseBody;
class AddLeadsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddLeadsResponseBody,
        };
    }
}
exports.AddLeadsResponse = AddLeadsResponse;
class AddRelationMetaFieldHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddRelationMetaFieldHeaders = AddRelationMetaFieldHeaders;
class AddRelationMetaFieldRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldDTOList: 'fieldDTOList',
            operatorUserId: 'operatorUserId',
            relationType: 'relationType',
            tenant: 'tenant',
        };
    }
    static types() {
        return {
            fieldDTOList: { 'type': 'array', 'itemType': AddRelationMetaFieldRequestFieldDTOList },
            operatorUserId: 'string',
            relationType: 'string',
            tenant: 'string',
        };
    }
}
exports.AddRelationMetaFieldRequest = AddRelationMetaFieldRequest;
class AddRelationMetaFieldResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            relationType: 'string',
        };
    }
}
exports.AddRelationMetaFieldResponseBody = AddRelationMetaFieldResponseBody;
class AddRelationMetaFieldResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddRelationMetaFieldResponseBody,
        };
    }
}
exports.AddRelationMetaFieldResponse = AddRelationMetaFieldResponse;
class BatchAddContactsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchAddContactsHeaders = BatchAddContactsHeaders;
class BatchAddContactsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorUserId: 'operatorUserId',
            relationList: 'relationList',
        };
    }
    static types() {
        return {
            operatorUserId: 'string',
            relationList: { 'type': 'array', 'itemType': BatchAddContactsRequestRelationList },
        };
    }
}
exports.BatchAddContactsRequest = BatchAddContactsRequest;
class BatchAddContactsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': BatchAddContactsResponseBodyResults },
        };
    }
}
exports.BatchAddContactsResponseBody = BatchAddContactsResponseBody;
class BatchAddContactsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchAddContactsResponseBody,
        };
    }
}
exports.BatchAddContactsResponse = BatchAddContactsResponse;
class BatchAddFollowRecordsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchAddFollowRecordsHeaders = BatchAddFollowRecordsHeaders;
class BatchAddFollowRecordsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceList: 'instanceList',
            operatorUserId: 'operatorUserId',
        };
    }
    static types() {
        return {
            instanceList: { 'type': 'array', 'itemType': BatchAddFollowRecordsRequestInstanceList },
            operatorUserId: 'string',
        };
    }
}
exports.BatchAddFollowRecordsRequest = BatchAddFollowRecordsRequest;
class BatchAddFollowRecordsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': BatchAddFollowRecordsResponseBodyResults },
        };
    }
}
exports.BatchAddFollowRecordsResponseBody = BatchAddFollowRecordsResponseBody;
class BatchAddFollowRecordsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchAddFollowRecordsResponseBody,
        };
    }
}
exports.BatchAddFollowRecordsResponse = BatchAddFollowRecordsResponse;
class BatchAddRelationDatasHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchAddRelationDatasHeaders = BatchAddRelationDatasHeaders;
class BatchAddRelationDatasRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorUserId: 'operatorUserId',
            relationList: 'relationList',
            relationType: 'relationType',
            skipDuplicateCheck: 'skipDuplicateCheck',
        };
    }
    static types() {
        return {
            operatorUserId: 'string',
            relationList: { 'type': 'array', 'itemType': BatchAddRelationDatasRequestRelationList },
            relationType: 'string',
            skipDuplicateCheck: 'boolean',
        };
    }
}
exports.BatchAddRelationDatasRequest = BatchAddRelationDatasRequest;
class BatchAddRelationDatasResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': BatchAddRelationDatasResponseBodyResults },
        };
    }
}
exports.BatchAddRelationDatasResponseBody = BatchAddRelationDatasResponseBody;
class BatchAddRelationDatasResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchAddRelationDatasResponseBody,
        };
    }
}
exports.BatchAddRelationDatasResponse = BatchAddRelationDatasResponse;
class BatchRemoveFollowRecordsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchRemoveFollowRecordsHeaders = BatchRemoveFollowRecordsHeaders;
class BatchRemoveFollowRecordsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceIds: 'instanceIds',
            operatorUserId: 'operatorUserId',
        };
    }
    static types() {
        return {
            instanceIds: { 'type': 'array', 'itemType': 'string' },
            operatorUserId: 'string',
        };
    }
}
exports.BatchRemoveFollowRecordsRequest = BatchRemoveFollowRecordsRequest;
class BatchRemoveFollowRecordsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': BatchRemoveFollowRecordsResponseBodyResults },
        };
    }
}
exports.BatchRemoveFollowRecordsResponseBody = BatchRemoveFollowRecordsResponseBody;
class BatchRemoveFollowRecordsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchRemoveFollowRecordsResponseBody,
        };
    }
}
exports.BatchRemoveFollowRecordsResponse = BatchRemoveFollowRecordsResponse;
class BatchSendOfficialAccountOTOMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageHeaders = BatchSendOfficialAccountOTOMessageHeaders;
class BatchSendOfficialAccountOTOMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            bizId: 'bizId',
            detail: 'detail',
        };
    }
    static types() {
        return {
            accountId: 'string',
            bizId: 'string',
            detail: BatchSendOfficialAccountOTOMessageRequestDetail,
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequest = BatchSendOfficialAccountOTOMessageRequest;
class BatchSendOfficialAccountOTOMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: BatchSendOfficialAccountOTOMessageResponseBodyResult,
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageResponseBody = BatchSendOfficialAccountOTOMessageResponseBody;
class BatchSendOfficialAccountOTOMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchSendOfficialAccountOTOMessageResponseBody,
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageResponse = BatchSendOfficialAccountOTOMessageResponse;
class BatchUpdateContactsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchUpdateContactsHeaders = BatchUpdateContactsHeaders;
class BatchUpdateContactsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorUserId: 'operatorUserId',
            relationList: 'relationList',
        };
    }
    static types() {
        return {
            operatorUserId: 'string',
            relationList: { 'type': 'array', 'itemType': BatchUpdateContactsRequestRelationList },
        };
    }
}
exports.BatchUpdateContactsRequest = BatchUpdateContactsRequest;
class BatchUpdateContactsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': BatchUpdateContactsResponseBodyResults },
        };
    }
}
exports.BatchUpdateContactsResponseBody = BatchUpdateContactsResponseBody;
class BatchUpdateContactsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchUpdateContactsResponseBody,
        };
    }
}
exports.BatchUpdateContactsResponse = BatchUpdateContactsResponse;
class BatchUpdateFollowRecordsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchUpdateFollowRecordsHeaders = BatchUpdateFollowRecordsHeaders;
class BatchUpdateFollowRecordsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceList: 'instanceList',
            operatorUserId: 'operatorUserId',
        };
    }
    static types() {
        return {
            instanceList: { 'type': 'array', 'itemType': BatchUpdateFollowRecordsRequestInstanceList },
            operatorUserId: 'string',
        };
    }
}
exports.BatchUpdateFollowRecordsRequest = BatchUpdateFollowRecordsRequest;
class BatchUpdateFollowRecordsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': BatchUpdateFollowRecordsResponseBodyResults },
        };
    }
}
exports.BatchUpdateFollowRecordsResponseBody = BatchUpdateFollowRecordsResponseBody;
class BatchUpdateFollowRecordsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchUpdateFollowRecordsResponseBody,
        };
    }
}
exports.BatchUpdateFollowRecordsResponse = BatchUpdateFollowRecordsResponse;
class BatchUpdateRelationDatasHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.BatchUpdateRelationDatasHeaders = BatchUpdateRelationDatasHeaders;
class BatchUpdateRelationDatasRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorUserId: 'operatorUserId',
            relationList: 'relationList',
            relationType: 'relationType',
            skipDuplicateCheck: 'skipDuplicateCheck',
        };
    }
    static types() {
        return {
            operatorUserId: 'string',
            relationList: { 'type': 'array', 'itemType': BatchUpdateRelationDatasRequestRelationList },
            relationType: 'string',
            skipDuplicateCheck: 'boolean',
        };
    }
}
exports.BatchUpdateRelationDatasRequest = BatchUpdateRelationDatasRequest;
class BatchUpdateRelationDatasResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            results: 'results',
        };
    }
    static types() {
        return {
            results: { 'type': 'array', 'itemType': BatchUpdateRelationDatasResponseBodyResults },
        };
    }
}
exports.BatchUpdateRelationDatasResponseBody = BatchUpdateRelationDatasResponseBody;
class BatchUpdateRelationDatasResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: BatchUpdateRelationDatasResponseBody,
        };
    }
}
exports.BatchUpdateRelationDatasResponse = BatchUpdateRelationDatasResponse;
class CreateCustomerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateCustomerHeaders = CreateCustomerHeaders;
class CreateCustomerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contacts: 'contacts',
            creatorUserId: 'creatorUserId',
            data: 'data',
            extendData: 'extendData',
            instanceId: 'instanceId',
            objectType: 'objectType',
            permission: 'permission',
            saveOption: 'saveOption',
        };
    }
    static types() {
        return {
            contacts: { 'type': 'array', 'itemType': CreateCustomerRequestContacts },
            creatorUserId: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            instanceId: 'string',
            objectType: 'string',
            permission: CreateCustomerRequestPermission,
            saveOption: CreateCustomerRequestSaveOption,
        };
    }
}
exports.CreateCustomerRequest = CreateCustomerRequest;
class CreateCustomerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contacts: 'contacts',
            customerInstanceId: 'customerInstanceId',
            objectType: 'objectType',
        };
    }
    static types() {
        return {
            contacts: { 'type': 'array', 'itemType': CreateCustomerResponseBodyContacts },
            customerInstanceId: 'string',
            objectType: 'string',
        };
    }
}
exports.CreateCustomerResponseBody = CreateCustomerResponseBody;
class CreateCustomerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateCustomerResponseBody,
        };
    }
}
exports.CreateCustomerResponse = CreateCustomerResponse;
class CreateGroupHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateGroupHeaders = CreateGroupHeaders;
class CreateGroupRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupName: 'groupName',
            memberUserIds: 'memberUserIds',
            ownerUserId: 'ownerUserId',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            groupName: 'string',
            memberUserIds: 'string',
            ownerUserId: 'string',
            relationType: 'string',
        };
    }
}
exports.CreateGroupRequest = CreateGroupRequest;
class CreateGroupResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
}
exports.CreateGroupResponseBody = CreateGroupResponseBody;
class CreateGroupResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGroupResponseBody,
        };
    }
}
exports.CreateGroupResponse = CreateGroupResponse;
class CreateGroupSetHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateGroupSetHeaders = CreateGroupSetHeaders;
class CreateGroupSetRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorUserId: 'creatorUserId',
            managerUserIds: 'managerUserIds',
            memberQuota: 'memberQuota',
            name: 'name',
            notice: 'notice',
            noticeToped: 'noticeToped',
            ownerUserId: 'ownerUserId',
            relationType: 'relationType',
            templateId: 'templateId',
            welcome: 'welcome',
        };
    }
    static types() {
        return {
            creatorUserId: 'string',
            managerUserIds: 'string',
            memberQuota: 'number',
            name: 'string',
            notice: 'string',
            noticeToped: 'number',
            ownerUserId: 'string',
            relationType: 'string',
            templateId: 'string',
            welcome: 'string',
        };
    }
}
exports.CreateGroupSetRequest = CreateGroupSetRequest;
class CreateGroupSetResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            inviteLink: 'inviteLink',
            lastOpenConversationId: 'lastOpenConversationId',
            manager: 'manager',
            managerUserIds: 'managerUserIds',
            memberCount: 'memberCount',
            memberQuota: 'memberQuota',
            name: 'name',
            notice: 'notice',
            noticeToped: 'noticeToped',
            openGroupSetId: 'openGroupSetId',
            owner: 'owner',
            ownerUserId: 'ownerUserId',
            relationType: 'relationType',
            templateId: 'templateId',
        };
    }
    static types() {
        return {
            gmtCreate: 'string',
            gmtModified: 'string',
            inviteLink: 'string',
            lastOpenConversationId: 'string',
            manager: { 'type': 'array', 'itemType': CreateGroupSetResponseBodyManager },
            managerUserIds: 'string',
            memberCount: 'number',
            memberQuota: 'number',
            name: 'string',
            notice: 'string',
            noticeToped: 'number',
            openGroupSetId: 'string',
            owner: CreateGroupSetResponseBodyOwner,
            ownerUserId: 'string',
            relationType: 'string',
            templateId: 'string',
        };
    }
}
exports.CreateGroupSetResponseBody = CreateGroupSetResponseBody;
class CreateGroupSetResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateGroupSetResponseBody,
        };
    }
}
exports.CreateGroupSetResponse = CreateGroupSetResponse;
class CreateRelationMetaHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateRelationMetaHeaders = CreateRelationMetaHeaders;
class CreateRelationMetaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorUserId: 'operatorUserId',
            relationMetaDTO: 'relationMetaDTO',
            tenant: 'tenant',
        };
    }
    static types() {
        return {
            operatorUserId: 'string',
            relationMetaDTO: CreateRelationMetaRequestRelationMetaDTO,
            tenant: 'string',
        };
    }
}
exports.CreateRelationMetaRequest = CreateRelationMetaRequest;
class CreateRelationMetaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            relationType: 'string',
        };
    }
}
exports.CreateRelationMetaResponseBody = CreateRelationMetaResponseBody;
class CreateRelationMetaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateRelationMetaResponseBody,
        };
    }
}
exports.CreateRelationMetaResponse = CreateRelationMetaResponse;
class DeleteCrmCustomObjectDataHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteCrmCustomObjectDataHeaders = DeleteCrmCustomObjectDataHeaders;
class DeleteCrmCustomObjectDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            formCode: 'formCode',
        };
    }
    static types() {
        return {
            formCode: 'string',
        };
    }
}
exports.DeleteCrmCustomObjectDataRequest = DeleteCrmCustomObjectDataRequest;
class DeleteCrmCustomObjectDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'instanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
        };
    }
}
exports.DeleteCrmCustomObjectDataResponseBody = DeleteCrmCustomObjectDataResponseBody;
class DeleteCrmCustomObjectDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteCrmCustomObjectDataResponseBody,
        };
    }
}
exports.DeleteCrmCustomObjectDataResponse = DeleteCrmCustomObjectDataResponse;
class DeleteCrmFormInstanceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteCrmFormInstanceHeaders = DeleteCrmFormInstanceHeaders;
class DeleteCrmFormInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentOperatorUserId: 'currentOperatorUserId',
            name: 'name',
        };
    }
    static types() {
        return {
            currentOperatorUserId: 'string',
            name: 'string',
        };
    }
}
exports.DeleteCrmFormInstanceRequest = DeleteCrmFormInstanceRequest;
class DeleteCrmFormInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'instanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
        };
    }
}
exports.DeleteCrmFormInstanceResponseBody = DeleteCrmFormInstanceResponseBody;
class DeleteCrmFormInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteCrmFormInstanceResponseBody,
        };
    }
}
exports.DeleteCrmFormInstanceResponse = DeleteCrmFormInstanceResponse;
class DeleteCrmPersonalCustomerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteCrmPersonalCustomerHeaders = DeleteCrmPersonalCustomerHeaders;
class DeleteCrmPersonalCustomerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentOperatorUserId: 'currentOperatorUserId',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            currentOperatorUserId: 'string',
            relationType: 'string',
        };
    }
}
exports.DeleteCrmPersonalCustomerRequest = DeleteCrmPersonalCustomerRequest;
class DeleteCrmPersonalCustomerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'instanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
        };
    }
}
exports.DeleteCrmPersonalCustomerResponseBody = DeleteCrmPersonalCustomerResponseBody;
class DeleteCrmPersonalCustomerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteCrmPersonalCustomerResponseBody,
        };
    }
}
exports.DeleteCrmPersonalCustomerResponse = DeleteCrmPersonalCustomerResponse;
class DeleteLeadsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteLeadsHeaders = DeleteLeadsHeaders;
class DeleteLeadsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            outLeadsIds: 'outLeadsIds',
        };
    }
    static types() {
        return {
            outLeadsIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeleteLeadsRequest = DeleteLeadsRequest;
class DeleteLeadsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            outLeadsIds: 'outLeadsIds',
        };
    }
    static types() {
        return {
            outLeadsIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.DeleteLeadsResponseBody = DeleteLeadsResponseBody;
class DeleteLeadsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteLeadsResponseBody,
        };
    }
}
exports.DeleteLeadsResponse = DeleteLeadsResponse;
class DeleteRelationMetaFieldHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeleteRelationMetaFieldHeaders = DeleteRelationMetaFieldHeaders;
class DeleteRelationMetaFieldRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldIdList: 'fieldIdList',
            operatorUserId: 'operatorUserId',
            relationType: 'relationType',
            tenant: 'tenant',
        };
    }
    static types() {
        return {
            fieldIdList: { 'type': 'array', 'itemType': 'string' },
            operatorUserId: 'string',
            relationType: 'string',
            tenant: 'string',
        };
    }
}
exports.DeleteRelationMetaFieldRequest = DeleteRelationMetaFieldRequest;
class DeleteRelationMetaFieldResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            relationType: 'string',
        };
    }
}
exports.DeleteRelationMetaFieldResponseBody = DeleteRelationMetaFieldResponseBody;
class DeleteRelationMetaFieldResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeleteRelationMetaFieldResponseBody,
        };
    }
}
exports.DeleteRelationMetaFieldResponse = DeleteRelationMetaFieldResponse;
class DescribeCrmPersonalCustomerObjectMetaHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaHeaders = DescribeCrmPersonalCustomerObjectMetaHeaders;
class DescribeCrmPersonalCustomerObjectMetaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            relationType: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaRequest = DescribeCrmPersonalCustomerObjectMetaRequest;
class DescribeCrmPersonalCustomerObjectMetaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
            customized: 'customized',
            fields: 'fields',
            name: 'name',
            status: 'status',
        };
    }
    static types() {
        return {
            code: 'string',
            customized: 'boolean',
            fields: { 'type': 'array', 'itemType': DescribeCrmPersonalCustomerObjectMetaResponseBodyFields },
            name: 'string',
            status: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaResponseBody = DescribeCrmPersonalCustomerObjectMetaResponseBody;
class DescribeCrmPersonalCustomerObjectMetaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeCrmPersonalCustomerObjectMetaResponseBody,
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaResponse = DescribeCrmPersonalCustomerObjectMetaResponse;
class DescribeRelationMetaHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DescribeRelationMetaHeaders = DescribeRelationMetaHeaders;
class DescribeRelationMetaRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorUserId: 'operatorUserId',
            relationTypes: 'relationTypes',
            tenant: 'tenant',
        };
    }
    static types() {
        return {
            operatorUserId: 'string',
            relationTypes: { 'type': 'array', 'itemType': 'string' },
            tenant: 'string',
        };
    }
}
exports.DescribeRelationMetaRequest = DescribeRelationMetaRequest;
class DescribeRelationMetaResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationMetaDTOList: 'relationMetaDTOList',
        };
    }
    static types() {
        return {
            relationMetaDTOList: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOList },
        };
    }
}
exports.DescribeRelationMetaResponseBody = DescribeRelationMetaResponseBody;
class DescribeRelationMetaResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DescribeRelationMetaResponseBody,
        };
    }
}
exports.DescribeRelationMetaResponse = DescribeRelationMetaResponse;
class GetAllCustomerRecyclesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetAllCustomerRecyclesHeaders = GetAllCustomerRecyclesHeaders;
class GetAllCustomerRecyclesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.GetAllCustomerRecyclesRequest = GetAllCustomerRecyclesRequest;
class GetAllCustomerRecyclesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            resultList: 'resultList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            resultList: { 'type': 'array', 'itemType': GetAllCustomerRecyclesResponseBodyResultList },
        };
    }
}
exports.GetAllCustomerRecyclesResponseBody = GetAllCustomerRecyclesResponseBody;
class GetAllCustomerRecyclesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAllCustomerRecyclesResponseBody,
        };
    }
}
exports.GetAllCustomerRecyclesResponse = GetAllCustomerRecyclesResponse;
class GetCrmGroupChatHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCrmGroupChatHeaders = GetCrmGroupChatHeaders;
class GetCrmGroupChatResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatId: 'chatId',
            gmtCreate: 'gmtCreate',
            iconUrl: 'iconUrl',
            memberCount: 'memberCount',
            name: 'name',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            ownerUserId: 'ownerUserId',
            ownerUserName: 'ownerUserName',
        };
    }
    static types() {
        return {
            chatId: 'string',
            gmtCreate: 'number',
            iconUrl: 'string',
            memberCount: 'number',
            name: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            ownerUserId: 'string',
            ownerUserName: 'string',
        };
    }
}
exports.GetCrmGroupChatResponseBody = GetCrmGroupChatResponseBody;
class GetCrmGroupChatResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCrmGroupChatResponseBody,
        };
    }
}
exports.GetCrmGroupChatResponse = GetCrmGroupChatResponse;
class GetCrmGroupChatMultiHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCrmGroupChatMultiHeaders = GetCrmGroupChatMultiHeaders;
class GetCrmGroupChatMultiRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationIds: 'openConversationIds',
        };
    }
    static types() {
        return {
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetCrmGroupChatMultiRequest = GetCrmGroupChatMultiRequest;
class GetCrmGroupChatMultiResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetCrmGroupChatMultiResponseBodyResult },
        };
    }
}
exports.GetCrmGroupChatMultiResponseBody = GetCrmGroupChatMultiResponseBody;
class GetCrmGroupChatMultiResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCrmGroupChatMultiResponseBody,
        };
    }
}
exports.GetCrmGroupChatMultiResponse = GetCrmGroupChatMultiResponse;
class GetCrmGroupChatSingleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCrmGroupChatSingleHeaders = GetCrmGroupChatSingleHeaders;
class GetCrmGroupChatSingleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
        };
    }
}
exports.GetCrmGroupChatSingleRequest = GetCrmGroupChatSingleRequest;
class GetCrmGroupChatSingleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'gmtCreate',
            iconUrl: 'iconUrl',
            memberCount: 'memberCount',
            name: 'name',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            ownerUserId: 'ownerUserId',
            ownerUserName: 'ownerUserName',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            iconUrl: 'string',
            memberCount: 'number',
            name: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            ownerUserId: 'string',
            ownerUserName: 'string',
        };
    }
}
exports.GetCrmGroupChatSingleResponseBody = GetCrmGroupChatSingleResponseBody;
class GetCrmGroupChatSingleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCrmGroupChatSingleResponseBody,
        };
    }
}
exports.GetCrmGroupChatSingleResponse = GetCrmGroupChatSingleResponse;
class GetCrmRolePermissionHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCrmRolePermissionHeaders = GetCrmRolePermissionHeaders;
class GetCrmRolePermissionRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            resourceId: 'resourceId',
        };
    }
    static types() {
        return {
            bizType: 'string',
            resourceId: 'string',
        };
    }
}
exports.GetCrmRolePermissionRequest = GetCrmRolePermissionRequest;
class GetCrmRolePermissionResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            permissions: 'permissions',
        };
    }
    static types() {
        return {
            permissions: { 'type': 'array', 'itemType': GetCrmRolePermissionResponseBodyPermissions },
        };
    }
}
exports.GetCrmRolePermissionResponseBody = GetCrmRolePermissionResponseBody;
class GetCrmRolePermissionResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCrmRolePermissionResponseBody,
        };
    }
}
exports.GetCrmRolePermissionResponse = GetCrmRolePermissionResponse;
class GetCustomerTracksByRelationIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCustomerTracksByRelationIdHeaders = GetCustomerTracksByRelationIdHeaders;
class GetCustomerTracksByRelationIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            relationId: 'relationId',
            typeGroup: 'typeGroup',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            relationId: 'string',
            typeGroup: 'number',
        };
    }
}
exports.GetCustomerTracksByRelationIdRequest = GetCustomerTracksByRelationIdRequest;
class GetCustomerTracksByRelationIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            resultList: 'resultList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            resultList: { 'type': 'array', 'itemType': GetCustomerTracksByRelationIdResponseBodyResultList },
        };
    }
}
exports.GetCustomerTracksByRelationIdResponseBody = GetCustomerTracksByRelationIdResponseBody;
class GetCustomerTracksByRelationIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCustomerTracksByRelationIdResponseBody,
        };
    }
}
exports.GetCustomerTracksByRelationIdResponse = GetCustomerTracksByRelationIdResponse;
class GetGroupSetHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetGroupSetHeaders = GetGroupSetHeaders;
class GetGroupSetRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openGroupSetId: 'openGroupSetId',
        };
    }
    static types() {
        return {
            openGroupSetId: 'string',
        };
    }
}
exports.GetGroupSetRequest = GetGroupSetRequest;
class GetGroupSetResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            groupChatCount: 'groupChatCount',
            inviteLink: 'inviteLink',
            lastOpenConversationId: 'lastOpenConversationId',
            manager: 'manager',
            managerUserIds: 'managerUserIds',
            memberCount: 'memberCount',
            memberQuota: 'memberQuota',
            name: 'name',
            notice: 'notice',
            noticeToped: 'noticeToped',
            openGroupSetId: 'openGroupSetId',
            owner: 'owner',
            ownerUserId: 'ownerUserId',
            relationType: 'relationType',
            templateId: 'templateId',
        };
    }
    static types() {
        return {
            gmtCreate: 'string',
            gmtModified: 'string',
            groupChatCount: 'number',
            inviteLink: 'string',
            lastOpenConversationId: 'string',
            manager: { 'type': 'array', 'itemType': GetGroupSetResponseBodyManager },
            managerUserIds: 'string',
            memberCount: 'number',
            memberQuota: 'number',
            name: 'string',
            notice: 'string',
            noticeToped: 'number',
            openGroupSetId: 'string',
            owner: GetGroupSetResponseBodyOwner,
            ownerUserId: 'string',
            relationType: 'string',
            templateId: 'string',
        };
    }
}
exports.GetGroupSetResponseBody = GetGroupSetResponseBody;
class GetGroupSetResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetGroupSetResponseBody,
        };
    }
}
exports.GetGroupSetResponse = GetGroupSetResponse;
class GetOfficialAccountContactInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetOfficialAccountContactInfoHeaders = GetOfficialAccountContactInfoHeaders;
class GetOfficialAccountContactInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authItems: 'authItems',
            corpName: 'corpName',
            mobile: 'mobile',
            stateCode: 'stateCode',
            unionId: 'unionId',
            userInfos: 'userInfos',
        };
    }
    static types() {
        return {
            authItems: { 'type': 'array', 'itemType': 'string' },
            corpName: 'string',
            mobile: 'string',
            stateCode: 'string',
            unionId: 'string',
            userInfos: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetOfficialAccountContactInfoResponseBody = GetOfficialAccountContactInfoResponseBody;
class GetOfficialAccountContactInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOfficialAccountContactInfoResponseBody,
        };
    }
}
exports.GetOfficialAccountContactInfoResponse = GetOfficialAccountContactInfoResponse;
class GetOfficialAccountContactsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetOfficialAccountContactsHeaders = GetOfficialAccountContactsHeaders;
class GetOfficialAccountContactsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.GetOfficialAccountContactsRequest = GetOfficialAccountContactsRequest;
class GetOfficialAccountContactsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            values: 'values',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            values: { 'type': 'array', 'itemType': GetOfficialAccountContactsResponseBodyValues },
        };
    }
}
exports.GetOfficialAccountContactsResponseBody = GetOfficialAccountContactsResponseBody;
class GetOfficialAccountContactsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOfficialAccountContactsResponseBody,
        };
    }
}
exports.GetOfficialAccountContactsResponse = GetOfficialAccountContactsResponse;
class GetOfficialAccountOTOMessageResultHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetOfficialAccountOTOMessageResultHeaders = GetOfficialAccountOTOMessageResultHeaders;
class GetOfficialAccountOTOMessageResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            accountId: 'string',
            openPushId: 'string',
        };
    }
}
exports.GetOfficialAccountOTOMessageResultRequest = GetOfficialAccountOTOMessageResultRequest;
class GetOfficialAccountOTOMessageResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: GetOfficialAccountOTOMessageResultResponseBodyResult,
        };
    }
}
exports.GetOfficialAccountOTOMessageResultResponseBody = GetOfficialAccountOTOMessageResultResponseBody;
class GetOfficialAccountOTOMessageResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetOfficialAccountOTOMessageResultResponseBody,
        };
    }
}
exports.GetOfficialAccountOTOMessageResultResponse = GetOfficialAccountOTOMessageResultResponse;
class GetRelationUkSettingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetRelationUkSettingHeaders = GetRelationUkSettingHeaders;
class GetRelationUkSettingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            relationType: 'string',
        };
    }
}
exports.GetRelationUkSettingRequest = GetRelationUkSettingRequest;
class GetRelationUkSettingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetRelationUkSettingResponseBodyResult },
        };
    }
}
exports.GetRelationUkSettingResponseBody = GetRelationUkSettingResponseBody;
class GetRelationUkSettingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetRelationUkSettingResponseBody,
        };
    }
}
exports.GetRelationUkSettingResponse = GetRelationUkSettingResponse;
class JoinGroupSetHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.JoinGroupSetHeaders = JoinGroupSetHeaders;
class JoinGroupSetRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizDataList: 'bizDataList',
            corpId: 'corpId',
            openGroupSetId: 'openGroupSetId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            bizDataList: { 'type': 'array', 'itemType': JoinGroupSetRequestBizDataList },
            corpId: 'string',
            openGroupSetId: 'string',
            unionId: 'string',
        };
    }
}
exports.JoinGroupSetRequest = JoinGroupSetRequest;
class JoinGroupSetResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatId: 'chatId',
            openConversationId: 'openConversationId',
        };
    }
    static types() {
        return {
            chatId: 'string',
            openConversationId: 'string',
        };
    }
}
exports.JoinGroupSetResponseBody = JoinGroupSetResponseBody;
class JoinGroupSetResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: JoinGroupSetResponseBody,
        };
    }
}
exports.JoinGroupSetResponse = JoinGroupSetResponse;
class ListCrmPersonalCustomersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListCrmPersonalCustomersHeaders = ListCrmPersonalCustomersHeaders;
class ListCrmPersonalCustomersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
            currentOperatorUserId: 'currentOperatorUserId',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': 'string' },
            currentOperatorUserId: 'string',
            relationType: 'string',
        };
    }
}
exports.ListCrmPersonalCustomersRequest = ListCrmPersonalCustomersRequest;
class ListCrmPersonalCustomersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': ListCrmPersonalCustomersResponseBodyResult },
        };
    }
}
exports.ListCrmPersonalCustomersResponseBody = ListCrmPersonalCustomersResponseBody;
class ListCrmPersonalCustomersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListCrmPersonalCustomersResponseBody,
        };
    }
}
exports.ListCrmPersonalCustomersResponse = ListCrmPersonalCustomersResponse;
class ListGroupSetHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ListGroupSetHeaders = ListGroupSetHeaders;
class ListGroupSetRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            queryDsl: 'queryDsl',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            queryDsl: 'string',
            relationType: 'string',
        };
    }
}
exports.ListGroupSetRequest = ListGroupSetRequest;
class ListGroupSetResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            resultList: 'resultList',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            resultList: { 'type': 'array', 'itemType': ListGroupSetResponseBodyResultList },
            totalCount: 'number',
        };
    }
}
exports.ListGroupSetResponseBody = ListGroupSetResponseBody;
class ListGroupSetResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ListGroupSetResponseBody,
        };
    }
}
exports.ListGroupSetResponse = ListGroupSetResponse;
class QueryAllCustomerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryAllCustomerHeaders = QueryAllCustomerHeaders;
class QueryAllCustomerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            objectType: 'objectType',
            operatorUserId: 'operatorUserId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            objectType: 'string',
            operatorUserId: 'string',
        };
    }
}
exports.QueryAllCustomerRequest = QueryAllCustomerRequest;
class QueryAllCustomerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: QueryAllCustomerResponseBodyResult,
        };
    }
}
exports.QueryAllCustomerResponseBody = QueryAllCustomerResponseBody;
class QueryAllCustomerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryAllCustomerResponseBody,
        };
    }
}
exports.QueryAllCustomerResponse = QueryAllCustomerResponse;
class QueryAllTracksHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryAllTracksHeaders = QueryAllTracksHeaders;
class QueryAllTracksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            order: 'order',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            order: 'string',
        };
    }
}
exports.QueryAllTracksRequest = QueryAllTracksRequest;
class QueryAllTracksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            values: 'values',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            values: { 'type': 'array', 'itemType': QueryAllTracksResponseBodyValues },
        };
    }
}
exports.QueryAllTracksResponseBody = QueryAllTracksResponseBody;
class QueryAllTracksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryAllTracksResponseBody,
        };
    }
}
exports.QueryAllTracksResponse = QueryAllTracksResponse;
class QueryCrmGroupChatsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCrmGroupChatsHeaders = QueryCrmGroupChatsHeaders;
class QueryCrmGroupChatsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            queryDsl: 'queryDsl',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            queryDsl: 'string',
            relationType: 'string',
        };
    }
}
exports.QueryCrmGroupChatsRequest = QueryCrmGroupChatsRequest;
class QueryCrmGroupChatsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            resultList: 'resultList',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'string',
            resultList: { 'type': 'array', 'itemType': QueryCrmGroupChatsResponseBodyResultList },
            totalCount: 'number',
        };
    }
}
exports.QueryCrmGroupChatsResponseBody = QueryCrmGroupChatsResponseBody;
class QueryCrmGroupChatsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCrmGroupChatsResponseBody,
        };
    }
}
exports.QueryCrmGroupChatsResponse = QueryCrmGroupChatsResponse;
class QueryCrmPersonalCustomerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCrmPersonalCustomerHeaders = QueryCrmPersonalCustomerHeaders;
class QueryCrmPersonalCustomerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            currentOperatorUserId: 'currentOperatorUserId',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            queryDsl: 'queryDsl',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            currentOperatorUserId: 'string',
            maxResults: 'number',
            nextToken: 'string',
            queryDsl: 'string',
            relationType: 'string',
        };
    }
}
exports.QueryCrmPersonalCustomerRequest = QueryCrmPersonalCustomerRequest;
class QueryCrmPersonalCustomerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
            values: 'values',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            maxResults: 'number',
            nextToken: 'string',
            totalCount: 'number',
            values: { 'type': 'array', 'itemType': QueryCrmPersonalCustomerResponseBodyValues },
        };
    }
}
exports.QueryCrmPersonalCustomerResponseBody = QueryCrmPersonalCustomerResponseBody;
class QueryCrmPersonalCustomerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCrmPersonalCustomerResponseBody,
        };
    }
}
exports.QueryCrmPersonalCustomerResponse = QueryCrmPersonalCustomerResponse;
class QueryGlobalInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryGlobalInfoHeaders = QueryGlobalInfoHeaders;
class QueryGlobalInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.QueryGlobalInfoRequest = QueryGlobalInfoRequest;
class QueryGlobalInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: QueryGlobalInfoResponseBodyResult,
        };
    }
}
exports.QueryGlobalInfoResponseBody = QueryGlobalInfoResponseBody;
class QueryGlobalInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryGlobalInfoResponseBody,
        };
    }
}
exports.QueryGlobalInfoResponse = QueryGlobalInfoResponse;
class QueryOfficialAccountUserBasicInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryOfficialAccountUserBasicInfoHeaders = QueryOfficialAccountUserBasicInfoHeaders;
class QueryOfficialAccountUserBasicInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bindingToken: 'bindingToken',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            bindingToken: 'string',
            unionId: 'string',
        };
    }
}
exports.QueryOfficialAccountUserBasicInfoRequest = QueryOfficialAccountUserBasicInfoRequest;
class QueryOfficialAccountUserBasicInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: QueryOfficialAccountUserBasicInfoResponseBodyResult,
        };
    }
}
exports.QueryOfficialAccountUserBasicInfoResponseBody = QueryOfficialAccountUserBasicInfoResponseBody;
class QueryOfficialAccountUserBasicInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryOfficialAccountUserBasicInfoResponseBody,
        };
    }
}
exports.QueryOfficialAccountUserBasicInfoResponse = QueryOfficialAccountUserBasicInfoResponse;
class QueryRelationDatasByTargetIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryRelationDatasByTargetIdHeaders = QueryRelationDatasByTargetIdHeaders;
class QueryRelationDatasByTargetIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            relationType: 'string',
        };
    }
}
exports.QueryRelationDatasByTargetIdRequest = QueryRelationDatasByTargetIdRequest;
class QueryRelationDatasByTargetIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relations: 'relations',
        };
    }
    static types() {
        return {
            relations: { 'type': 'array', 'itemType': QueryRelationDatasByTargetIdResponseBodyRelations },
        };
    }
}
exports.QueryRelationDatasByTargetIdResponseBody = QueryRelationDatasByTargetIdResponseBody;
class QueryRelationDatasByTargetIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryRelationDatasByTargetIdResponseBody,
        };
    }
}
exports.QueryRelationDatasByTargetIdResponse = QueryRelationDatasByTargetIdResponse;
class RecallOfficialAccountOTOMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RecallOfficialAccountOTOMessageHeaders = RecallOfficialAccountOTOMessageHeaders;
class RecallOfficialAccountOTOMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            accountId: 'string',
            openPushId: 'string',
        };
    }
}
exports.RecallOfficialAccountOTOMessageRequest = RecallOfficialAccountOTOMessageRequest;
class RecallOfficialAccountOTOMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.RecallOfficialAccountOTOMessageResponseBody = RecallOfficialAccountOTOMessageResponseBody;
class RecallOfficialAccountOTOMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RecallOfficialAccountOTOMessageResponseBody,
        };
    }
}
exports.RecallOfficialAccountOTOMessageResponse = RecallOfficialAccountOTOMessageResponse;
class SendOfficialAccountOTOMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageHeaders = SendOfficialAccountOTOMessageHeaders;
class SendOfficialAccountOTOMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            accountId: 'accountId',
            bizId: 'bizId',
            detail: 'detail',
        };
    }
    static types() {
        return {
            accountId: 'string',
            bizId: 'string',
            detail: SendOfficialAccountOTOMessageRequestDetail,
        };
    }
}
exports.SendOfficialAccountOTOMessageRequest = SendOfficialAccountOTOMessageRequest;
class SendOfficialAccountOTOMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: SendOfficialAccountOTOMessageResponseBodyResult,
        };
    }
}
exports.SendOfficialAccountOTOMessageResponseBody = SendOfficialAccountOTOMessageResponseBody;
class SendOfficialAccountOTOMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendOfficialAccountOTOMessageResponseBody,
        };
    }
}
exports.SendOfficialAccountOTOMessageResponse = SendOfficialAccountOTOMessageResponse;
class SendOfficialAccountSNSMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageHeaders = SendOfficialAccountSNSMessageHeaders;
class SendOfficialAccountSNSMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bindingToken: 'bindingToken',
            bizId: 'bizId',
            detail: 'detail',
        };
    }
    static types() {
        return {
            bindingToken: 'string',
            bizId: 'string',
            detail: SendOfficialAccountSNSMessageRequestDetail,
        };
    }
}
exports.SendOfficialAccountSNSMessageRequest = SendOfficialAccountSNSMessageRequest;
class SendOfficialAccountSNSMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: SendOfficialAccountSNSMessageResponseBodyResult,
        };
    }
}
exports.SendOfficialAccountSNSMessageResponseBody = SendOfficialAccountSNSMessageResponseBody;
class SendOfficialAccountSNSMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendOfficialAccountSNSMessageResponseBody,
        };
    }
}
exports.SendOfficialAccountSNSMessageResponse = SendOfficialAccountSNSMessageResponse;
class ServiceWindowMessageBatchPushHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushHeaders = ServiceWindowMessageBatchPushHeaders;
class ServiceWindowMessageBatchPushRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'bizId',
            detail: 'detail',
        };
    }
    static types() {
        return {
            bizId: 'string',
            detail: ServiceWindowMessageBatchPushRequestDetail,
        };
    }
}
exports.ServiceWindowMessageBatchPushRequest = ServiceWindowMessageBatchPushRequest;
class ServiceWindowMessageBatchPushResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
            result: 'result',
        };
    }
    static types() {
        return {
            requestId: 'string',
            result: ServiceWindowMessageBatchPushResponseBodyResult,
        };
    }
}
exports.ServiceWindowMessageBatchPushResponseBody = ServiceWindowMessageBatchPushResponseBody;
class ServiceWindowMessageBatchPushResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ServiceWindowMessageBatchPushResponseBody,
        };
    }
}
exports.ServiceWindowMessageBatchPushResponse = ServiceWindowMessageBatchPushResponse;
class UpdateCrmPersonalCustomerHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateCrmPersonalCustomerHeaders = UpdateCrmPersonalCustomerHeaders;
class UpdateCrmPersonalCustomerRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            data: 'data',
            extendData: 'extendData',
            instanceId: 'instanceId',
            modifierNick: 'modifierNick',
            modifierUserId: 'modifierUserId',
            permission: 'permission',
            relationType: 'relationType',
            skipDuplicateCheck: 'skipDuplicateCheck',
        };
    }
    static types() {
        return {
            action: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            instanceId: 'string',
            modifierNick: 'string',
            modifierUserId: 'string',
            permission: UpdateCrmPersonalCustomerRequestPermission,
            relationType: 'string',
            skipDuplicateCheck: 'boolean',
        };
    }
}
exports.UpdateCrmPersonalCustomerRequest = UpdateCrmPersonalCustomerRequest;
class UpdateCrmPersonalCustomerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            instanceId: 'instanceId',
        };
    }
    static types() {
        return {
            instanceId: 'string',
        };
    }
}
exports.UpdateCrmPersonalCustomerResponseBody = UpdateCrmPersonalCustomerResponseBody;
class UpdateCrmPersonalCustomerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateCrmPersonalCustomerResponseBody,
        };
    }
}
exports.UpdateCrmPersonalCustomerResponse = UpdateCrmPersonalCustomerResponse;
class UpdateGroupSetHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateGroupSetHeaders = UpdateGroupSetHeaders;
class UpdateGroupSetRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            managerUserIds: 'managerUserIds',
            memberQuota: 'memberQuota',
            name: 'name',
            notice: 'notice',
            noticeToped: 'noticeToped',
            openGroupSetId: 'openGroupSetId',
            ownerUserId: 'ownerUserId',
            templateId: 'templateId',
            welcome: 'welcome',
        };
    }
    static types() {
        return {
            managerUserIds: 'string',
            memberQuota: 'number',
            name: 'string',
            notice: 'string',
            noticeToped: 'number',
            openGroupSetId: 'string',
            ownerUserId: 'string',
            templateId: 'string',
            welcome: 'string',
        };
    }
}
exports.UpdateGroupSetRequest = UpdateGroupSetRequest;
class UpdateGroupSetResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: 'boolean',
        };
    }
}
exports.UpdateGroupSetResponse = UpdateGroupSetResponse;
class UpdateRelationMetaFieldHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateRelationMetaFieldHeaders = UpdateRelationMetaFieldHeaders;
class UpdateRelationMetaFieldRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldDTOList: 'fieldDTOList',
            operatorUserId: 'operatorUserId',
            relationType: 'relationType',
            tenant: 'tenant',
        };
    }
    static types() {
        return {
            fieldDTOList: { 'type': 'array', 'itemType': UpdateRelationMetaFieldRequestFieldDTOList },
            operatorUserId: 'string',
            relationType: 'string',
            tenant: 'string',
        };
    }
}
exports.UpdateRelationMetaFieldRequest = UpdateRelationMetaFieldRequest;
class UpdateRelationMetaFieldResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            relationType: 'string',
        };
    }
}
exports.UpdateRelationMetaFieldResponseBody = UpdateRelationMetaFieldResponseBody;
class UpdateRelationMetaFieldResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateRelationMetaFieldResponseBody,
        };
    }
}
exports.UpdateRelationMetaFieldResponse = UpdateRelationMetaFieldResponse;
class AddCrmPersonalCustomerRequestPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerStaffIds: 'ownerStaffIds',
            participantStaffIds: 'participantStaffIds',
        };
    }
    static types() {
        return {
            ownerStaffIds: { 'type': 'array', 'itemType': 'string' },
            participantStaffIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.AddCrmPersonalCustomerRequestPermission = AddCrmPersonalCustomerRequestPermission;
class AddLeadsRequestLeads extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            leadsName: 'leadsName',
            outLeadsId: 'outLeadsId',
        };
    }
    static types() {
        return {
            leadsName: 'string',
            outLeadsId: 'string',
        };
    }
}
exports.AddLeadsRequestLeads = AddLeadsRequestLeads;
class AddRelationMetaFieldRequestFieldDTOListPropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.AddRelationMetaFieldRequestFieldDTOListPropsOptions = AddRelationMetaFieldRequestFieldDTOListPropsOptions;
class AddRelationMetaFieldRequestFieldDTOListProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            align: 'align',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            disabled: 'disabled',
            duration: 'duration',
            fieldId: 'fieldId',
            format: 'format',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            link: 'link',
            needDetail: 'needDetail',
            notPrint: 'notPrint',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            sortable: 'sortable',
            unit: 'unit',
        };
    }
    static types() {
        return {
            align: 'string',
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            disabled: 'boolean',
            duration: 'boolean',
            fieldId: 'string',
            format: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            link: 'string',
            needDetail: 'string',
            notPrint: 'string',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': AddRelationMetaFieldRequestFieldDTOListPropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            sortable: 'boolean',
            unit: 'string',
        };
    }
}
exports.AddRelationMetaFieldRequestFieldDTOListProps = AddRelationMetaFieldRequestFieldDTOListProps;
class AddRelationMetaFieldRequestFieldDTOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            props: 'props',
        };
    }
    static types() {
        return {
            componentName: 'string',
            props: AddRelationMetaFieldRequestFieldDTOListProps,
        };
    }
}
exports.AddRelationMetaFieldRequestFieldDTOList = AddRelationMetaFieldRequestFieldDTOList;
class BatchAddContactsRequestRelationListBizDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.BatchAddContactsRequestRelationListBizDataList = BatchAddContactsRequestRelationListBizDataList;
class BatchAddContactsRequestRelationList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizDataList: 'bizDataList',
            bizExtMap: 'bizExtMap',
        };
    }
    static types() {
        return {
            bizDataList: { 'type': 'array', 'itemType': BatchAddContactsRequestRelationListBizDataList },
            bizExtMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.BatchAddContactsRequestRelationList = BatchAddContactsRequestRelationList;
class BatchAddContactsResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            relationId: 'relationId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            relationId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchAddContactsResponseBodyResults = BatchAddContactsResponseBodyResults;
class BatchAddFollowRecordsRequestInstanceListDataArray extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.BatchAddFollowRecordsRequestInstanceListDataArray = BatchAddFollowRecordsRequestInstanceListDataArray;
class BatchAddFollowRecordsRequestInstanceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataArray: 'dataArray',
        };
    }
    static types() {
        return {
            dataArray: { 'type': 'array', 'itemType': BatchAddFollowRecordsRequestInstanceListDataArray },
        };
    }
}
exports.BatchAddFollowRecordsRequestInstanceList = BatchAddFollowRecordsRequestInstanceList;
class BatchAddFollowRecordsResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            instanceId: 'instanceId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            instanceId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchAddFollowRecordsResponseBodyResults = BatchAddFollowRecordsResponseBodyResults;
class BatchAddRelationDatasRequestRelationListBizDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.BatchAddRelationDatasRequestRelationListBizDataList = BatchAddRelationDatasRequestRelationListBizDataList;
class BatchAddRelationDatasRequestRelationListRelationPermissionDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            participantUserIds: 'participantUserIds',
            principalUserIds: 'principalUserIds',
        };
    }
    static types() {
        return {
            participantUserIds: { 'type': 'array', 'itemType': 'string' },
            principalUserIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.BatchAddRelationDatasRequestRelationListRelationPermissionDTO = BatchAddRelationDatasRequestRelationListRelationPermissionDTO;
class BatchAddRelationDatasRequestRelationList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizDataList: 'bizDataList',
            bizExtMap: 'bizExtMap',
            relationPermissionDTO: 'relationPermissionDTO',
        };
    }
    static types() {
        return {
            bizDataList: { 'type': 'array', 'itemType': BatchAddRelationDatasRequestRelationListBizDataList },
            bizExtMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            relationPermissionDTO: BatchAddRelationDatasRequestRelationListRelationPermissionDTO,
        };
    }
}
exports.BatchAddRelationDatasRequestRelationList = BatchAddRelationDatasRequestRelationList;
class BatchAddRelationDatasResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duplicatedRelationIds: 'duplicatedRelationIds',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            relationId: 'relationId',
            success: 'success',
        };
    }
    static types() {
        return {
            duplicatedRelationIds: { 'type': 'array', 'itemType': 'string' },
            errorCode: 'string',
            errorMsg: 'string',
            relationId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchAddRelationDatasResponseBodyResults = BatchAddRelationDatasResponseBodyResults;
class BatchRemoveFollowRecordsResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            instanceId: 'instanceId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            instanceId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchRemoveFollowRecordsResponseBodyResults = BatchRemoveFollowRecordsResponseBodyResults;
class BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionUrl: 'actionUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            actionUrl: 'string',
            title: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList = BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList;
class BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            buttonList: 'buttonList',
            buttonOrientation: 'buttonOrientation',
            markdown: 'markdown',
            singleTitle: 'singleTitle',
            singleUrl: 'singleUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            buttonList: { 'type': 'array', 'itemType': BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList },
            buttonOrientation: 'string',
            markdown: 'string',
            singleTitle: 'string',
            singleUrl: 'string',
            title: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard = BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard;
class BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyLink extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageUrl: 'messageUrl',
            picUrl: 'picUrl',
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            messageUrl: 'string',
            picUrl: 'string',
            text: 'string',
            title: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyLink = BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyLink;
class BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            text: 'string',
            title: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown = BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown;
class BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyText extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyText = BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyText;
class BatchSendOfficialAccountOTOMessageRequestDetailMessageBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionCard: 'actionCard',
            link: 'link',
            markdown: 'markdown',
            text: 'text',
        };
    }
    static types() {
        return {
            actionCard: BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard,
            link: BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyLink,
            markdown: BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown,
            text: BatchSendOfficialAccountOTOMessageRequestDetailMessageBodyText,
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequestDetailMessageBody = BatchSendOfficialAccountOTOMessageRequestDetailMessageBody;
class BatchSendOfficialAccountOTOMessageRequestDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizRequestId: 'bizRequestId',
            messageBody: 'messageBody',
            msgType: 'msgType',
            sendToAll: 'sendToAll',
            userIdList: 'userIdList',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            bizRequestId: 'string',
            messageBody: BatchSendOfficialAccountOTOMessageRequestDetailMessageBody,
            msgType: 'string',
            sendToAll: 'boolean',
            userIdList: { 'type': 'array', 'itemType': 'string' },
            uuid: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageRequestDetail = BatchSendOfficialAccountOTOMessageRequestDetail;
class BatchSendOfficialAccountOTOMessageResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            openPushId: 'string',
        };
    }
}
exports.BatchSendOfficialAccountOTOMessageResponseBodyResult = BatchSendOfficialAccountOTOMessageResponseBodyResult;
class BatchUpdateContactsRequestRelationListBizDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.BatchUpdateContactsRequestRelationListBizDataList = BatchUpdateContactsRequestRelationListBizDataList;
class BatchUpdateContactsRequestRelationList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizDataList: 'bizDataList',
            bizExtMap: 'bizExtMap',
            relationId: 'relationId',
        };
    }
    static types() {
        return {
            bizDataList: { 'type': 'array', 'itemType': BatchUpdateContactsRequestRelationListBizDataList },
            bizExtMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            relationId: 'string',
        };
    }
}
exports.BatchUpdateContactsRequestRelationList = BatchUpdateContactsRequestRelationList;
class BatchUpdateContactsResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            relationId: 'relationId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            relationId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchUpdateContactsResponseBodyResults = BatchUpdateContactsResponseBodyResults;
class BatchUpdateFollowRecordsRequestInstanceListDataArray extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.BatchUpdateFollowRecordsRequestInstanceListDataArray = BatchUpdateFollowRecordsRequestInstanceListDataArray;
class BatchUpdateFollowRecordsRequestInstanceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dataArray: 'dataArray',
            instanceId: 'instanceId',
        };
    }
    static types() {
        return {
            dataArray: { 'type': 'array', 'itemType': BatchUpdateFollowRecordsRequestInstanceListDataArray },
            instanceId: 'string',
        };
    }
}
exports.BatchUpdateFollowRecordsRequestInstanceList = BatchUpdateFollowRecordsRequestInstanceList;
class BatchUpdateFollowRecordsResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            instanceId: 'instanceId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            instanceId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchUpdateFollowRecordsResponseBodyResults = BatchUpdateFollowRecordsResponseBodyResults;
class BatchUpdateRelationDatasRequestRelationListBizDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.BatchUpdateRelationDatasRequestRelationListBizDataList = BatchUpdateRelationDatasRequestRelationListBizDataList;
class BatchUpdateRelationDatasRequestRelationList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizDataList: 'bizDataList',
            bizExtMap: 'bizExtMap',
            relationId: 'relationId',
        };
    }
    static types() {
        return {
            bizDataList: { 'type': 'array', 'itemType': BatchUpdateRelationDatasRequestRelationListBizDataList },
            bizExtMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            relationId: 'string',
        };
    }
}
exports.BatchUpdateRelationDatasRequestRelationList = BatchUpdateRelationDatasRequestRelationList;
class BatchUpdateRelationDatasResponseBodyResults extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duplicatedRelationIds: 'duplicatedRelationIds',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            relationId: 'relationId',
            success: 'success',
        };
    }
    static types() {
        return {
            duplicatedRelationIds: { 'type': 'array', 'itemType': 'string' },
            errorCode: 'string',
            errorMsg: 'string',
            relationId: 'string',
            success: 'boolean',
        };
    }
}
exports.BatchUpdateRelationDatasResponseBodyResults = BatchUpdateRelationDatasResponseBodyResults;
class CreateCustomerRequestContacts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
            extendData: 'extendData',
        };
    }
    static types() {
        return {
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.CreateCustomerRequestContacts = CreateCustomerRequestContacts;
class CreateCustomerRequestPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerStaffIds: 'ownerStaffIds',
            participantStaffIds: 'participantStaffIds',
        };
    }
    static types() {
        return {
            ownerStaffIds: { 'type': 'array', 'itemType': 'string' },
            participantStaffIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.CreateCustomerRequestPermission = CreateCustomerRequestPermission;
class CreateCustomerRequestSaveOption extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customerExistedPolicy: 'customerExistedPolicy',
            skipDuplicateCheck: 'skipDuplicateCheck',
            subscribePolicy: 'subscribePolicy',
            throwExceptionWhileSavingContactFailed: 'throwExceptionWhileSavingContactFailed',
        };
    }
    static types() {
        return {
            customerExistedPolicy: 'string',
            skipDuplicateCheck: 'boolean',
            subscribePolicy: 'number',
            throwExceptionWhileSavingContactFailed: 'boolean',
        };
    }
}
exports.CreateCustomerRequestSaveOption = CreateCustomerRequestSaveOption;
class CreateCustomerResponseBodyContacts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contactInstanceId: 'contactInstanceId',
        };
    }
    static types() {
        return {
            contactInstanceId: 'string',
        };
    }
}
exports.CreateCustomerResponseBodyContacts = CreateCustomerResponseBodyContacts;
class CreateGroupSetResponseBodyManager extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.CreateGroupSetResponseBodyManager = CreateGroupSetResponseBodyManager;
class CreateGroupSetResponseBodyOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.CreateGroupSetResponseBodyOwner = CreateGroupSetResponseBodyOwner;
class CreateRelationMetaRequestRelationMetaDTOItemsPropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.CreateRelationMetaRequestRelationMetaDTOItemsPropsOptions = CreateRelationMetaRequestRelationMetaDTOItemsPropsOptions;
class CreateRelationMetaRequestRelationMetaDTOItemsProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            align: 'align',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            disabled: 'disabled',
            duration: 'duration',
            fieldId: 'fieldId',
            format: 'format',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            link: 'link',
            needDetail: 'needDetail',
            notPrint: 'notPrint',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            sortable: 'sortable',
            unit: 'unit',
        };
    }
    static types() {
        return {
            align: 'string',
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            disabled: 'boolean',
            duration: 'boolean',
            fieldId: 'string',
            format: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            link: 'string',
            needDetail: 'string',
            notPrint: 'string',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': CreateRelationMetaRequestRelationMetaDTOItemsPropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            sortable: 'boolean',
            unit: 'string',
        };
    }
}
exports.CreateRelationMetaRequestRelationMetaDTOItemsProps = CreateRelationMetaRequestRelationMetaDTOItemsProps;
class CreateRelationMetaRequestRelationMetaDTOItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            props: 'props',
        };
    }
    static types() {
        return {
            componentName: 'string',
            props: CreateRelationMetaRequestRelationMetaDTOItemsProps,
        };
    }
}
exports.CreateRelationMetaRequestRelationMetaDTOItems = CreateRelationMetaRequestRelationMetaDTOItems;
class CreateRelationMetaRequestRelationMetaDTO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            desc: 'desc',
            items: 'items',
            name: 'name',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            desc: 'string',
            items: { 'type': 'array', 'itemType': CreateRelationMetaRequestRelationMetaDTOItems },
            name: 'string',
            relationType: 'string',
        };
    }
}
exports.CreateRelationMetaRequestRelationMetaDTO = CreateRelationMetaRequestRelationMetaDTO;
class DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFieldsSelectOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFieldsSelectOptions = DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFieldsSelectOptions;
class DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFields extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            format: 'format',
            label: 'label',
            name: 'name',
            nillable: 'nillable',
            selectOptions: 'selectOptions',
            type: 'type',
            unit: 'unit',
        };
    }
    static types() {
        return {
            format: 'string',
            label: 'string',
            name: 'string',
            nillable: 'boolean',
            selectOptions: { 'type': 'array', 'itemType': DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFieldsSelectOptions },
            type: 'string',
            unit: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFields = DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFields;
class DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsRollUpSummaryFields extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            aggregator: 'aggregator',
            name: 'name',
        };
    }
    static types() {
        return {
            aggregator: 'string',
            name: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsRollUpSummaryFields = DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsRollUpSummaryFields;
class DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsSelectOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsSelectOptions = DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsSelectOptions;
class DescribeCrmPersonalCustomerObjectMetaResponseBodyFields extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customized: 'customized',
            format: 'format',
            label: 'label',
            name: 'name',
            nillable: 'nillable',
            quote: 'quote',
            referenceFields: 'referenceFields',
            referenceTo: 'referenceTo',
            rollUpSummaryFields: 'rollUpSummaryFields',
            selectOptions: 'selectOptions',
            type: 'type',
            unit: 'unit',
        };
    }
    static types() {
        return {
            customized: 'boolean',
            format: 'string',
            label: 'string',
            name: 'string',
            nillable: 'boolean',
            quote: 'boolean',
            referenceFields: { 'type': 'array', 'itemType': DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsReferenceFields },
            referenceTo: 'string',
            rollUpSummaryFields: { 'type': 'array', 'itemType': DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsRollUpSummaryFields },
            selectOptions: { 'type': 'array', 'itemType': DescribeCrmPersonalCustomerObjectMetaResponseBodyFieldsSelectOptions },
            type: 'string',
            unit: 'string',
        };
    }
}
exports.DescribeCrmPersonalCustomerObjectMetaResponseBodyFields = DescribeCrmPersonalCustomerObjectMetaResponseBodyFields;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsAvailableTemplates extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsAvailableTemplates = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsAvailableTemplates;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParamsFilters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            filterType: 'filterType',
            value: 'value',
            valueType: 'valueType',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            filterType: 'string',
            value: 'string',
            valueType: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParamsFilters = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParamsFilters;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            filters: 'filters',
        };
    }
    static types() {
        return {
            filters: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParamsFilters },
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParams = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParams;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appType: 'appType',
            appUuid: 'appUuid',
            bizType: 'bizType',
            formCode: 'formCode',
        };
    }
    static types() {
        return {
            appType: 'number',
            appUuid: 'string',
            bizType: 'string',
            formCode: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceTarget = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceTarget;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            params: 'params',
            target: 'target',
            type: 'type',
        };
    }
    static types() {
        return {
            params: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceParams,
            target: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSourceTarget,
            type: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSource = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSource;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptionsExtension extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            editFreeze: 'editFreeze',
        };
    }
    static types() {
        return {
            editFreeze: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptionsExtension = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptionsExtension;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extension: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptionsExtension,
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptions = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptions;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsStatField extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            label: 'label',
            unit: 'unit',
            upper: 'upper',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            label: 'string',
            unit: 'string',
            upper: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsStatField = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsStatField;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelateProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            align: 'align',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            disabled: 'disabled',
            duration: 'duration',
            durationLabel: 'durationLabel',
            fieldId: 'fieldId',
            format: 'format',
            formula: 'formula',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            limit: 'limit',
            link: 'link',
            mode: 'mode',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            ratio: 'ratio',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            spread: 'spread',
            statField: 'statField',
            unit: 'unit',
            verticalPrint: 'verticalPrint',
            watermark: 'watermark',
        };
    }
    static types() {
        return {
            align: 'string',
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            disabled: 'boolean',
            duration: 'boolean',
            durationLabel: 'string',
            fieldId: 'string',
            format: 'string',
            formula: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            limit: 'number',
            link: 'string',
            mode: 'string',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            ratio: 'number',
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            spread: 'boolean',
            statField: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelatePropsStatField },
            unit: 'string',
            verticalPrint: 'boolean',
            watermark: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelateProps = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelateProps;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFields extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            relateProps: 'relateProps',
        };
    }
    static types() {
        return {
            componentName: 'string',
            relateProps: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFieldsRelateProps,
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFields = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFields;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptionsExtension extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            editFreeze: 'editFreeze',
        };
    }
    static types() {
        return {
            editFreeze: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptionsExtension = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptionsExtension;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extension: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptionsExtension,
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptions = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptions;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParamsFilters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            filterType: 'filterType',
            value: 'value',
            valueType: 'valueType',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            filterType: 'string',
            value: 'string',
            valueType: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParamsFilters = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParamsFilters;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            filters: 'filters',
        };
    }
    static types() {
        return {
            filters: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParamsFilters },
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParams = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParams;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appType: 'appType',
            appUuid: 'appUuid',
            bizType: 'bizType',
            formCode: 'formCode',
        };
    }
    static types() {
        return {
            appType: 'number',
            appUuid: 'string',
            bizType: 'string',
            formCode: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceTarget = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceTarget;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            params: 'params',
            target: 'target',
            type: 'type',
        };
    }
    static types() {
        return {
            params: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceParams,
            target: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSourceTarget,
            type: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSource = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSource;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsOptions = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsOptions;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsStatField extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            label: 'label',
            unit: 'unit',
            upper: 'upper',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            label: 'string',
            unit: 'string',
            upper: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsStatField = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsStatField;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelateProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            align: 'align',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            disabled: 'disabled',
            duration: 'duration',
            fieldId: 'fieldId',
            format: 'format',
            formula: 'formula',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            link: 'link',
            multi: 'multi',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            quote: 'quote',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            statField: 'statField',
            unit: 'unit',
            verticalPrint: 'verticalPrint',
        };
    }
    static types() {
        return {
            align: 'string',
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            disabled: 'boolean',
            duration: 'string',
            fieldId: 'string',
            format: 'string',
            formula: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            link: 'string',
            multi: 'number',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            quote: 'number',
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            statField: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelatePropsStatField },
            unit: 'string',
            verticalPrint: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelateProps = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelateProps;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFields extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            relateProps: 'relateProps',
        };
    }
    static types() {
        return {
            componentName: 'string',
            relateProps: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFieldsRelateProps,
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFields = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFields;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            dataSource: 'dataSource',
            fields: 'fields',
        };
    }
    static types() {
        return {
            bizType: 'string',
            dataSource: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceDataSource,
            fields: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSourceFields },
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSource = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSource;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRule = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRule;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsStatField extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            label: 'label',
            unit: 'unit',
            upper: 'upper',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            label: 'string',
            unit: 'string',
            upper: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsStatField = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsStatField;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionName: 'actionName',
            align: 'align',
            availableTemplates: 'availableTemplates',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            dataSource: 'dataSource',
            defaultColor: 'defaultColor',
            disabled: 'disabled',
            duration: 'duration',
            durationLabel: 'durationLabel',
            fieldId: 'fieldId',
            fields: 'fields',
            format: 'format',
            formula: 'formula',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            limit: 'limit',
            link: 'link',
            mode: 'mode',
            multiple: 'multiple',
            notPrint: 'notPrint',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            quote: 'quote',
            ratio: 'ratio',
            relateSource: 'relateSource',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            rule: 'rule',
            sortable: 'sortable',
            spread: 'spread',
            statField: 'statField',
            tableViewMode: 'tableViewMode',
            unit: 'unit',
            verticalPrint: 'verticalPrint',
            watermark: 'watermark',
        };
    }
    static types() {
        return {
            actionName: 'string',
            align: 'string',
            availableTemplates: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsAvailableTemplates },
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            dataSource: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsDataSource,
            defaultColor: 'string',
            disabled: 'boolean',
            duration: 'boolean',
            durationLabel: 'string',
            fieldId: 'string',
            fields: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsFields },
            format: 'string',
            formula: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            limit: 'number',
            link: 'string',
            mode: 'string',
            multiple: 'boolean',
            notPrint: 'string',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            quote: 'number',
            ratio: 'number',
            relateSource: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRelateSource },
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            rule: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsRule },
            sortable: 'boolean',
            spread: 'boolean',
            statField: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenPropsStatField },
            tableViewMode: 'string',
            unit: 'string',
            verticalPrint: 'boolean',
            watermark: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenProps = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenProps;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildren extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            props: 'props',
        };
    }
    static types() {
        return {
            componentName: 'string',
            props: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildrenProps,
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildren = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildren;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsAvailableTemplates extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            id: 'id',
            name: 'name',
        };
    }
    static types() {
        return {
            id: 'string',
            name: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsAvailableTemplates = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsAvailableTemplates;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParamsFilters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            filterType: 'filterType',
            value: 'value',
            valueType: 'valueType',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            filterType: 'string',
            value: 'string',
            valueType: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParamsFilters = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParamsFilters;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            filters: 'filters',
        };
    }
    static types() {
        return {
            filters: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParamsFilters },
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParams = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParams;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appType: 'appType',
            appUuid: 'appUuid',
            bizType: 'bizType',
            formCode: 'formCode',
        };
    }
    static types() {
        return {
            appType: 'number',
            appUuid: 'string',
            bizType: 'string',
            formCode: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceTarget = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceTarget;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            params: 'params',
            target: 'target',
            type: 'type',
        };
    }
    static types() {
        return {
            params: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceParams,
            target: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSourceTarget,
            type: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSource = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSource;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptionsExtension extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            editFreeze: 'editFreeze',
        };
    }
    static types() {
        return {
            editFreeze: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptionsExtension = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptionsExtension;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extension: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptionsExtension,
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptions = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptions;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsStatField extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            label: 'label',
            unit: 'unit',
            upper: 'upper',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            label: 'string',
            unit: 'string',
            upper: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsStatField = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsStatField;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelateProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            align: 'align',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            disabled: 'disabled',
            duration: 'duration',
            durationLabel: 'durationLabel',
            fieldId: 'fieldId',
            format: 'format',
            formula: 'formula',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            limit: 'limit',
            link: 'link',
            mode: 'mode',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            ratio: 'ratio',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            spread: 'spread',
            statField: 'statField',
            unit: 'unit',
            verticalPrint: 'verticalPrint',
            watermark: 'watermark',
        };
    }
    static types() {
        return {
            align: 'string',
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            disabled: 'boolean',
            duration: 'string',
            durationLabel: 'string',
            fieldId: 'string',
            format: 'string',
            formula: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            limit: 'number',
            link: 'string',
            mode: 'string',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            ratio: 'number',
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            spread: 'boolean',
            statField: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelatePropsStatField },
            unit: 'string',
            verticalPrint: 'boolean',
            watermark: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelateProps = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelateProps;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFields extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            relateProps: 'relateProps',
        };
    }
    static types() {
        return {
            componentName: 'string',
            relateProps: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFieldsRelateProps,
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFields = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFields;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptionsExtension extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            editFreeze: 'editFreeze',
        };
    }
    static types() {
        return {
            editFreeze: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptionsExtension = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptionsExtension;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            key: 'key',
            value: 'value',
            warn: 'warn',
        };
    }
    static types() {
        return {
            extension: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptionsExtension,
            key: 'string',
            value: 'string',
            warn: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptions = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptions;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParamsFilters extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            filterType: 'filterType',
            value: 'value',
            valueType: 'valueType',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            filterType: 'string',
            value: 'string',
            valueType: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParamsFilters = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParamsFilters;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            filters: 'filters',
        };
    }
    static types() {
        return {
            filters: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParamsFilters },
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParams = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParams;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceTarget extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appType: 'appType',
            appUuid: 'appUuid',
            bizType: 'bizType',
            formCode: 'formCode',
        };
    }
    static types() {
        return {
            appType: 'number',
            appUuid: 'string',
            bizType: 'string',
            formCode: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceTarget = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceTarget;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            params: 'params',
            target: 'target',
            type: 'type',
        };
    }
    static types() {
        return {
            params: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceParams,
            target: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSourceTarget,
            type: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSource = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSource;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptionsExtension extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            editFreeze: 'editFreeze',
        };
    }
    static types() {
        return {
            editFreeze: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptionsExtension = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptionsExtension;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extension: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptionsExtension,
            key: 'string',
            value: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptions = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptions;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsStatField extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            label: 'label',
            unit: 'unit',
            upper: 'upper',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            label: 'string',
            unit: 'string',
            upper: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsStatField = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsStatField;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelateProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            align: 'align',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            disabled: 'disabled',
            duration: 'duration',
            fieldId: 'fieldId',
            format: 'format',
            formula: 'formula',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            link: 'link',
            multi: 'multi',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            quote: 'quote',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            statField: 'statField',
            unit: 'unit',
            verticalPrint: 'verticalPrint',
        };
    }
    static types() {
        return {
            align: 'string',
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            disabled: 'boolean',
            duration: 'string',
            fieldId: 'string',
            format: 'string',
            formula: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            link: 'string',
            multi: 'number',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            quote: 'number',
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            statField: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelatePropsStatField },
            unit: 'string',
            verticalPrint: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelateProps = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelateProps;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFields extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            relateProps: 'relateProps',
        };
    }
    static types() {
        return {
            componentName: 'string',
            relateProps: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFieldsRelateProps,
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFields = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFields;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSource extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizType: 'bizType',
            dataSource: 'dataSource',
            fields: 'fields',
        };
    }
    static types() {
        return {
            bizType: 'string',
            dataSource: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceDataSource,
            fields: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSourceFields },
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSource = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSource;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRule extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            type: 'type',
            value: 'value',
        };
    }
    static types() {
        return {
            type: 'string',
            value: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRule = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRule;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsStatField extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldId: 'fieldId',
            label: 'label',
            unit: 'unit',
            upper: 'upper',
        };
    }
    static types() {
        return {
            fieldId: 'string',
            label: 'string',
            unit: 'string',
            upper: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsStatField = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsStatField;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItemsProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionName: 'actionName',
            align: 'align',
            availableTemplates: 'availableTemplates',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            dataSource: 'dataSource',
            defaultColor: 'defaultColor',
            disabled: 'disabled',
            duration: 'duration',
            durationLabel: 'durationLabel',
            fieldId: 'fieldId',
            fields: 'fields',
            format: 'format',
            formula: 'formula',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            limit: 'limit',
            link: 'link',
            mode: 'mode',
            multi: 'multi',
            multiple: 'multiple',
            needDetail: 'needDetail',
            notPrint: 'notPrint',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            quote: 'quote',
            ratio: 'ratio',
            relateSource: 'relateSource',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            rule: 'rule',
            sortable: 'sortable',
            spread: 'spread',
            statField: 'statField',
            tableViewMode: 'tableViewMode',
            unit: 'unit',
            verticalPrint: 'verticalPrint',
            watermark: 'watermark',
        };
    }
    static types() {
        return {
            actionName: 'string',
            align: 'string',
            availableTemplates: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsAvailableTemplates },
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            dataSource: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsDataSource,
            defaultColor: 'string',
            disabled: 'boolean',
            duration: 'boolean',
            durationLabel: 'string',
            fieldId: 'string',
            fields: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsFields },
            format: 'string',
            formula: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            limit: 'number',
            link: 'string',
            mode: 'string',
            multi: 'number',
            multiple: 'boolean',
            needDetail: 'string',
            notPrint: 'string',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            quote: 'number',
            ratio: 'number',
            relateSource: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRelateSource },
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            rule: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsRule },
            sortable: 'boolean',
            spread: 'boolean',
            statField: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsPropsStatField },
            tableViewMode: 'string',
            unit: 'string',
            verticalPrint: 'boolean',
            watermark: 'boolean',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItemsProps = DescribeRelationMetaResponseBodyRelationMetaDTOListItemsProps;
class DescribeRelationMetaResponseBodyRelationMetaDTOListItems extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            children: 'children',
            componentName: 'componentName',
            props: 'props',
        };
    }
    static types() {
        return {
            children: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItemsChildren },
            componentName: 'string',
            props: DescribeRelationMetaResponseBodyRelationMetaDTOListItemsProps,
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOListItems = DescribeRelationMetaResponseBodyRelationMetaDTOListItems;
class DescribeRelationMetaResponseBodyRelationMetaDTOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorUserId: 'creatorUserId',
            desc: 'desc',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            items: 'items',
            name: 'name',
            relationMetaCode: 'relationMetaCode',
            relationMetaStatus: 'relationMetaStatus',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            creatorUserId: 'string',
            desc: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            items: { 'type': 'array', 'itemType': DescribeRelationMetaResponseBodyRelationMetaDTOListItems },
            name: 'string',
            relationMetaCode: 'string',
            relationMetaStatus: 'string',
            relationType: 'string',
        };
    }
}
exports.DescribeRelationMetaResponseBodyRelationMetaDTOList = DescribeRelationMetaResponseBodyRelationMetaDTOList;
class GetAllCustomerRecyclesResponseBodyResultList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            customerId: 'customerId',
            followUpActionTime: 'followUpActionTime',
            isDeleted: 'isDeleted',
            notifyTime: 'notifyTime',
            recycleRuleId: 'recycleRuleId',
            recycleTime: 'recycleTime',
        };
    }
    static types() {
        return {
            customerId: 'string',
            followUpActionTime: 'string',
            isDeleted: 'boolean',
            notifyTime: 'string',
            recycleRuleId: 'number',
            recycleTime: 'string',
        };
    }
}
exports.GetAllCustomerRecyclesResponseBodyResultList = GetAllCustomerRecyclesResponseBodyResultList;
class GetCrmGroupChatMultiResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'gmtCreate',
            iconUrl: 'iconUrl',
            memberCount: 'memberCount',
            name: 'name',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            ownerUserId: 'ownerUserId',
            ownerUserName: 'ownerUserName',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            iconUrl: 'string',
            memberCount: 'number',
            name: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            ownerUserId: 'string',
            ownerUserName: 'string',
        };
    }
}
exports.GetCrmGroupChatMultiResponseBodyResult = GetCrmGroupChatMultiResponseBodyResult;
class GetCrmRolePermissionResponseBodyPermissionsFieldScopes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldActions: 'fieldActions',
            fieldId: 'fieldId',
        };
    }
    static types() {
        return {
            fieldActions: { 'type': 'array', 'itemType': 'string' },
            fieldId: 'string',
        };
    }
}
exports.GetCrmRolePermissionResponseBodyPermissionsFieldScopes = GetCrmRolePermissionResponseBodyPermissionsFieldScopes;
class GetCrmRolePermissionResponseBodyPermissionsManagingScopeListExt extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptIdList: 'deptIdList',
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            deptIdList: { 'type': 'array', 'itemType': 'number' },
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetCrmRolePermissionResponseBodyPermissionsManagingScopeListExt = GetCrmRolePermissionResponseBodyPermissionsManagingScopeListExt;
class GetCrmRolePermissionResponseBodyPermissionsManagingScopeList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ext: 'ext',
            manager: 'manager',
            type: 'type',
        };
    }
    static types() {
        return {
            ext: GetCrmRolePermissionResponseBodyPermissionsManagingScopeListExt,
            manager: 'boolean',
            type: 'string',
        };
    }
}
exports.GetCrmRolePermissionResponseBodyPermissionsManagingScopeList = GetCrmRolePermissionResponseBodyPermissionsManagingScopeList;
class GetCrmRolePermissionResponseBodyPermissionsOperateScopes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasAuth: 'hasAuth',
            type: 'type',
        };
    }
    static types() {
        return {
            hasAuth: 'boolean',
            type: 'string',
        };
    }
}
exports.GetCrmRolePermissionResponseBodyPermissionsOperateScopes = GetCrmRolePermissionResponseBodyPermissionsOperateScopes;
class GetCrmRolePermissionResponseBodyPermissionsRoleMemberList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberId: 'memberId',
            name: 'name',
            type: 'type',
            userId: 'userId',
        };
    }
    static types() {
        return {
            memberId: 'string',
            name: 'string',
            type: 'string',
            userId: 'string',
        };
    }
}
exports.GetCrmRolePermissionResponseBodyPermissionsRoleMemberList = GetCrmRolePermissionResponseBodyPermissionsRoleMemberList;
class GetCrmRolePermissionResponseBodyPermissions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            defaultRole: 'defaultRole',
            fieldScopes: 'fieldScopes',
            managingScopeList: 'managingScopeList',
            operateScopes: 'operateScopes',
            resourceId: 'resourceId',
            roleId: 'roleId',
            roleMemberList: 'roleMemberList',
            roleName: 'roleName',
        };
    }
    static types() {
        return {
            defaultRole: 'boolean',
            fieldScopes: { 'type': 'array', 'itemType': GetCrmRolePermissionResponseBodyPermissionsFieldScopes },
            managingScopeList: { 'type': 'array', 'itemType': GetCrmRolePermissionResponseBodyPermissionsManagingScopeList },
            operateScopes: { 'type': 'array', 'itemType': GetCrmRolePermissionResponseBodyPermissionsOperateScopes },
            resourceId: 'string',
            roleId: 'number',
            roleMemberList: { 'type': 'array', 'itemType': GetCrmRolePermissionResponseBodyPermissionsRoleMemberList },
            roleName: 'string',
        };
    }
}
exports.GetCrmRolePermissionResponseBodyPermissions = GetCrmRolePermissionResponseBodyPermissions;
class GetCustomerTracksByRelationIdResponseBodyResultListIsvInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appName: 'appName',
            orgName: 'orgName',
        };
    }
    static types() {
        return {
            appName: 'string',
            orgName: 'string',
        };
    }
}
exports.GetCustomerTracksByRelationIdResponseBodyResultListIsvInfo = GetCustomerTracksByRelationIdResponseBodyResultListIsvInfo;
class GetCustomerTracksByRelationIdResponseBodyResultList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            creatorName: 'creatorName',
            detail: 'detail',
            format: 'format',
            gmtCreate: 'gmtCreate',
            isvInfo: 'isvInfo',
            title: 'title',
            type: 'type',
            typeGroup: 'typeGroup',
        };
    }
    static types() {
        return {
            content: 'string',
            creatorName: 'string',
            detail: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            format: 'string',
            gmtCreate: 'string',
            isvInfo: GetCustomerTracksByRelationIdResponseBodyResultListIsvInfo,
            title: 'string',
            type: 'number',
            typeGroup: 'number',
        };
    }
}
exports.GetCustomerTracksByRelationIdResponseBodyResultList = GetCustomerTracksByRelationIdResponseBodyResultList;
class GetGroupSetResponseBodyManager extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.GetGroupSetResponseBodyManager = GetGroupSetResponseBodyManager;
class GetGroupSetResponseBodyOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.GetGroupSetResponseBodyOwner = GetGroupSetResponseBodyOwner;
class GetOfficialAccountContactsResponseBodyValuesContactsPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerStaffIds: 'ownerStaffIds',
            participantStaffIds: 'participantStaffIds',
        };
    }
    static types() {
        return {
            ownerStaffIds: { 'type': 'array', 'itemType': 'string' },
            participantStaffIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetOfficialAccountContactsResponseBodyValuesContactsPermission = GetOfficialAccountContactsResponseBodyValuesContactsPermission;
class GetOfficialAccountContactsResponseBodyValuesContacts extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            creatorNick: 'creatorNick',
            creatorUserId: 'creatorUserId',
            data: 'data',
            extendData: 'extendData',
            instanceId: 'instanceId',
            modifyTime: 'modifyTime',
            permission: 'permission',
        };
    }
    static types() {
        return {
            createTime: 'string',
            creatorNick: 'string',
            creatorUserId: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            instanceId: 'string',
            modifyTime: 'string',
            permission: GetOfficialAccountContactsResponseBodyValuesContactsPermission,
        };
    }
}
exports.GetOfficialAccountContactsResponseBodyValuesContacts = GetOfficialAccountContactsResponseBodyValuesContacts;
class GetOfficialAccountContactsResponseBodyValues extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contacts: 'contacts',
            userId: 'userId',
        };
    }
    static types() {
        return {
            contacts: { 'type': 'array', 'itemType': GetOfficialAccountContactsResponseBodyValuesContacts },
            userId: 'string',
        };
    }
}
exports.GetOfficialAccountContactsResponseBodyValues = GetOfficialAccountContactsResponseBodyValues;
class GetOfficialAccountOTOMessageResultResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            readUserIdList: 'readUserIdList',
            status: 'status',
        };
    }
    static types() {
        return {
            readUserIdList: { 'type': 'array', 'itemType': 'string' },
            status: 'number',
        };
    }
}
exports.GetOfficialAccountOTOMessageResultResponseBodyResult = GetOfficialAccountOTOMessageResultResponseBodyResult;
class GetRelationUkSettingResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizAlias: 'bizAlias',
            fieldId: 'fieldId',
        };
    }
    static types() {
        return {
            bizAlias: 'string',
            fieldId: 'string',
        };
    }
}
exports.GetRelationUkSettingResponseBodyResult = GetRelationUkSettingResponseBodyResult;
class JoinGroupSetRequestBizDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.JoinGroupSetRequestBizDataList = JoinGroupSetRequestBizDataList;
class ListCrmPersonalCustomersResponseBodyResultPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerStaffIds: 'ownerStaffIds',
            participantStaffIds: 'participantStaffIds',
        };
    }
    static types() {
        return {
            ownerStaffIds: { 'type': 'array', 'itemType': 'string' },
            participantStaffIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ListCrmPersonalCustomersResponseBodyResultPermission = ListCrmPersonalCustomersResponseBodyResultPermission;
class ListCrmPersonalCustomersResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appUuid: 'appUuid',
            creatorNick: 'creatorNick',
            creatorUserId: 'creatorUserId',
            data: 'data',
            extendData: 'extendData',
            formCode: 'formCode',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            instanceId: 'instanceId',
            objectType: 'objectType',
            permission: 'permission',
            procInstStatus: 'procInstStatus',
            procOutResult: 'procOutResult',
        };
    }
    static types() {
        return {
            appUuid: 'string',
            creatorNick: 'string',
            creatorUserId: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            formCode: 'string',
            gmtCreate: 'string',
            gmtModified: 'string',
            instanceId: 'string',
            objectType: 'string',
            permission: ListCrmPersonalCustomersResponseBodyResultPermission,
            procInstStatus: 'string',
            procOutResult: 'string',
        };
    }
}
exports.ListCrmPersonalCustomersResponseBodyResult = ListCrmPersonalCustomersResponseBodyResult;
class ListGroupSetResponseBodyResultListManager extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.ListGroupSetResponseBodyResultListManager = ListGroupSetResponseBodyResultListManager;
class ListGroupSetResponseBodyResultListOwner extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            userId: 'userId',
        };
    }
    static types() {
        return {
            name: 'string',
            userId: 'string',
        };
    }
}
exports.ListGroupSetResponseBodyResultListOwner = ListGroupSetResponseBodyResultListOwner;
class ListGroupSetResponseBodyResultList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            groupChatCount: 'groupChatCount',
            lastOpenConversationId: 'lastOpenConversationId',
            manager: 'manager',
            managerUserIds: 'managerUserIds',
            memberCount: 'memberCount',
            memberQuota: 'memberQuota',
            name: 'name',
            notice: 'notice',
            noticeToped: 'noticeToped',
            openGroupSetId: 'openGroupSetId',
            owner: 'owner',
            ownerUserId: 'ownerUserId',
            relationType: 'relationType',
            templateId: 'templateId',
        };
    }
    static types() {
        return {
            gmtCreate: 'string',
            gmtModified: 'string',
            groupChatCount: 'number',
            lastOpenConversationId: 'string',
            manager: { 'type': 'array', 'itemType': ListGroupSetResponseBodyResultListManager },
            managerUserIds: 'string',
            memberCount: 'number',
            memberQuota: 'number',
            name: 'string',
            notice: 'string',
            noticeToped: 'number',
            openGroupSetId: 'string',
            owner: ListGroupSetResponseBodyResultListOwner,
            ownerUserId: 'string',
            relationType: 'string',
            templateId: 'string',
        };
    }
}
exports.ListGroupSetResponseBodyResultList = ListGroupSetResponseBodyResultList;
class QueryAllCustomerResponseBodyResultValuesPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerStaffIds: 'ownerStaffIds',
            participantStaffIds: 'participantStaffIds',
        };
    }
    static types() {
        return {
            ownerStaffIds: { 'type': 'array', 'itemType': 'string' },
            participantStaffIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryAllCustomerResponseBodyResultValuesPermission = QueryAllCustomerResponseBodyResultValuesPermission;
class QueryAllCustomerResponseBodyResultValues extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            createTime: 'createTime',
            creatorNick: 'creatorNick',
            creatorUserId: 'creatorUserId',
            data: 'data',
            extendData: 'extendData',
            instanceId: 'instanceId',
            modifyTime: 'modifyTime',
            objectType: 'objectType',
            permission: 'permission',
            processInstanceStatus: 'processInstanceStatus',
            processOutResult: 'processOutResult',
        };
    }
    static types() {
        return {
            createTime: 'string',
            creatorNick: 'string',
            creatorUserId: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            instanceId: 'string',
            modifyTime: 'string',
            objectType: 'string',
            permission: QueryAllCustomerResponseBodyResultValuesPermission,
            processInstanceStatus: 'string',
            processOutResult: 'string',
        };
    }
}
exports.QueryAllCustomerResponseBodyResultValues = QueryAllCustomerResponseBodyResultValues;
class QueryAllCustomerResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            values: 'values',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            values: { 'type': 'array', 'itemType': QueryAllCustomerResponseBodyResultValues },
        };
    }
}
exports.QueryAllCustomerResponseBodyResult = QueryAllCustomerResponseBodyResult;
class QueryAllTracksResponseBodyValues extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'bizId',
            creator: 'creator',
            customerId: 'customerId',
            gmtCreate: 'gmtCreate',
            id: 'id',
            subType: 'subType',
            type: 'type',
        };
    }
    static types() {
        return {
            bizId: 'string',
            creator: 'string',
            customerId: 'string',
            gmtCreate: 'number',
            id: 'string',
            subType: 'number',
            type: 'number',
        };
    }
}
exports.QueryAllTracksResponseBodyValues = QueryAllTracksResponseBodyValues;
class QueryCrmGroupChatsResponseBodyResultList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtCreate: 'gmtCreate',
            memberCount: 'memberCount',
            name: 'name',
            openConversationId: 'openConversationId',
            openGroupSetId: 'openGroupSetId',
            ownerUserId: 'ownerUserId',
            ownerUserName: 'ownerUserName',
        };
    }
    static types() {
        return {
            gmtCreate: 'number',
            memberCount: 'number',
            name: 'string',
            openConversationId: 'string',
            openGroupSetId: 'string',
            ownerUserId: 'string',
            ownerUserName: 'string',
        };
    }
}
exports.QueryCrmGroupChatsResponseBodyResultList = QueryCrmGroupChatsResponseBodyResultList;
class QueryCrmPersonalCustomerResponseBodyValuesPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerStaffIds: 'ownerStaffIds',
            participantStaffIds: 'participantStaffIds',
        };
    }
    static types() {
        return {
            ownerStaffIds: { 'type': 'array', 'itemType': 'string' },
            participantStaffIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryCrmPersonalCustomerResponseBodyValuesPermission = QueryCrmPersonalCustomerResponseBodyValuesPermission;
class QueryCrmPersonalCustomerResponseBodyValues extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorNick: 'creatorNick',
            creatorUserId: 'creatorUserId',
            data: 'data',
            extendData: 'extendData',
            gmtCreate: 'gmtCreate',
            gmtModified: 'gmtModified',
            instanceId: 'instanceId',
            objectType: 'objectType',
            permission: 'permission',
            procInstStatus: 'procInstStatus',
            procOutResult: 'procOutResult',
        };
    }
    static types() {
        return {
            creatorNick: 'string',
            creatorUserId: 'string',
            data: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            extendData: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            gmtCreate: 'string',
            gmtModified: 'string',
            instanceId: 'string',
            objectType: 'string',
            permission: QueryCrmPersonalCustomerResponseBodyValuesPermission,
            procInstStatus: 'string',
            procOutResult: 'string',
        };
    }
}
exports.QueryCrmPersonalCustomerResponseBodyValues = QueryCrmPersonalCustomerResponseBodyValues;
class QueryGlobalInfoResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            oemEnable: 'oemEnable',
        };
    }
    static types() {
        return {
            oemEnable: 'boolean',
        };
    }
}
exports.QueryGlobalInfoResponseBodyResult = QueryGlobalInfoResponseBodyResult;
class QueryOfficialAccountUserBasicInfoResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            status: 'status',
        };
    }
    static types() {
        return {
            status: 'string',
        };
    }
}
exports.QueryOfficialAccountUserBasicInfoResponseBodyResult = QueryOfficialAccountUserBasicInfoResponseBodyResult;
class QueryRelationDatasByTargetIdResponseBodyRelationsBizDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extendValue: 'extendValue',
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            extendValue: 'string',
            key: 'string',
            value: 'string',
        };
    }
}
exports.QueryRelationDatasByTargetIdResponseBodyRelationsBizDataList = QueryRelationDatasByTargetIdResponseBodyRelationsBizDataList;
class QueryRelationDatasByTargetIdResponseBodyRelations extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizDataList: 'bizDataList',
            openConversationIds: 'openConversationIds',
            relationId: 'relationId',
            relationType: 'relationType',
        };
    }
    static types() {
        return {
            bizDataList: { 'type': 'array', 'itemType': QueryRelationDatasByTargetIdResponseBodyRelationsBizDataList },
            openConversationIds: { 'type': 'array', 'itemType': 'string' },
            relationId: 'string',
            relationType: 'string',
        };
    }
}
exports.QueryRelationDatasByTargetIdResponseBodyRelations = QueryRelationDatasByTargetIdResponseBodyRelations;
class SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionUrl: 'actionUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            actionUrl: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList = SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList;
class SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            buttonList: 'buttonList',
            buttonOrientation: 'buttonOrientation',
            markdown: 'markdown',
            singleTitle: 'singleTitle',
            singleUrl: 'singleUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            buttonList: { 'type': 'array', 'itemType': SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCardButtonList },
            buttonOrientation: 'string',
            markdown: 'string',
            singleTitle: 'string',
            singleUrl: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard = SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard;
class SendOfficialAccountOTOMessageRequestDetailMessageBodyImage extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mediaId: 'mediaId',
        };
    }
    static types() {
        return {
            mediaId: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetailMessageBodyImage = SendOfficialAccountOTOMessageRequestDetailMessageBodyImage;
class SendOfficialAccountOTOMessageRequestDetailMessageBodyLink extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageUrl: 'messageUrl',
            picUrl: 'picUrl',
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            messageUrl: 'string',
            picUrl: 'string',
            text: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetailMessageBodyLink = SendOfficialAccountOTOMessageRequestDetailMessageBodyLink;
class SendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            text: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown = SendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown;
class SendOfficialAccountOTOMessageRequestDetailMessageBodyText extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetailMessageBodyText = SendOfficialAccountOTOMessageRequestDetailMessageBodyText;
class SendOfficialAccountOTOMessageRequestDetailMessageBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionCard: 'actionCard',
            image: 'image',
            link: 'link',
            markdown: 'markdown',
            text: 'text',
        };
    }
    static types() {
        return {
            actionCard: SendOfficialAccountOTOMessageRequestDetailMessageBodyActionCard,
            image: SendOfficialAccountOTOMessageRequestDetailMessageBodyImage,
            link: SendOfficialAccountOTOMessageRequestDetailMessageBodyLink,
            markdown: SendOfficialAccountOTOMessageRequestDetailMessageBodyMarkdown,
            text: SendOfficialAccountOTOMessageRequestDetailMessageBodyText,
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetailMessageBody = SendOfficialAccountOTOMessageRequestDetailMessageBody;
class SendOfficialAccountOTOMessageRequestDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageBody: 'messageBody',
            msgType: 'msgType',
            unionId: 'unionId',
            userId: 'userId',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            messageBody: SendOfficialAccountOTOMessageRequestDetailMessageBody,
            msgType: 'string',
            unionId: 'string',
            userId: 'string',
            uuid: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageRequestDetail = SendOfficialAccountOTOMessageRequestDetail;
class SendOfficialAccountOTOMessageResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            openPushId: 'string',
        };
    }
}
exports.SendOfficialAccountOTOMessageResponseBodyResult = SendOfficialAccountOTOMessageResponseBodyResult;
class SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCardButtonList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionUrl: 'actionUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            actionUrl: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCardButtonList = SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCardButtonList;
class SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCard extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            buttonList: 'buttonList',
            buttonOrientation: 'buttonOrientation',
            markdown: 'markdown',
            singleTitle: 'singleTitle',
            singleUrl: 'singleUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            buttonList: { 'type': 'array', 'itemType': SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCardButtonList },
            buttonOrientation: 'string',
            markdown: 'string',
            singleTitle: 'string',
            singleUrl: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCard = SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCard;
class SendOfficialAccountSNSMessageRequestDetailMessageBodyLink extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageUrl: 'messageUrl',
            picUrl: 'picUrl',
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            messageUrl: 'string',
            picUrl: 'string',
            text: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageRequestDetailMessageBodyLink = SendOfficialAccountSNSMessageRequestDetailMessageBodyLink;
class SendOfficialAccountSNSMessageRequestDetailMessageBodyMarkdown extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            text: 'string',
            title: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageRequestDetailMessageBodyMarkdown = SendOfficialAccountSNSMessageRequestDetailMessageBodyMarkdown;
class SendOfficialAccountSNSMessageRequestDetailMessageBodyText extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageRequestDetailMessageBodyText = SendOfficialAccountSNSMessageRequestDetailMessageBodyText;
class SendOfficialAccountSNSMessageRequestDetailMessageBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionCard: 'actionCard',
            link: 'link',
            markdown: 'markdown',
            text: 'text',
        };
    }
    static types() {
        return {
            actionCard: SendOfficialAccountSNSMessageRequestDetailMessageBodyActionCard,
            link: SendOfficialAccountSNSMessageRequestDetailMessageBodyLink,
            markdown: SendOfficialAccountSNSMessageRequestDetailMessageBodyMarkdown,
            text: SendOfficialAccountSNSMessageRequestDetailMessageBodyText,
        };
    }
}
exports.SendOfficialAccountSNSMessageRequestDetailMessageBody = SendOfficialAccountSNSMessageRequestDetailMessageBody;
class SendOfficialAccountSNSMessageRequestDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageBody: 'messageBody',
            msgType: 'msgType',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            messageBody: SendOfficialAccountSNSMessageRequestDetailMessageBody,
            msgType: 'string',
            uuid: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageRequestDetail = SendOfficialAccountSNSMessageRequestDetail;
class SendOfficialAccountSNSMessageResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            openPushId: 'string',
        };
    }
}
exports.SendOfficialAccountSNSMessageResponseBodyResult = SendOfficialAccountSNSMessageResponseBodyResult;
class ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCardButtonList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionUrl: 'actionUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            actionUrl: 'string',
            title: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCardButtonList = ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCardButtonList;
class ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCard extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            buttonList: 'buttonList',
            buttonOrientation: 'buttonOrientation',
            markdown: 'markdown',
            singleTitle: 'singleTitle',
            singleUrl: 'singleUrl',
            title: 'title',
        };
    }
    static types() {
        return {
            buttonList: { 'type': 'array', 'itemType': ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCardButtonList },
            buttonOrientation: 'string',
            markdown: 'string',
            singleTitle: 'string',
            singleUrl: 'string',
            title: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCard = ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCard;
class ServiceWindowMessageBatchPushRequestDetailMessageBodyLink extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            messageUrl: 'messageUrl',
            picUrl: 'picUrl',
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            messageUrl: 'string',
            picUrl: 'string',
            text: 'string',
            title: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushRequestDetailMessageBodyLink = ServiceWindowMessageBatchPushRequestDetailMessageBodyLink;
class ServiceWindowMessageBatchPushRequestDetailMessageBodyMarkdown extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            text: 'text',
            title: 'title',
        };
    }
    static types() {
        return {
            text: 'string',
            title: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushRequestDetailMessageBodyMarkdown = ServiceWindowMessageBatchPushRequestDetailMessageBodyMarkdown;
class ServiceWindowMessageBatchPushRequestDetailMessageBodyText extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
        };
    }
    static types() {
        return {
            content: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushRequestDetailMessageBodyText = ServiceWindowMessageBatchPushRequestDetailMessageBodyText;
class ServiceWindowMessageBatchPushRequestDetailMessageBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionCard: 'actionCard',
            link: 'link',
            markdown: 'markdown',
            text: 'text',
        };
    }
    static types() {
        return {
            actionCard: ServiceWindowMessageBatchPushRequestDetailMessageBodyActionCard,
            link: ServiceWindowMessageBatchPushRequestDetailMessageBodyLink,
            markdown: ServiceWindowMessageBatchPushRequestDetailMessageBodyMarkdown,
            text: ServiceWindowMessageBatchPushRequestDetailMessageBodyText,
        };
    }
}
exports.ServiceWindowMessageBatchPushRequestDetailMessageBody = ServiceWindowMessageBatchPushRequestDetailMessageBody;
class ServiceWindowMessageBatchPushRequestDetail extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizRequestId: 'bizRequestId',
            messageBody: 'messageBody',
            msgType: 'msgType',
            sendToAll: 'sendToAll',
            userIdList: 'userIdList',
            uuid: 'uuid',
        };
    }
    static types() {
        return {
            bizRequestId: 'string',
            messageBody: ServiceWindowMessageBatchPushRequestDetailMessageBody,
            msgType: 'string',
            sendToAll: 'boolean',
            userIdList: { 'type': 'array', 'itemType': 'string' },
            uuid: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushRequestDetail = ServiceWindowMessageBatchPushRequestDetail;
class ServiceWindowMessageBatchPushResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openPushId: 'openPushId',
        };
    }
    static types() {
        return {
            openPushId: 'string',
        };
    }
}
exports.ServiceWindowMessageBatchPushResponseBodyResult = ServiceWindowMessageBatchPushResponseBodyResult;
class UpdateCrmPersonalCustomerRequestPermission extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ownerStaffIds: 'ownerStaffIds',
            participantStaffIds: 'participantStaffIds',
        };
    }
    static types() {
        return {
            ownerStaffIds: { 'type': 'array', 'itemType': 'string' },
            participantStaffIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.UpdateCrmPersonalCustomerRequestPermission = UpdateCrmPersonalCustomerRequestPermission;
class UpdateRelationMetaFieldRequestFieldDTOListPropsOptions extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.UpdateRelationMetaFieldRequestFieldDTOListPropsOptions = UpdateRelationMetaFieldRequestFieldDTOListPropsOptions;
class UpdateRelationMetaFieldRequestFieldDTOListProps extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            align: 'align',
            bizAlias: 'bizAlias',
            choice: 'choice',
            content: 'content',
            disabled: 'disabled',
            duration: 'duration',
            fieldId: 'fieldId',
            format: 'format',
            invisible: 'invisible',
            label: 'label',
            labelEditableFreeze: 'labelEditableFreeze',
            link: 'link',
            needDetail: 'needDetail',
            notPrint: 'notPrint',
            notUpper: 'notUpper',
            options: 'options',
            payEnable: 'payEnable',
            placeholder: 'placeholder',
            required: 'required',
            requiredEditableFreeze: 'requiredEditableFreeze',
            sortable: 'sortable',
            unit: 'unit',
        };
    }
    static types() {
        return {
            align: 'string',
            bizAlias: 'string',
            choice: 'number',
            content: 'string',
            disabled: 'boolean',
            duration: 'boolean',
            fieldId: 'string',
            format: 'string',
            invisible: 'boolean',
            label: 'string',
            labelEditableFreeze: 'boolean',
            link: 'string',
            needDetail: 'string',
            notPrint: 'string',
            notUpper: 'string',
            options: { 'type': 'array', 'itemType': UpdateRelationMetaFieldRequestFieldDTOListPropsOptions },
            payEnable: 'boolean',
            placeholder: 'string',
            required: 'boolean',
            requiredEditableFreeze: 'boolean',
            sortable: 'boolean',
            unit: 'string',
        };
    }
}
exports.UpdateRelationMetaFieldRequestFieldDTOListProps = UpdateRelationMetaFieldRequestFieldDTOListProps;
class UpdateRelationMetaFieldRequestFieldDTOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            componentName: 'componentName',
            props: 'props',
        };
    }
    static types() {
        return {
            componentName: 'string',
            props: UpdateRelationMetaFieldRequestFieldDTOListProps,
        };
    }
}
exports.UpdateRelationMetaFieldRequestFieldDTOList = UpdateRelationMetaFieldRequestFieldDTOList;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async abandonCustomerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.customTrackDesc)) {
            body["customTrackDesc"] = request.customTrackDesc;
        }
        if (!tea_util_1.default.isUnset(request.instanceIdList)) {
            body["instanceIdList"] = request.instanceIdList;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.optType)) {
            body["optType"] = request.optType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AbandonCustomer",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customers/abandon`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AbandonCustomerResponse({}));
    }
    async abandonCustomer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AbandonCustomerHeaders({});
        return await this.abandonCustomerWithOptions(request, headers, runtime);
    }
    async addCrmPersonalCustomerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.creatorNick)) {
            body["creatorNick"] = request.creatorNick;
        }
        if (!tea_util_1.default.isUnset(request.creatorUserId)) {
            body["creatorUserId"] = request.creatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.data)) {
            body["data"] = request.data;
        }
        if (!tea_util_1.default.isUnset(request.extendData)) {
            body["extendData"] = request.extendData;
        }
        if (!tea_util_1.default.isUnset(request.permission)) {
            body["permission"] = request.permission;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.skipDuplicateCheck)) {
            body["skipDuplicateCheck"] = request.skipDuplicateCheck;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddCrmPersonalCustomer",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/personalCustomers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddCrmPersonalCustomerResponse({}));
    }
    async addCrmPersonalCustomer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddCrmPersonalCustomerHeaders({});
        return await this.addCrmPersonalCustomerWithOptions(request, headers, runtime);
    }
    async addCustomerTrackWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.customerId)) {
            body["customerId"] = request.customerId;
        }
        if (!tea_util_1.default.isUnset(request.extraBizInfo)) {
            body["extraBizInfo"] = request.extraBizInfo;
        }
        if (!tea_util_1.default.isUnset(request.idempotentKey)) {
            body["idempotentKey"] = request.idempotentKey;
        }
        if (!tea_util_1.default.isUnset(request.maskedContent)) {
            body["maskedContent"] = request.maskedContent;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.type)) {
            body["type"] = request.type;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddCustomerTrack",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customerTracks`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddCustomerTrackResponse({}));
    }
    async addCustomerTrack(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddCustomerTrackHeaders({});
        return await this.addCustomerTrackWithOptions(request, headers, runtime);
    }
    async addLeadsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.assignTimestamp)) {
            body["assignTimestamp"] = request.assignTimestamp;
        }
        if (!tea_util_1.default.isUnset(request.assignUserId)) {
            body["assignUserId"] = request.assignUserId;
        }
        if (!tea_util_1.default.isUnset(request.assignedUserId)) {
            body["assignedUserId"] = request.assignedUserId;
        }
        if (!tea_util_1.default.isUnset(request.leads)) {
            body["leads"] = request.leads;
        }
        if (!tea_util_1.default.isUnset(request.outTaskId)) {
            body["outTaskId"] = request.outTaskId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddLeads",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/leads`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddLeadsResponse({}));
    }
    async addLeads(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddLeadsHeaders({});
        return await this.addLeadsWithOptions(request, headers, runtime);
    }
    async addRelationMetaFieldWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fieldDTOList)) {
            body["fieldDTOList"] = request.fieldDTOList;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.tenant)) {
            body["tenant"] = request.tenant;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddRelationMetaField",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relations/metas/fields`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddRelationMetaFieldResponse({}));
    }
    async addRelationMetaField(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddRelationMetaFieldHeaders({});
        return await this.addRelationMetaFieldWithOptions(request, headers, runtime);
    }
    async batchAddContactsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationList)) {
            body["relationList"] = request.relationList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchAddContacts",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/contacts/batch`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchAddContactsResponse({}));
    }
    async batchAddContacts(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchAddContactsHeaders({});
        return await this.batchAddContactsWithOptions(request, headers, runtime);
    }
    async batchAddFollowRecordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.instanceList)) {
            body["instanceList"] = request.instanceList;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchAddFollowRecords",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/followRecords/batch`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchAddFollowRecordsResponse({}));
    }
    async batchAddFollowRecords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchAddFollowRecordsHeaders({});
        return await this.batchAddFollowRecordsWithOptions(request, headers, runtime);
    }
    async batchAddRelationDatasWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationList)) {
            body["relationList"] = request.relationList;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.skipDuplicateCheck)) {
            body["skipDuplicateCheck"] = request.skipDuplicateCheck;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchAddRelationDatas",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relationDatas/batch`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchAddRelationDatasResponse({}));
    }
    async batchAddRelationDatas(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchAddRelationDatasHeaders({});
        return await this.batchAddRelationDatasWithOptions(request, headers, runtime);
    }
    async batchRemoveFollowRecordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.instanceIds)) {
            body["instanceIds"] = request.instanceIds;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchRemoveFollowRecords",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/followRecords/batchRemove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchRemoveFollowRecordsResponse({}));
    }
    async batchRemoveFollowRecords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchRemoveFollowRecordsHeaders({});
        return await this.batchRemoveFollowRecordsWithOptions(request, headers, runtime);
    }
    async batchSendOfficialAccountOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            body["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchSendOfficialAccountOTOMessage",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/oToMessages/batchSend`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchSendOfficialAccountOTOMessageResponse({}));
    }
    async batchSendOfficialAccountOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchSendOfficialAccountOTOMessageHeaders({});
        return await this.batchSendOfficialAccountOTOMessageWithOptions(request, headers, runtime);
    }
    async batchUpdateContactsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationList)) {
            body["relationList"] = request.relationList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchUpdateContacts",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/contacts/batch`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchUpdateContactsResponse({}));
    }
    async batchUpdateContacts(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchUpdateContactsHeaders({});
        return await this.batchUpdateContactsWithOptions(request, headers, runtime);
    }
    async batchUpdateFollowRecordsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.instanceList)) {
            body["instanceList"] = request.instanceList;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchUpdateFollowRecords",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/followRecords/batch`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchUpdateFollowRecordsResponse({}));
    }
    async batchUpdateFollowRecords(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchUpdateFollowRecordsHeaders({});
        return await this.batchUpdateFollowRecordsWithOptions(request, headers, runtime);
    }
    async batchUpdateRelationDatasWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationList)) {
            body["relationList"] = request.relationList;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.skipDuplicateCheck)) {
            body["skipDuplicateCheck"] = request.skipDuplicateCheck;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "BatchUpdateRelationDatas",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relationDatas/batch`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new BatchUpdateRelationDatasResponse({}));
    }
    async batchUpdateRelationDatas(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new BatchUpdateRelationDatasHeaders({});
        return await this.batchUpdateRelationDatasWithOptions(request, headers, runtime);
    }
    async createCustomerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.contacts)) {
            body["contacts"] = request.contacts;
        }
        if (!tea_util_1.default.isUnset(request.creatorUserId)) {
            body["creatorUserId"] = request.creatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.data)) {
            body["data"] = request.data;
        }
        if (!tea_util_1.default.isUnset(request.extendData)) {
            body["extendData"] = request.extendData;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            body["instanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.objectType)) {
            body["objectType"] = request.objectType;
        }
        if (!tea_util_1.default.isUnset(request.permission)) {
            body["permission"] = request.permission;
        }
        if (!tea_util_1.default.isUnset(request.saveOption)) {
            body["saveOption"] = request.saveOption;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateCustomer",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateCustomerResponse({}));
    }
    async createCustomer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateCustomerHeaders({});
        return await this.createCustomerWithOptions(request, headers, runtime);
    }
    async createGroupWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.groupName)) {
            body["groupName"] = request.groupName;
        }
        if (!tea_util_1.default.isUnset(request.memberUserIds)) {
            body["memberUserIds"] = request.memberUserIds;
        }
        if (!tea_util_1.default.isUnset(request.ownerUserId)) {
            body["ownerUserId"] = request.ownerUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateGroup",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/groups`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateGroupResponse({}));
    }
    async createGroup(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateGroupHeaders({});
        return await this.createGroupWithOptions(request, headers, runtime);
    }
    async createGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUserId)) {
            body["creatorUserId"] = request.creatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.managerUserIds)) {
            body["managerUserIds"] = request.managerUserIds;
        }
        if (!tea_util_1.default.isUnset(request.memberQuota)) {
            body["memberQuota"] = request.memberQuota;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.notice)) {
            body["notice"] = request.notice;
        }
        if (!tea_util_1.default.isUnset(request.noticeToped)) {
            body["noticeToped"] = request.noticeToped;
        }
        if (!tea_util_1.default.isUnset(request.ownerUserId)) {
            body["ownerUserId"] = request.ownerUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        if (!tea_util_1.default.isUnset(request.welcome)) {
            body["welcome"] = request.welcome;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateGroupSet",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/groupSets`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateGroupSetResponse({}));
    }
    async createGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateGroupSetHeaders({});
        return await this.createGroupSetWithOptions(request, headers, runtime);
    }
    async createRelationMetaWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationMetaDTO)) {
            body["relationMetaDTO"] = request.relationMetaDTO;
        }
        if (!tea_util_1.default.isUnset(request.tenant)) {
            body["tenant"] = request.tenant;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateRelationMeta",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relations/metas/create`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateRelationMetaResponse({}));
    }
    async createRelationMeta(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateRelationMetaHeaders({});
        return await this.createRelationMetaWithOptions(request, headers, runtime);
    }
    async deleteCrmCustomObjectDataWithOptions(instanceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.formCode)) {
            query["formCode"] = request.formCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteCrmCustomObjectData",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customObjectDatas/instances/${instanceId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteCrmCustomObjectDataResponse({}));
    }
    async deleteCrmCustomObjectData(instanceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteCrmCustomObjectDataHeaders({});
        return await this.deleteCrmCustomObjectDataWithOptions(instanceId, request, headers, runtime);
    }
    async deleteCrmFormInstanceWithOptions(instanceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentOperatorUserId)) {
            query["currentOperatorUserId"] = request.currentOperatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            query["name"] = request.name;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteCrmFormInstance",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/formInstances/${instanceId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteCrmFormInstanceResponse({}));
    }
    async deleteCrmFormInstance(instanceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteCrmFormInstanceHeaders({});
        return await this.deleteCrmFormInstanceWithOptions(instanceId, request, headers, runtime);
    }
    async deleteCrmPersonalCustomerWithOptions(dataId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentOperatorUserId)) {
            query["currentOperatorUserId"] = request.currentOperatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DeleteCrmPersonalCustomer",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/personalCustomers/${dataId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteCrmPersonalCustomerResponse({}));
    }
    async deleteCrmPersonalCustomer(dataId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteCrmPersonalCustomerHeaders({});
        return await this.deleteCrmPersonalCustomerWithOptions(dataId, request, headers, runtime);
    }
    async deleteLeadsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.outLeadsIds)) {
            body["outLeadsIds"] = request.outLeadsIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteLeads",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/leads/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteLeadsResponse({}));
    }
    async deleteLeads(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteLeadsHeaders({});
        return await this.deleteLeadsWithOptions(request, headers, runtime);
    }
    async deleteRelationMetaFieldWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fieldIdList)) {
            body["fieldIdList"] = request.fieldIdList;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.tenant)) {
            body["tenant"] = request.tenant;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeleteRelationMetaField",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relations/metas/fields/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeleteRelationMetaFieldResponse({}));
    }
    async deleteRelationMetaField(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeleteRelationMetaFieldHeaders({});
        return await this.deleteRelationMetaFieldWithOptions(request, headers, runtime);
    }
    async describeCrmPersonalCustomerObjectMetaWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "DescribeCrmPersonalCustomerObjectMeta",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/personalCustomers/objectMeta`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DescribeCrmPersonalCustomerObjectMetaResponse({}));
    }
    async describeCrmPersonalCustomerObjectMeta(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DescribeCrmPersonalCustomerObjectMetaHeaders({});
        return await this.describeCrmPersonalCustomerObjectMetaWithOptions(request, headers, runtime);
    }
    async describeRelationMetaWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationTypes)) {
            body["relationTypes"] = request.relationTypes;
        }
        if (!tea_util_1.default.isUnset(request.tenant)) {
            body["tenant"] = request.tenant;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DescribeRelationMeta",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relations/metas/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DescribeRelationMetaResponse({}));
    }
    async describeRelationMeta(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DescribeRelationMetaHeaders({});
        return await this.describeRelationMetaWithOptions(request, headers, runtime);
    }
    async getAllCustomerRecyclesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetAllCustomerRecycles",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customerRecycles`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAllCustomerRecyclesResponse({}));
    }
    async getAllCustomerRecycles(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAllCustomerRecyclesHeaders({});
        return await this.getAllCustomerRecyclesWithOptions(request, headers, runtime);
    }
    async getCrmGroupChatWithOptions(openConversationId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetCrmGroupChat",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/crmGroupChats/${openConversationId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCrmGroupChatResponse({}));
    }
    async getCrmGroupChat(openConversationId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCrmGroupChatHeaders({});
        return await this.getCrmGroupChatWithOptions(openConversationId, headers, runtime);
    }
    async getCrmGroupChatMultiWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.openConversationIds)) {
            body["openConversationIds"] = request.openConversationIds;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetCrmGroupChatMulti",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/crmGroupChats/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCrmGroupChatMultiResponse({}));
    }
    async getCrmGroupChatMulti(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCrmGroupChatMultiHeaders({});
        return await this.getCrmGroupChatMultiWithOptions(request, headers, runtime);
    }
    async getCrmGroupChatSingleWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetCrmGroupChatSingle",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/crmGroupChats/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCrmGroupChatSingleResponse({}));
    }
    async getCrmGroupChatSingle(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCrmGroupChatSingleHeaders({});
        return await this.getCrmGroupChatSingleWithOptions(request, headers, runtime);
    }
    async getCrmRolePermissionWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bizType)) {
            query["bizType"] = request.bizType;
        }
        if (!tea_util_1.default.isUnset(request.resourceId)) {
            query["resourceId"] = request.resourceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetCrmRolePermission",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/permissions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCrmRolePermissionResponse({}));
    }
    async getCrmRolePermission(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCrmRolePermissionHeaders({});
        return await this.getCrmRolePermissionWithOptions(request, headers, runtime);
    }
    async getCustomerTracksByRelationIdWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.relationId)) {
            query["relationId"] = request.relationId;
        }
        if (!tea_util_1.default.isUnset(request.typeGroup)) {
            query["typeGroup"] = request.typeGroup;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetCustomerTracksByRelationId",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customerTracks`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCustomerTracksByRelationIdResponse({}));
    }
    async getCustomerTracksByRelationId(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCustomerTracksByRelationIdHeaders({});
        return await this.getCustomerTracksByRelationIdWithOptions(request, headers, runtime);
    }
    async getGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            query["openGroupSetId"] = request.openGroupSetId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetGroupSet",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/groupSets`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetGroupSetResponse({}));
    }
    async getGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetGroupSetHeaders({});
        return await this.getGroupSetWithOptions(request, headers, runtime);
    }
    async getOfficialAccountContactInfoWithOptions(userId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetOfficialAccountContactInfo",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/contacts/${userId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetOfficialAccountContactInfoResponse({}));
    }
    async getOfficialAccountContactInfo(userId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetOfficialAccountContactInfoHeaders({});
        return await this.getOfficialAccountContactInfoWithOptions(userId, headers, runtime);
    }
    async getOfficialAccountContactsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetOfficialAccountContacts",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/contacts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetOfficialAccountContactsResponse({}));
    }
    async getOfficialAccountContacts(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetOfficialAccountContactsHeaders({});
        return await this.getOfficialAccountContactsWithOptions(request, headers, runtime);
    }
    async getOfficialAccountOTOMessageResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            query["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.openPushId)) {
            query["openPushId"] = request.openPushId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetOfficialAccountOTOMessageResult",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/oToMessages/sendResults`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetOfficialAccountOTOMessageResultResponse({}));
    }
    async getOfficialAccountOTOMessageResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetOfficialAccountOTOMessageResultHeaders({});
        return await this.getOfficialAccountOTOMessageResultWithOptions(request, headers, runtime);
    }
    async getRelationUkSettingWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetRelationUkSetting",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relationUkSettings`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetRelationUkSettingResponse({}));
    }
    async getRelationUkSetting(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetRelationUkSettingHeaders({});
        return await this.getRelationUkSettingWithOptions(request, headers, runtime);
    }
    async joinGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizDataList)) {
            body["bizDataList"] = request.bizDataList;
        }
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "JoinGroupSet",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/groupSets/join`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new JoinGroupSetResponse({}));
    }
    async joinGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new JoinGroupSetHeaders({});
        return await this.joinGroupSetWithOptions(request, headers, runtime);
    }
    async listCrmPersonalCustomersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentOperatorUserId)) {
            query["currentOperatorUserId"] = request.currentOperatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: request.body,
        });
        let params = new $OpenApi.Params({
            action: "ListCrmPersonalCustomers",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/personalCustomers/batchQuery`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListCrmPersonalCustomersResponse({}));
    }
    async listCrmPersonalCustomers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListCrmPersonalCustomersHeaders({});
        return await this.listCrmPersonalCustomersWithOptions(request, headers, runtime);
    }
    async listGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.queryDsl)) {
            query["queryDsl"] = request.queryDsl;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ListGroupSet",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/groupSets/lists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ListGroupSetResponse({}));
    }
    async listGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ListGroupSetHeaders({});
        return await this.listGroupSetWithOptions(request, headers, runtime);
    }
    async queryAllCustomerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.objectType)) {
            body["objectType"] = request.objectType;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryAllCustomer",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customerInstances`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryAllCustomerResponse({}));
    }
    async queryAllCustomer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryAllCustomerHeaders({});
        return await this.queryAllCustomerWithOptions(request, headers, runtime);
    }
    async queryAllTracksWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.order)) {
            query["order"] = request.order;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryAllTracks",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/customers/tracks`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryAllTracksResponse({}));
    }
    async queryAllTracks(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryAllTracksHeaders({});
        return await this.queryAllTracksWithOptions(request, headers, runtime);
    }
    async queryCrmGroupChatsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.queryDsl)) {
            query["queryDsl"] = request.queryDsl;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCrmGroupChats",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/crmGroupChats`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCrmGroupChatsResponse({}));
    }
    async queryCrmGroupChats(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCrmGroupChatsHeaders({});
        return await this.queryCrmGroupChatsWithOptions(request, headers, runtime);
    }
    async queryCrmPersonalCustomerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.currentOperatorUserId)) {
            query["currentOperatorUserId"] = request.currentOperatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.queryDsl)) {
            query["queryDsl"] = request.queryDsl;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCrmPersonalCustomer",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/personalCustomers`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCrmPersonalCustomerResponse({}));
    }
    async queryCrmPersonalCustomer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCrmPersonalCustomerHeaders({});
        return await this.queryCrmPersonalCustomerWithOptions(request, headers, runtime);
    }
    async queryGlobalInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryGlobalInfo",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/globalInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryGlobalInfoResponse({}));
    }
    async queryGlobalInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryGlobalInfoHeaders({});
        return await this.queryGlobalInfoWithOptions(request, headers, runtime);
    }
    async queryOfficialAccountUserBasicInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.bindingToken)) {
            query["bindingToken"] = request.bindingToken;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryOfficialAccountUserBasicInfo",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/basics/users`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryOfficialAccountUserBasicInfoResponse({}));
    }
    async queryOfficialAccountUserBasicInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryOfficialAccountUserBasicInfoHeaders({});
        return await this.queryOfficialAccountUserBasicInfoWithOptions(request, headers, runtime);
    }
    async queryRelationDatasByTargetIdWithOptions(targetId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.relationType)) {
            query["relationType"] = request.relationType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryRelationDatasByTargetId",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relations/datas/targets/${targetId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryRelationDatasByTargetIdResponse({}));
    }
    async queryRelationDatasByTargetId(targetId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryRelationDatasByTargetIdHeaders({});
        return await this.queryRelationDatasByTargetIdWithOptions(targetId, request, headers, runtime);
    }
    async recallOfficialAccountOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            body["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.openPushId)) {
            body["openPushId"] = request.openPushId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RecallOfficialAccountOTOMessage",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/oToMessages/recall`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RecallOfficialAccountOTOMessageResponse({}));
    }
    async recallOfficialAccountOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RecallOfficialAccountOTOMessageHeaders({});
        return await this.recallOfficialAccountOTOMessageWithOptions(request, headers, runtime);
    }
    async sendOfficialAccountOTOMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.accountId)) {
            body["accountId"] = request.accountId;
        }
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendOfficialAccountOTOMessage",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/oToMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendOfficialAccountOTOMessageResponse({}));
    }
    async sendOfficialAccountOTOMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendOfficialAccountOTOMessageHeaders({});
        return await this.sendOfficialAccountOTOMessageWithOptions(request, headers, runtime);
    }
    async sendOfficialAccountSNSMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bindingToken)) {
            body["bindingToken"] = request.bindingToken;
        }
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendOfficialAccountSNSMessage",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/officialAccounts/snsMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendOfficialAccountSNSMessageResponse({}));
    }
    async sendOfficialAccountSNSMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendOfficialAccountSNSMessageHeaders({});
        return await this.sendOfficialAccountSNSMessageWithOptions(request, headers, runtime);
    }
    async serviceWindowMessageBatchPushWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.detail)) {
            body["detail"] = request.detail;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ServiceWindowMessageBatchPush",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/messages/batchSend`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ServiceWindowMessageBatchPushResponse({}));
    }
    async serviceWindowMessageBatchPush(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ServiceWindowMessageBatchPushHeaders({});
        return await this.serviceWindowMessageBatchPushWithOptions(request, headers, runtime);
    }
    async updateCrmPersonalCustomerWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.data)) {
            body["data"] = request.data;
        }
        if (!tea_util_1.default.isUnset(request.extendData)) {
            body["extendData"] = request.extendData;
        }
        if (!tea_util_1.default.isUnset(request.instanceId)) {
            body["instanceId"] = request.instanceId;
        }
        if (!tea_util_1.default.isUnset(request.modifierNick)) {
            body["modifierNick"] = request.modifierNick;
        }
        if (!tea_util_1.default.isUnset(request.modifierUserId)) {
            body["modifierUserId"] = request.modifierUserId;
        }
        if (!tea_util_1.default.isUnset(request.permission)) {
            body["permission"] = request.permission;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.skipDuplicateCheck)) {
            body["skipDuplicateCheck"] = request.skipDuplicateCheck;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateCrmPersonalCustomer",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/personalCustomers`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateCrmPersonalCustomerResponse({}));
    }
    async updateCrmPersonalCustomer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateCrmPersonalCustomerHeaders({});
        return await this.updateCrmPersonalCustomerWithOptions(request, headers, runtime);
    }
    async updateGroupSetWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.managerUserIds)) {
            body["managerUserIds"] = request.managerUserIds;
        }
        if (!tea_util_1.default.isUnset(request.memberQuota)) {
            body["memberQuota"] = request.memberQuota;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.notice)) {
            body["notice"] = request.notice;
        }
        if (!tea_util_1.default.isUnset(request.noticeToped)) {
            body["noticeToped"] = request.noticeToped;
        }
        if (!tea_util_1.default.isUnset(request.openGroupSetId)) {
            body["openGroupSetId"] = request.openGroupSetId;
        }
        if (!tea_util_1.default.isUnset(request.ownerUserId)) {
            body["ownerUserId"] = request.ownerUserId;
        }
        if (!tea_util_1.default.isUnset(request.templateId)) {
            body["templateId"] = request.templateId;
        }
        if (!tea_util_1.default.isUnset(request.welcome)) {
            body["welcome"] = request.welcome;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateGroupSet",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/groupSets/set`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "boolean",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateGroupSetResponse({}));
    }
    async updateGroupSet(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateGroupSetHeaders({});
        return await this.updateGroupSetWithOptions(request, headers, runtime);
    }
    async updateRelationMetaFieldWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.fieldDTOList)) {
            body["fieldDTOList"] = request.fieldDTOList;
        }
        if (!tea_util_1.default.isUnset(request.operatorUserId)) {
            body["operatorUserId"] = request.operatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.relationType)) {
            body["relationType"] = request.relationType;
        }
        if (!tea_util_1.default.isUnset(request.tenant)) {
            body["tenant"] = request.tenant;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateRelationMetaField",
            version: "crm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/crm/relations/metas/fields`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateRelationMetaFieldResponse({}));
    }
    async updateRelationMetaField(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateRelationMetaFieldHeaders({});
        return await this.updateRelationMetaFieldWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map