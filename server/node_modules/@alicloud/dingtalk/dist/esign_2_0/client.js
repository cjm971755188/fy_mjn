"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class ApprovalListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ApprovalListHeaders = ApprovalListHeaders;
class ApprovalListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': ApprovalListResponseBodyData },
        };
    }
}
exports.ApprovalListResponseBody = ApprovalListResponseBody;
class ApprovalListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ApprovalListResponseBody,
        };
    }
}
exports.ApprovalListResponse = ApprovalListResponse;
class CancelCorpAuthHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CancelCorpAuthHeaders = CancelCorpAuthHeaders;
class CancelCorpAuthRequest extends $tea.Model {
    static names() {
        return {};
    }
    static types() {
        return {};
    }
    constructor(map) {
        super(map);
    }
}
exports.CancelCorpAuthRequest = CancelCorpAuthRequest;
class CancelCorpAuthResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.CancelCorpAuthResponseBody = CancelCorpAuthResponseBody;
class CancelCorpAuthResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelCorpAuthResponseBody,
        };
    }
}
exports.CancelCorpAuthResponse = CancelCorpAuthResponse;
class ChannelOrdersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ChannelOrdersHeaders = ChannelOrdersHeaders;
class ChannelOrdersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            itemCode: 'itemCode',
            itemName: 'itemName',
            orderCreateTime: 'orderCreateTime',
            orderId: 'orderId',
            payFee: 'payFee',
            quantity: 'quantity',
        };
    }
    static types() {
        return {
            itemCode: 'string',
            itemName: 'string',
            orderCreateTime: 'number',
            orderId: 'string',
            payFee: 'number',
            quantity: 'number',
        };
    }
}
exports.ChannelOrdersRequest = ChannelOrdersRequest;
class ChannelOrdersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            esignOrderId: 'esignOrderId',
        };
    }
    static types() {
        return {
            esignOrderId: 'string',
        };
    }
}
exports.ChannelOrdersResponseBody = ChannelOrdersResponseBody;
class ChannelOrdersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ChannelOrdersResponseBody,
        };
    }
}
exports.ChannelOrdersResponse = ChannelOrdersResponse;
class CorpRealnameHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CorpRealnameHeaders = CorpRealnameHeaders;
class CorpRealnameRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            redirectUrl: 'redirectUrl',
            userId: 'userId',
        };
    }
    static types() {
        return {
            redirectUrl: 'string',
            userId: 'string',
        };
    }
}
exports.CorpRealnameRequest = CorpRealnameRequest;
class CorpRealnameResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mobileUrl: 'mobileUrl',
            pcUrl: 'pcUrl',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            mobileUrl: 'string',
            pcUrl: 'string',
            taskId: 'string',
        };
    }
}
exports.CorpRealnameResponseBody = CorpRealnameResponseBody;
class CorpRealnameResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CorpRealnameResponseBody,
        };
    }
}
exports.CorpRealnameResponse = CorpRealnameResponse;
class CreateDevelopersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateDevelopersHeaders = CreateDevelopersHeaders;
class CreateDevelopersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            noticeUrl: 'noticeUrl',
        };
    }
    static types() {
        return {
            noticeUrl: 'string',
        };
    }
}
exports.CreateDevelopersRequest = CreateDevelopersRequest;
class CreateDevelopersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: 'boolean',
        };
    }
}
exports.CreateDevelopersResponseBody = CreateDevelopersResponseBody;
class CreateDevelopersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateDevelopersResponseBody,
        };
    }
}
exports.CreateDevelopersResponse = CreateDevelopersResponse;
class CreateProcessHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateProcessHeaders = CreateProcessHeaders;
class CreateProcessRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            ccs: 'ccs',
            files: 'files',
            initiatorUserId: 'initiatorUserId',
            participants: 'participants',
            redirectUrl: 'redirectUrl',
            signEndTime: 'signEndTime',
            sourceInfo: 'sourceInfo',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            ccs: { 'type': 'array', 'itemType': CreateProcessRequestCcs },
            files: { 'type': 'array', 'itemType': CreateProcessRequestFiles },
            initiatorUserId: 'string',
            participants: { 'type': 'array', 'itemType': CreateProcessRequestParticipants },
            redirectUrl: 'string',
            signEndTime: 'number',
            sourceInfo: CreateProcessRequestSourceInfo,
            taskName: 'string',
        };
    }
}
exports.CreateProcessRequest = CreateProcessRequest;
class CreateProcessResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            taskId: 'string',
        };
    }
}
exports.CreateProcessResponseBody = CreateProcessResponseBody;
class CreateProcessResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateProcessResponseBody,
        };
    }
}
exports.CreateProcessResponse = CreateProcessResponse;
class GetAttachsApprovalHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            tsignOpenAppId: 'tsignOpenAppId',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            tsignOpenAppId: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetAttachsApprovalHeaders = GetAttachsApprovalHeaders;
class GetAttachsApprovalResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': GetAttachsApprovalResponseBodyData },
        };
    }
}
exports.GetAttachsApprovalResponseBody = GetAttachsApprovalResponseBody;
class GetAttachsApprovalResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAttachsApprovalResponseBody,
        };
    }
}
exports.GetAttachsApprovalResponse = GetAttachsApprovalResponse;
class GetAuthUrlHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetAuthUrlHeaders = GetAuthUrlHeaders;
class GetAuthUrlRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            redirectUrl: 'redirectUrl',
        };
    }
    static types() {
        return {
            redirectUrl: 'string',
        };
    }
}
exports.GetAuthUrlRequest = GetAuthUrlRequest;
class GetAuthUrlResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mobileUrl: 'mobileUrl',
            pcUrl: 'pcUrl',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            mobileUrl: 'string',
            pcUrl: 'string',
            taskId: 'string',
        };
    }
}
exports.GetAuthUrlResponseBody = GetAuthUrlResponseBody;
class GetAuthUrlResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetAuthUrlResponseBody,
        };
    }
}
exports.GetAuthUrlResponse = GetAuthUrlResponse;
class GetContractMarginHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetContractMarginHeaders = GetContractMarginHeaders;
class GetContractMarginResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            margin: 'margin',
        };
    }
    static types() {
        return {
            margin: 'number',
        };
    }
}
exports.GetContractMarginResponseBody = GetContractMarginResponseBody;
class GetContractMarginResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetContractMarginResponseBody,
        };
    }
}
exports.GetContractMarginResponse = GetContractMarginResponse;
class GetCorpConsoleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCorpConsoleHeaders = GetCorpConsoleHeaders;
class GetCorpConsoleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orgConsoleUrl: 'orgConsoleUrl',
        };
    }
    static types() {
        return {
            orgConsoleUrl: 'string',
        };
    }
}
exports.GetCorpConsoleResponseBody = GetCorpConsoleResponseBody;
class GetCorpConsoleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCorpConsoleResponseBody,
        };
    }
}
exports.GetCorpConsoleResponse = GetCorpConsoleResponse;
class GetCorpInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetCorpInfoHeaders = GetCorpInfoHeaders;
class GetCorpInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isRealName: 'isRealName',
            orgRealName: 'orgRealName',
        };
    }
    static types() {
        return {
            isRealName: 'string',
            orgRealName: 'string',
        };
    }
}
exports.GetCorpInfoResponseBody = GetCorpInfoResponseBody;
class GetCorpInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetCorpInfoResponseBody,
        };
    }
}
exports.GetCorpInfoResponse = GetCorpInfoResponse;
class GetExecuteUrlHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetExecuteUrlHeaders = GetExecuteUrlHeaders;
class GetExecuteUrlRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            account: 'account',
            signContainer: 'signContainer',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            account: 'string',
            signContainer: 'number',
            taskId: 'string',
        };
    }
}
exports.GetExecuteUrlRequest = GetExecuteUrlRequest;
class GetExecuteUrlResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            longUrl: 'longUrl',
            mobileUrl: 'mobileUrl',
            pcUrl: 'pcUrl',
            shortUrl: 'shortUrl',
        };
    }
    static types() {
        return {
            longUrl: 'string',
            mobileUrl: 'string',
            pcUrl: 'string',
            shortUrl: 'string',
        };
    }
}
exports.GetExecuteUrlResponseBody = GetExecuteUrlResponseBody;
class GetExecuteUrlResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetExecuteUrlResponseBody,
        };
    }
}
exports.GetExecuteUrlResponse = GetExecuteUrlResponse;
class GetFileInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileInfoHeaders = GetFileInfoHeaders;
class GetFileInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            downloadUrl: 'downloadUrl',
            fileId: 'fileId',
            name: 'name',
            pdfTotalPages: 'pdfTotalPages',
            size: 'size',
            status: 'status',
        };
    }
    static types() {
        return {
            downloadUrl: 'string',
            fileId: 'string',
            name: 'string',
            pdfTotalPages: 'number',
            size: 'number',
            status: 'number',
        };
    }
}
exports.GetFileInfoResponseBody = GetFileInfoResponseBody;
class GetFileInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFileInfoResponseBody,
        };
    }
}
exports.GetFileInfoResponse = GetFileInfoResponse;
class GetFileUploadUrlHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFileUploadUrlHeaders = GetFileUploadUrlHeaders;
class GetFileUploadUrlRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            contentMd5: 'contentMd5',
            contentType: 'contentType',
            convert2Pdf: 'convert2Pdf',
            fileName: 'fileName',
            fileSize: 'fileSize',
        };
    }
    static types() {
        return {
            contentMd5: 'string',
            contentType: 'string',
            convert2Pdf: 'boolean',
            fileName: 'string',
            fileSize: 'number',
        };
    }
}
exports.GetFileUploadUrlRequest = GetFileUploadUrlRequest;
class GetFileUploadUrlResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            uploadUrl: 'uploadUrl',
        };
    }
    static types() {
        return {
            fileId: 'string',
            uploadUrl: 'string',
        };
    }
}
exports.GetFileUploadUrlResponseBody = GetFileUploadUrlResponseBody;
class GetFileUploadUrlResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFileUploadUrlResponseBody,
        };
    }
}
exports.GetFileUploadUrlResponse = GetFileUploadUrlResponse;
class GetFlowDetailHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFlowDetailHeaders = GetFlowDetailHeaders;
class GetFlowDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            businessScene: 'businessScene',
            flowStatus: 'flowStatus',
            initiatorAuthorizedName: 'initiatorAuthorizedName',
            initiatorName: 'initiatorName',
            logs: 'logs',
        };
    }
    static types() {
        return {
            businessScene: 'string',
            flowStatus: 'number',
            initiatorAuthorizedName: 'string',
            initiatorName: 'string',
            logs: { 'type': 'array', 'itemType': GetFlowDetailResponseBodyLogs },
        };
    }
}
exports.GetFlowDetailResponseBody = GetFlowDetailResponseBody;
class GetFlowDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFlowDetailResponseBody,
        };
    }
}
exports.GetFlowDetailResponse = GetFlowDetailResponse;
class GetFlowDocsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetFlowDocsHeaders = GetFlowDocsHeaders;
class GetFlowDocsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': GetFlowDocsResponseBodyData },
        };
    }
}
exports.GetFlowDocsResponseBody = GetFlowDocsResponseBody;
class GetFlowDocsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetFlowDocsResponseBody,
        };
    }
}
exports.GetFlowDocsResponse = GetFlowDocsResponse;
class GetIsvStatusHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetIsvStatusHeaders = GetIsvStatusHeaders;
class GetIsvStatusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            authStatus: 'authStatus',
            installStatus: 'installStatus',
        };
    }
    static types() {
        return {
            authStatus: 'string',
            installStatus: 'string',
        };
    }
}
exports.GetIsvStatusResponseBody = GetIsvStatusResponseBody;
class GetIsvStatusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetIsvStatusResponseBody,
        };
    }
}
exports.GetIsvStatusResponse = GetIsvStatusResponse;
class GetSignDetailHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetSignDetailHeaders = GetSignDetailHeaders;
class GetSignDetailResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            businessScene: 'businessScene',
            flowStatus: 'flowStatus',
            signers: 'signers',
        };
    }
    static types() {
        return {
            businessScene: 'string',
            flowStatus: 'number',
            signers: { 'type': 'array', 'itemType': GetSignDetailResponseBodySigners },
        };
    }
}
exports.GetSignDetailResponseBody = GetSignDetailResponseBody;
class GetSignDetailResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetSignDetailResponseBody,
        };
    }
}
exports.GetSignDetailResponse = GetSignDetailResponse;
class GetUserInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetUserInfoHeaders = GetUserInfoHeaders;
class GetUserInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            isRealName: 'isRealName',
            userRealName: 'userRealName',
        };
    }
    static types() {
        return {
            isRealName: 'string',
            userRealName: 'string',
        };
    }
}
exports.GetUserInfoResponseBody = GetUserInfoResponseBody;
class GetUserInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserInfoResponseBody,
        };
    }
}
exports.GetUserInfoResponse = GetUserInfoResponse;
class ProcessStartHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ProcessStartHeaders = ProcessStartHeaders;
class ProcessStartRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            autoStart: 'autoStart',
            ccs: 'ccs',
            files: 'files',
            initiatorUserId: 'initiatorUserId',
            participants: 'participants',
            redirectUrl: 'redirectUrl',
            sourceInfo: 'sourceInfo',
            taskName: 'taskName',
        };
    }
    static types() {
        return {
            autoStart: 'string',
            ccs: { 'type': 'array', 'itemType': ProcessStartRequestCcs },
            files: { 'type': 'array', 'itemType': ProcessStartRequestFiles },
            initiatorUserId: 'string',
            participants: { 'type': 'array', 'itemType': ProcessStartRequestParticipants },
            redirectUrl: 'string',
            sourceInfo: ProcessStartRequestSourceInfo,
            taskName: 'string',
        };
    }
}
exports.ProcessStartRequest = ProcessStartRequest;
class ProcessStartResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mobileUrl: 'mobileUrl',
            pcUrl: 'pcUrl',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            mobileUrl: 'string',
            pcUrl: 'string',
            taskId: 'string',
        };
    }
}
exports.ProcessStartResponseBody = ProcessStartResponseBody;
class ProcessStartResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ProcessStartResponseBody,
        };
    }
}
exports.ProcessStartResponse = ProcessStartResponse;
class ResaleOrderHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ResaleOrderHeaders = ResaleOrderHeaders;
class ResaleOrderRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            orderCreateTime: 'orderCreateTime',
            orderId: 'orderId',
            quantity: 'quantity',
            serviceStartTime: 'serviceStartTime',
            serviceStopTime: 'serviceStopTime',
        };
    }
    static types() {
        return {
            orderCreateTime: 'number',
            orderId: 'string',
            quantity: 'number',
            serviceStartTime: 'number',
            serviceStopTime: 'number',
        };
    }
}
exports.ResaleOrderRequest = ResaleOrderRequest;
class ResaleOrderResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            esignOrderId: 'esignOrderId',
        };
    }
    static types() {
        return {
            esignOrderId: 'string',
        };
    }
}
exports.ResaleOrderResponseBody = ResaleOrderResponseBody;
class ResaleOrderResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ResaleOrderResponseBody,
        };
    }
}
exports.ResaleOrderResponse = ResaleOrderResponse;
class UsersRealnameHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            serviceGroup: 'serviceGroup',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            serviceGroup: 'string',
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UsersRealnameHeaders = UsersRealnameHeaders;
class UsersRealnameRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            redirectUrl: 'redirectUrl',
            userId: 'userId',
        };
    }
    static types() {
        return {
            redirectUrl: 'string',
            userId: 'string',
        };
    }
}
exports.UsersRealnameRequest = UsersRealnameRequest;
class UsersRealnameResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mobileUrl: 'mobileUrl',
            pcUrl: 'pcUrl',
            taskId: 'taskId',
        };
    }
    static types() {
        return {
            mobileUrl: 'string',
            pcUrl: 'string',
            taskId: 'string',
        };
    }
}
exports.UsersRealnameResponseBody = UsersRealnameResponseBody;
class UsersRealnameResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UsersRealnameResponseBody,
        };
    }
}
exports.UsersRealnameResponse = UsersRealnameResponse;
class ApprovalListResponseBodyDataApprovalNodes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            approvalTime: 'approvalTime',
            approverName: 'approverName',
            startTime: 'startTime',
            status: 'status',
        };
    }
    static types() {
        return {
            approvalTime: 'string',
            approverName: 'string',
            startTime: 'number',
            status: 'string',
        };
    }
}
exports.ApprovalListResponseBodyDataApprovalNodes = ApprovalListResponseBodyDataApprovalNodes;
class ApprovalListResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            approvalName: 'approvalName',
            approvalNodes: 'approvalNodes',
            endTime: 'endTime',
            refuseReason: 'refuseReason',
            sealIdImg: 'sealIdImg',
            sponsorAccountName: 'sponsorAccountName',
            startTime: 'startTime',
            status: 'status',
        };
    }
    static types() {
        return {
            approvalName: 'string',
            approvalNodes: { 'type': 'array', 'itemType': ApprovalListResponseBodyDataApprovalNodes },
            endTime: 'number',
            refuseReason: 'string',
            sealIdImg: 'string',
            sponsorAccountName: 'string',
            startTime: 'number',
            status: 'string',
        };
    }
}
exports.ApprovalListResponseBodyData = ApprovalListResponseBodyData;
class CreateProcessRequestCcs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            account: 'account',
            accountName: 'accountName',
            accountType: 'accountType',
            orgName: 'orgName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            account: 'string',
            accountName: 'string',
            accountType: 'string',
            orgName: 'string',
            userId: 'string',
        };
    }
}
exports.CreateProcessRequestCcs = CreateProcessRequestCcs;
class CreateProcessRequestFiles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            fileName: 'fileName',
            fileType: 'fileType',
        };
    }
    static types() {
        return {
            fileId: 'string',
            fileName: 'string',
            fileType: 'number',
        };
    }
}
exports.CreateProcessRequestFiles = CreateProcessRequestFiles;
class CreateProcessRequestParticipantsSignPosListSignDate extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            format: 'format',
        };
    }
    static types() {
        return {
            format: 'string',
        };
    }
}
exports.CreateProcessRequestParticipantsSignPosListSignDate = CreateProcessRequestParticipantsSignPosListSignDate;
class CreateProcessRequestParticipantsSignPosList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            isCrossPage: 'isCrossPage',
            needSignDate: 'needSignDate',
            page: 'page',
            signDate: 'signDate',
            signRequirement: 'signRequirement',
            x: 'x',
            y: 'y',
        };
    }
    static types() {
        return {
            fileId: 'string',
            isCrossPage: 'boolean',
            needSignDate: 'boolean',
            page: 'string',
            signDate: CreateProcessRequestParticipantsSignPosListSignDate,
            signRequirement: 'string',
            x: 'number',
            y: 'number',
        };
    }
}
exports.CreateProcessRequestParticipantsSignPosList = CreateProcessRequestParticipantsSignPosList;
class CreateProcessRequestParticipants extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            account: 'account',
            accountName: 'accountName',
            accountType: 'accountType',
            orgName: 'orgName',
            signOrder: 'signOrder',
            signPosList: 'signPosList',
            signRequirements: 'signRequirements',
            userId: 'userId',
        };
    }
    static types() {
        return {
            account: 'string',
            accountName: 'string',
            accountType: 'string',
            orgName: 'string',
            signOrder: 'number',
            signPosList: { 'type': 'array', 'itemType': CreateProcessRequestParticipantsSignPosList },
            signRequirements: 'string',
            userId: 'string',
        };
    }
}
exports.CreateProcessRequestParticipants = CreateProcessRequestParticipants;
class CreateProcessRequestSourceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mobileUrl: 'mobileUrl',
            pcUrl: 'pcUrl',
            showText: 'showText',
        };
    }
    static types() {
        return {
            mobileUrl: 'string',
            pcUrl: 'string',
            showText: 'string',
        };
    }
}
exports.CreateProcessRequestSourceInfo = CreateProcessRequestSourceInfo;
class GetAttachsApprovalResponseBodyDataFiles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileName: 'fileName',
            originalFileUrl: 'originalFileUrl',
            signFinishFileUrl: 'signFinishFileUrl',
        };
    }
    static types() {
        return {
            fileName: 'string',
            originalFileUrl: 'string',
            signFinishFileUrl: 'string',
        };
    }
}
exports.GetAttachsApprovalResponseBodyDataFiles = GetAttachsApprovalResponseBodyDataFiles;
class GetAttachsApprovalResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            files: 'files',
            flowId: 'flowId',
            status: 'status',
        };
    }
    static types() {
        return {
            files: { 'type': 'array', 'itemType': GetAttachsApprovalResponseBodyDataFiles },
            flowId: 'string',
            status: 'string',
        };
    }
}
exports.GetAttachsApprovalResponseBodyData = GetAttachsApprovalResponseBodyData;
class GetFlowDetailResponseBodyLogs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            logType: 'logType',
            operateDescription: 'operateDescription',
            operateTime: 'operateTime',
            operatorAccountName: 'operatorAccountName',
        };
    }
    static types() {
        return {
            logType: 'string',
            operateDescription: 'string',
            operateTime: 'number',
            operatorAccountName: 'string',
        };
    }
}
exports.GetFlowDetailResponseBodyLogs = GetFlowDetailResponseBodyLogs;
class GetFlowDocsResponseBodyData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            fileName: 'fileName',
            fileUrl: 'fileUrl',
        };
    }
    static types() {
        return {
            fileId: 'string',
            fileName: 'string',
            fileUrl: 'string',
        };
    }
}
exports.GetFlowDocsResponseBodyData = GetFlowDocsResponseBodyData;
class GetSignDetailResponseBodySigners extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            signStatus: 'signStatus',
            signerName: 'signerName',
        };
    }
    static types() {
        return {
            signStatus: 'number',
            signerName: 'string',
        };
    }
}
exports.GetSignDetailResponseBodySigners = GetSignDetailResponseBodySigners;
class ProcessStartRequestCcs extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            account: 'account',
            accountName: 'accountName',
            accountType: 'accountType',
            orgName: 'orgName',
            userId: 'userId',
        };
    }
    static types() {
        return {
            account: 'string',
            accountName: 'string',
            accountType: 'string',
            orgName: 'string',
            userId: 'string',
        };
    }
}
exports.ProcessStartRequestCcs = ProcessStartRequestCcs;
class ProcessStartRequestFiles extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fileId: 'fileId',
            fileName: 'fileName',
        };
    }
    static types() {
        return {
            fileId: 'string',
            fileName: 'string',
        };
    }
}
exports.ProcessStartRequestFiles = ProcessStartRequestFiles;
class ProcessStartRequestParticipants extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            account: 'account',
            accountName: 'accountName',
            accountType: 'accountType',
            orgName: 'orgName',
            signRequirements: 'signRequirements',
            userId: 'userId',
        };
    }
    static types() {
        return {
            account: 'string',
            accountName: 'string',
            accountType: 'string',
            orgName: 'string',
            signRequirements: 'string',
            userId: 'string',
        };
    }
}
exports.ProcessStartRequestParticipants = ProcessStartRequestParticipants;
class ProcessStartRequestSourceInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mobileUrl: 'mobileUrl',
            pcUrl: 'pcUrl',
            showText: 'showText',
        };
    }
    static types() {
        return {
            mobileUrl: 'string',
            pcUrl: 'string',
            showText: 'string',
        };
    }
}
exports.ProcessStartRequestSourceInfo = ProcessStartRequestSourceInfo;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async approvalListWithOptions(taskId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "ApprovalList",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/approvals/${taskId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ApprovalListResponse({}));
    }
    async approvalList(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ApprovalListHeaders({});
        return await this.approvalListWithOptions(taskId, headers, runtime);
    }
    async cancelCorpAuthWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "CancelCorpAuth",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/auths/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CancelCorpAuthResponse({}));
    }
    async cancelCorpAuth(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CancelCorpAuthHeaders({});
        return await this.cancelCorpAuthWithOptions(request, headers, runtime);
    }
    async channelOrdersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.itemCode)) {
            body["itemCode"] = request.itemCode;
        }
        if (!tea_util_1.default.isUnset(request.itemName)) {
            body["itemName"] = request.itemName;
        }
        if (!tea_util_1.default.isUnset(request.orderCreateTime)) {
            body["orderCreateTime"] = request.orderCreateTime;
        }
        if (!tea_util_1.default.isUnset(request.orderId)) {
            body["orderId"] = request.orderId;
        }
        if (!tea_util_1.default.isUnset(request.payFee)) {
            body["payFee"] = request.payFee;
        }
        if (!tea_util_1.default.isUnset(request.quantity)) {
            body["quantity"] = request.quantity;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ChannelOrders",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/orders/channel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ChannelOrdersResponse({}));
    }
    async channelOrders(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ChannelOrdersHeaders({});
        return await this.channelOrdersWithOptions(request, headers, runtime);
    }
    async corpRealnameWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.redirectUrl)) {
            body["redirectUrl"] = request.redirectUrl;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CorpRealname",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/corps/realnames`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CorpRealnameResponse({}));
    }
    async corpRealname(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CorpRealnameHeaders({});
        return await this.corpRealnameWithOptions(request, headers, runtime);
    }
    async createDevelopersWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.noticeUrl)) {
            body["noticeUrl"] = request.noticeUrl;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateDevelopers",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/developers`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateDevelopersResponse({}));
    }
    async createDevelopers(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateDevelopersHeaders({});
        return await this.createDevelopersWithOptions(request, headers, runtime);
    }
    async createProcessWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.ccs)) {
            body["ccs"] = request.ccs;
        }
        if (!tea_util_1.default.isUnset(request.files)) {
            body["files"] = request.files;
        }
        if (!tea_util_1.default.isUnset(request.initiatorUserId)) {
            body["initiatorUserId"] = request.initiatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.participants)) {
            body["participants"] = request.participants;
        }
        if (!tea_util_1.default.isUnset(request.redirectUrl)) {
            body["redirectUrl"] = request.redirectUrl;
        }
        if (!tea_util_1.default.isUnset(request.signEndTime)) {
            body["signEndTime"] = request.signEndTime;
        }
        if (!tea_util_1.default.isUnset(request.sourceInfo)) {
            body["sourceInfo"] = request.sourceInfo;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            body["taskName"] = request.taskName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateProcess",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/process/startAtOnce`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateProcessResponse({}));
    }
    async createProcess(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateProcessHeaders({});
        return await this.createProcessWithOptions(request, headers, runtime);
    }
    async getAttachsApprovalWithOptions(instanceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.tsignOpenAppId)) {
            realHeaders["tsignOpenAppId"] = tea_util_1.default.toJSONString(headers.tsignOpenAppId);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetAttachsApproval",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/dingInstances/${instanceId}/attachments`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAttachsApprovalResponse({}));
    }
    async getAttachsApproval(instanceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAttachsApprovalHeaders({});
        return await this.getAttachsApprovalWithOptions(instanceId, headers, runtime);
    }
    async getAuthUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.redirectUrl)) {
            body["redirectUrl"] = request.redirectUrl;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetAuthUrl",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/auths/urls`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetAuthUrlResponse({}));
    }
    async getAuthUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetAuthUrlHeaders({});
        return await this.getAuthUrlWithOptions(request, headers, runtime);
    }
    async getContractMarginWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetContractMargin",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/margins`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetContractMarginResponse({}));
    }
    async getContractMargin() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetContractMarginHeaders({});
        return await this.getContractMarginWithOptions(headers, runtime);
    }
    async getCorpConsoleWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetCorpConsole",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/corps/consoles`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCorpConsoleResponse({}));
    }
    async getCorpConsole() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCorpConsoleHeaders({});
        return await this.getCorpConsoleWithOptions(headers, runtime);
    }
    async getCorpInfoWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetCorpInfo",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/corps/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetCorpInfoResponse({}));
    }
    async getCorpInfo() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetCorpInfoHeaders({});
        return await this.getCorpInfoWithOptions(headers, runtime);
    }
    async getExecuteUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.account)) {
            body["account"] = request.account;
        }
        if (!tea_util_1.default.isUnset(request.signContainer)) {
            body["signContainer"] = request.signContainer;
        }
        if (!tea_util_1.default.isUnset(request.taskId)) {
            body["taskId"] = request.taskId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetExecuteUrl",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/process/executeUrls`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetExecuteUrlResponse({}));
    }
    async getExecuteUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetExecuteUrlHeaders({});
        return await this.getExecuteUrlWithOptions(request, headers, runtime);
    }
    async getFileInfoWithOptions(fileId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetFileInfo",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/files/${fileId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFileInfoResponse({}));
    }
    async getFileInfo(fileId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileInfoHeaders({});
        return await this.getFileInfoWithOptions(fileId, headers, runtime);
    }
    async getFileUploadUrlWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.contentMd5)) {
            body["contentMd5"] = request.contentMd5;
        }
        if (!tea_util_1.default.isUnset(request.contentType)) {
            body["contentType"] = request.contentType;
        }
        if (!tea_util_1.default.isUnset(request.convert2Pdf)) {
            body["convert2Pdf"] = request.convert2Pdf;
        }
        if (!tea_util_1.default.isUnset(request.fileName)) {
            body["fileName"] = request.fileName;
        }
        if (!tea_util_1.default.isUnset(request.fileSize)) {
            body["fileSize"] = request.fileSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "GetFileUploadUrl",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/files/uploadUrls`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFileUploadUrlResponse({}));
    }
    async getFileUploadUrl(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFileUploadUrlHeaders({});
        return await this.getFileUploadUrlWithOptions(request, headers, runtime);
    }
    async getFlowDetailWithOptions(taskId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetFlowDetail",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/flowTasks/${taskId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFlowDetailResponse({}));
    }
    async getFlowDetail(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFlowDetailHeaders({});
        return await this.getFlowDetailWithOptions(taskId, headers, runtime);
    }
    async getFlowDocsWithOptions(taskId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetFlowDocs",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/flowTasks/${taskId}/docs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetFlowDocsResponse({}));
    }
    async getFlowDocs(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetFlowDocsHeaders({});
        return await this.getFlowDocsWithOptions(taskId, headers, runtime);
    }
    async getIsvStatusWithOptions(headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetIsvStatus",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/corps/appStatus`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetIsvStatusResponse({}));
    }
    async getIsvStatus() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetIsvStatusHeaders({});
        return await this.getIsvStatusWithOptions(headers, runtime);
    }
    async getSignDetailWithOptions(taskId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetSignDetail",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/signTasks/${taskId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetSignDetailResponse({}));
    }
    async getSignDetail(taskId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetSignDetailHeaders({});
        return await this.getSignDetailWithOptions(taskId, headers, runtime);
    }
    async getUserInfoWithOptions(userId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "GetUserInfo",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/users/${userId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserInfoResponse({}));
    }
    async getUserInfo(userId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserInfoHeaders({});
        return await this.getUserInfoWithOptions(userId, headers, runtime);
    }
    async processStartWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.autoStart)) {
            body["autoStart"] = request.autoStart;
        }
        if (!tea_util_1.default.isUnset(request.ccs)) {
            body["ccs"] = request.ccs;
        }
        if (!tea_util_1.default.isUnset(request.files)) {
            body["files"] = request.files;
        }
        if (!tea_util_1.default.isUnset(request.initiatorUserId)) {
            body["initiatorUserId"] = request.initiatorUserId;
        }
        if (!tea_util_1.default.isUnset(request.participants)) {
            body["participants"] = request.participants;
        }
        if (!tea_util_1.default.isUnset(request.redirectUrl)) {
            body["redirectUrl"] = request.redirectUrl;
        }
        if (!tea_util_1.default.isUnset(request.sourceInfo)) {
            body["sourceInfo"] = request.sourceInfo;
        }
        if (!tea_util_1.default.isUnset(request.taskName)) {
            body["taskName"] = request.taskName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ProcessStart",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/processes/startUrls`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ProcessStartResponse({}));
    }
    async processStart(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ProcessStartHeaders({});
        return await this.processStartWithOptions(request, headers, runtime);
    }
    async resaleOrderWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.orderCreateTime)) {
            body["orderCreateTime"] = request.orderCreateTime;
        }
        if (!tea_util_1.default.isUnset(request.orderId)) {
            body["orderId"] = request.orderId;
        }
        if (!tea_util_1.default.isUnset(request.quantity)) {
            body["quantity"] = request.quantity;
        }
        if (!tea_util_1.default.isUnset(request.serviceStartTime)) {
            body["serviceStartTime"] = request.serviceStartTime;
        }
        if (!tea_util_1.default.isUnset(request.serviceStopTime)) {
            body["serviceStopTime"] = request.serviceStopTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "ResaleOrder",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/orders/resale`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ResaleOrderResponse({}));
    }
    async resaleOrder(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ResaleOrderHeaders({});
        return await this.resaleOrderWithOptions(request, headers, runtime);
    }
    async usersRealnameWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.redirectUrl)) {
            body["redirectUrl"] = request.redirectUrl;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.serviceGroup)) {
            realHeaders["serviceGroup"] = tea_util_1.default.toJSONString(headers.serviceGroup);
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UsersRealname",
            version: "esign_2.0",
            protocol: "HTTP",
            pathname: `/v2.0/esign/users/realnames`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UsersRealnameResponse({}));
    }
    async usersRealname(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UsersRealnameHeaders({});
        return await this.usersRealnameWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map