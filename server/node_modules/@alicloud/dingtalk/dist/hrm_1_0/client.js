"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class AddHrmPreentryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddHrmPreentryHeaders = AddHrmPreentryHeaders;
class AddHrmPreentryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            agentId: 'agentId',
            groups: 'groups',
            mobile: 'mobile',
            name: 'name',
            needSendPreEntryMsg: 'needSendPreEntryMsg',
            preEntryTime: 'preEntryTime',
        };
    }
    static types() {
        return {
            agentId: 'number',
            groups: { 'type': 'array', 'itemType': AddHrmPreentryRequestGroups },
            mobile: 'string',
            name: 'string',
            needSendPreEntryMsg: 'boolean',
            preEntryTime: 'number',
        };
    }
}
exports.AddHrmPreentryRequest = AddHrmPreentryRequest;
class AddHrmPreentryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tmpUserId: 'tmpUserId',
        };
    }
    static types() {
        return {
            tmpUserId: 'string',
        };
    }
}
exports.AddHrmPreentryResponseBody = AddHrmPreentryResponseBody;
class AddHrmPreentryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddHrmPreentryResponseBody,
        };
    }
}
exports.AddHrmPreentryResponse = AddHrmPreentryResponse;
class DeviceMarketManagerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeviceMarketManagerResponseBody = DeviceMarketManagerResponseBody;
class DeviceMarketManagerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeviceMarketManagerResponseBody,
        };
    }
}
exports.DeviceMarketManagerResponse = DeviceMarketManagerResponse;
class DeviceMarketOrderManagerResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            requestId: 'string',
        };
    }
}
exports.DeviceMarketOrderManagerResponseBody = DeviceMarketOrderManagerResponseBody;
class DeviceMarketOrderManagerResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeviceMarketOrderManagerResponseBody,
        };
    }
}
exports.DeviceMarketOrderManagerResponse = DeviceMarketOrderManagerResponse;
class ECertQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.ECertQueryHeaders = ECertQueryHeaders;
class ECertQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userId: 'userId',
        };
    }
    static types() {
        return {
            userId: 'string',
        };
    }
}
exports.ECertQueryRequest = ECertQueryRequest;
class ECertQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            certNO: 'certNO',
            employJobId: 'employJobId',
            employJobIdLabel: 'employJobIdLabel',
            employPositionId: 'employPositionId',
            employPositionIdLabel: 'employPositionIdLabel',
            employPositionRankId: 'employPositionRankId',
            employPositionRankIdLabel: 'employPositionRankIdLabel',
            hiredDate: 'hiredDate',
            lastWorkDay: 'lastWorkDay',
            mainDeptId: 'mainDeptId',
            mainDeptName: 'mainDeptName',
            name: 'name',
            realName: 'realName',
            terminationReasonPassive: 'terminationReasonPassive',
            terminationReasonVoluntary: 'terminationReasonVoluntary',
        };
    }
    static types() {
        return {
            certNO: 'string',
            employJobId: 'string',
            employJobIdLabel: 'string',
            employPositionId: 'string',
            employPositionIdLabel: 'string',
            employPositionRankId: 'string',
            employPositionRankIdLabel: 'string',
            hiredDate: 'string',
            lastWorkDay: 'string',
            mainDeptId: 'number',
            mainDeptName: 'string',
            name: 'string',
            realName: 'string',
            terminationReasonPassive: { 'type': 'array', 'itemType': 'string' },
            terminationReasonVoluntary: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.ECertQueryResponseBody = ECertQueryResponseBody;
class ECertQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: ECertQueryResponseBody,
        };
    }
}
exports.ECertQueryResponse = ECertQueryResponse;
class EsignRollbackHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.EsignRollbackHeaders = EsignRollbackHeaders;
class EsignRollbackRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            optUserId: 'optUserId',
        };
    }
    static types() {
        return {
            optUserId: 'string',
        };
    }
}
exports.EsignRollbackRequest = EsignRollbackRequest;
class EsignRollbackResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.EsignRollbackResponseBody = EsignRollbackResponseBody;
class EsignRollbackResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: EsignRollbackResponseBody,
        };
    }
}
exports.EsignRollbackResponse = EsignRollbackResponse;
class HrmProcessRegularHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.HrmProcessRegularHeaders = HrmProcessRegularHeaders;
class HrmProcessRegularRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operationId: 'operationId',
            regularDate: 'regularDate',
            remark: 'remark',
            userId: 'userId',
        };
    }
    static types() {
        return {
            operationId: 'string',
            regularDate: 'number',
            remark: 'string',
            userId: 'string',
        };
    }
}
exports.HrmProcessRegularRequest = HrmProcessRegularRequest;
class HrmProcessRegularResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.HrmProcessRegularResponseBody = HrmProcessRegularResponseBody;
class HrmProcessRegularResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmProcessRegularResponseBody,
        };
    }
}
exports.HrmProcessRegularResponse = HrmProcessRegularResponse;
class HrmProcessTransferHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.HrmProcessTransferHeaders = HrmProcessTransferHeaders;
class HrmProcessTransferRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptIdsAfterTransfer: 'deptIdsAfterTransfer',
            jobIdAfterTransfer: 'jobIdAfterTransfer',
            mainDeptIdAfterTransfer: 'mainDeptIdAfterTransfer',
            operateUserId: 'operateUserId',
            positionIdAfterTransfer: 'positionIdAfterTransfer',
            positionLevelAfterTransfer: 'positionLevelAfterTransfer',
            positionNameAfterTransfer: 'positionNameAfterTransfer',
            rankIdAfterTransfer: 'rankIdAfterTransfer',
            userId: 'userId',
        };
    }
    static types() {
        return {
            deptIdsAfterTransfer: { 'type': 'array', 'itemType': 'number' },
            jobIdAfterTransfer: 'string',
            mainDeptIdAfterTransfer: 'number',
            operateUserId: 'string',
            positionIdAfterTransfer: 'string',
            positionLevelAfterTransfer: 'string',
            positionNameAfterTransfer: 'string',
            rankIdAfterTransfer: 'string',
            userId: 'string',
        };
    }
}
exports.HrmProcessTransferRequest = HrmProcessTransferRequest;
class HrmProcessTransferResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.HrmProcessTransferResponseBody = HrmProcessTransferResponseBody;
class HrmProcessTransferResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmProcessTransferResponseBody,
        };
    }
}
exports.HrmProcessTransferResponse = HrmProcessTransferResponse;
class HrmProcessUpdateTerminationInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.HrmProcessUpdateTerminationInfoHeaders = HrmProcessUpdateTerminationInfoHeaders;
class HrmProcessUpdateTerminationInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            dismissionMemo: 'dismissionMemo',
            lastWorkDate: 'lastWorkDate',
            userId: 'userId',
        };
    }
    static types() {
        return {
            dismissionMemo: 'string',
            lastWorkDate: 'number',
            userId: 'string',
        };
    }
}
exports.HrmProcessUpdateTerminationInfoRequest = HrmProcessUpdateTerminationInfoRequest;
class HrmProcessUpdateTerminationInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.HrmProcessUpdateTerminationInfoResponseBody = HrmProcessUpdateTerminationInfoResponseBody;
class HrmProcessUpdateTerminationInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: HrmProcessUpdateTerminationInfoResponseBody,
        };
    }
}
exports.HrmProcessUpdateTerminationInfoResponse = HrmProcessUpdateTerminationInfoResponse;
class MasterDataQueryHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MasterDataQueryHeaders = MasterDataQueryHeaders;
class MasterDataQueryRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizUK: 'bizUK',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            optUserId: 'optUserId',
            queryParams: 'queryParams',
            relationIds: 'relationIds',
            scopeCode: 'scopeCode',
            tenantId: 'tenantId',
            viewEntityCode: 'viewEntityCode',
        };
    }
    static types() {
        return {
            bizUK: 'string',
            maxResults: 'number',
            nextToken: 'number',
            optUserId: 'string',
            queryParams: { 'type': 'array', 'itemType': MasterDataQueryRequestQueryParams },
            relationIds: { 'type': 'array', 'itemType': 'string' },
            scopeCode: 'string',
            tenantId: 'number',
            viewEntityCode: 'string',
        };
    }
}
exports.MasterDataQueryRequest = MasterDataQueryRequest;
class MasterDataQueryResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            result: 'result',
            success: 'success',
            total: 'total',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'number',
            result: { 'type': 'array', 'itemType': MasterDataQueryResponseBodyResult },
            success: 'boolean',
            total: 'number',
        };
    }
}
exports.MasterDataQueryResponseBody = MasterDataQueryResponseBody;
class MasterDataQueryResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDataQueryResponseBody,
        };
    }
}
exports.MasterDataQueryResponse = MasterDataQueryResponse;
class MasterDataSaveHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MasterDataSaveHeaders = MasterDataSaveHeaders;
class MasterDataSaveRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
            tenantId: 'tenantId',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': MasterDataSaveRequestBody },
            tenantId: 'number',
        };
    }
}
exports.MasterDataSaveRequest = MasterDataSaveRequest;
class MasterDataSaveResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allSuccess: 'allSuccess',
            failResult: 'failResult',
        };
    }
    static types() {
        return {
            allSuccess: 'boolean',
            failResult: { 'type': 'array', 'itemType': MasterDataSaveResponseBodyFailResult },
        };
    }
}
exports.MasterDataSaveResponseBody = MasterDataSaveResponseBody;
class MasterDataSaveResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDataSaveResponseBody,
        };
    }
}
exports.MasterDataSaveResponse = MasterDataSaveResponse;
class MasterDataTenantQueyHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MasterDataTenantQueyHeaders = MasterDataTenantQueyHeaders;
class MasterDataTenantQueyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            entityCode: 'entityCode',
            scopeCode: 'scopeCode',
        };
    }
    static types() {
        return {
            entityCode: 'string',
            scopeCode: 'string',
        };
    }
}
exports.MasterDataTenantQueyRequest = MasterDataTenantQueyRequest;
class MasterDataTenantQueyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': MasterDataTenantQueyResponseBodyResult },
        };
    }
}
exports.MasterDataTenantQueyResponseBody = MasterDataTenantQueyResponseBody;
class MasterDataTenantQueyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MasterDataTenantQueyResponseBody,
        };
    }
}
exports.MasterDataTenantQueyResponse = MasterDataTenantQueyResponse;
class QueryCustomEntryProcessesHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCustomEntryProcessesHeaders = QueryCustomEntryProcessesHeaders;
class QueryCustomEntryProcessesRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            operateUserId: 'operateUserId',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
            operateUserId: 'string',
        };
    }
}
exports.QueryCustomEntryProcessesRequest = QueryCustomEntryProcessesRequest;
class QueryCustomEntryProcessesResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryCustomEntryProcessesResponseBodyList },
            nextToken: 'number',
        };
    }
}
exports.QueryCustomEntryProcessesResponseBody = QueryCustomEntryProcessesResponseBody;
class QueryCustomEntryProcessesResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCustomEntryProcessesResponseBody,
        };
    }
}
exports.QueryCustomEntryProcessesResponse = QueryCustomEntryProcessesResponse;
class QueryDismissionStaffIdListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryDismissionStaffIdListHeaders = QueryDismissionStaffIdListHeaders;
class QueryDismissionStaffIdListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
        };
    }
}
exports.QueryDismissionStaffIdListRequest = QueryDismissionStaffIdListRequest;
class QueryDismissionStaffIdListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            nextToken: 'nextToken',
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            nextToken: 'number',
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryDismissionStaffIdListResponseBody = QueryDismissionStaffIdListResponseBody;
class QueryDismissionStaffIdListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryDismissionStaffIdListResponseBody,
        };
    }
}
exports.QueryDismissionStaffIdListResponse = QueryDismissionStaffIdListResponse;
class QueryHrmEmployeeDismissionInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryHrmEmployeeDismissionInfoHeaders = QueryHrmEmployeeDismissionInfoHeaders;
class QueryHrmEmployeeDismissionInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userIdList: 'userIdList',
        };
    }
    static types() {
        return {
            userIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryHrmEmployeeDismissionInfoRequest = QueryHrmEmployeeDismissionInfoRequest;
class QueryHrmEmployeeDismissionInfoShrinkRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            userIdListShrink: 'userIdList',
        };
    }
    static types() {
        return {
            userIdListShrink: 'string',
        };
    }
}
exports.QueryHrmEmployeeDismissionInfoShrinkRequest = QueryHrmEmployeeDismissionInfoShrinkRequest;
class QueryHrmEmployeeDismissionInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': QueryHrmEmployeeDismissionInfoResponseBodyResult },
        };
    }
}
exports.QueryHrmEmployeeDismissionInfoResponseBody = QueryHrmEmployeeDismissionInfoResponseBody;
class QueryHrmEmployeeDismissionInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryHrmEmployeeDismissionInfoResponseBody,
        };
    }
}
exports.QueryHrmEmployeeDismissionInfoResponse = QueryHrmEmployeeDismissionInfoResponse;
class QueryJobRanksHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryJobRanksHeaders = QueryJobRanksHeaders;
class QueryJobRanksRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            rankCategoryId: 'rankCategoryId',
            rankCode: 'rankCode',
            rankName: 'rankName',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'number',
            rankCategoryId: 'string',
            rankCode: 'string',
            rankName: 'string',
        };
    }
}
exports.QueryJobRanksRequest = QueryJobRanksRequest;
class QueryJobRanksResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryJobRanksResponseBodyList },
            nextToken: 'number',
        };
    }
}
exports.QueryJobRanksResponseBody = QueryJobRanksResponseBody;
class QueryJobRanksResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryJobRanksResponseBody,
        };
    }
}
exports.QueryJobRanksResponse = QueryJobRanksResponse;
class QueryJobsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryJobsHeaders = QueryJobsHeaders;
class QueryJobsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobName: 'jobName',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            jobName: 'string',
            maxResults: 'number',
            nextToken: 'number',
        };
    }
}
exports.QueryJobsRequest = QueryJobsRequest;
class QueryJobsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryJobsResponseBodyList },
            nextToken: 'number',
        };
    }
}
exports.QueryJobsResponseBody = QueryJobsResponseBody;
class QueryJobsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryJobsResponseBody,
        };
    }
}
exports.QueryJobsResponse = QueryJobsResponse;
class QueryPositionsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryPositionsHeaders = QueryPositionsHeaders;
class QueryPositionsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptId: 'deptId',
            inCategoryIds: 'inCategoryIds',
            inPositionIds: 'inPositionIds',
            positionName: 'positionName',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            deptId: 'number',
            inCategoryIds: { 'type': 'array', 'itemType': 'string' },
            inPositionIds: { 'type': 'array', 'itemType': 'string' },
            positionName: 'string',
            maxResults: 'number',
            nextToken: 'number',
        };
    }
}
exports.QueryPositionsRequest = QueryPositionsRequest;
class QueryPositionsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            list: { 'type': 'array', 'itemType': QueryPositionsResponseBodyList },
            nextToken: 'number',
        };
    }
}
exports.QueryPositionsResponseBody = QueryPositionsResponseBody;
class QueryPositionsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPositionsResponseBody,
        };
    }
}
exports.QueryPositionsResponse = QueryPositionsResponse;
class RosterMetaAvailableFieldListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RosterMetaAvailableFieldListHeaders = RosterMetaAvailableFieldListHeaders;
class RosterMetaAvailableFieldListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appAgentId: 'appAgentId',
        };
    }
    static types() {
        return {
            appAgentId: 'number',
        };
    }
}
exports.RosterMetaAvailableFieldListRequest = RosterMetaAvailableFieldListRequest;
class RosterMetaAvailableFieldListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': RosterMetaAvailableFieldListResponseBodyResult },
        };
    }
}
exports.RosterMetaAvailableFieldListResponseBody = RosterMetaAvailableFieldListResponseBody;
class RosterMetaAvailableFieldListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RosterMetaAvailableFieldListResponseBody,
        };
    }
}
exports.RosterMetaAvailableFieldListResponse = RosterMetaAvailableFieldListResponse;
class RosterMetaFieldOptionsUpdateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.RosterMetaFieldOptionsUpdateHeaders = RosterMetaFieldOptionsUpdateHeaders;
class RosterMetaFieldOptionsUpdateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            appAgentId: 'appAgentId',
            fieldCode: 'fieldCode',
            groupId: 'groupId',
            labels: 'labels',
            modifyType: 'modifyType',
        };
    }
    static types() {
        return {
            appAgentId: 'number',
            fieldCode: 'string',
            groupId: 'string',
            labels: { 'type': 'array', 'itemType': 'string' },
            modifyType: 'string',
        };
    }
}
exports.RosterMetaFieldOptionsUpdateRequest = RosterMetaFieldOptionsUpdateRequest;
class RosterMetaFieldOptionsUpdateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.RosterMetaFieldOptionsUpdateResponseBody = RosterMetaFieldOptionsUpdateResponseBody;
class RosterMetaFieldOptionsUpdateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: RosterMetaFieldOptionsUpdateResponseBody,
        };
    }
}
exports.RosterMetaFieldOptionsUpdateResponse = RosterMetaFieldOptionsUpdateResponse;
class SendIsvCardMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendIsvCardMessageHeaders = SendIsvCardMessageHeaders;
class SendIsvCardMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            agentId: 'agentId',
            bizId: 'bizId',
            messageType: 'messageType',
            receiverUserIds: 'receiverUserIds',
            sceneType: 'sceneType',
            scope: 'scope',
            senderUserId: 'senderUserId',
            valueMap: 'valueMap',
        };
    }
    static types() {
        return {
            agentId: 'number',
            bizId: 'string',
            messageType: 'string',
            receiverUserIds: { 'type': 'array', 'itemType': 'string' },
            sceneType: 'string',
            scope: 'string',
            senderUserId: 'string',
            valueMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.SendIsvCardMessageRequest = SendIsvCardMessageRequest;
class SendIsvCardMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            hrmInteractiveCardSendResult: 'hrmInteractiveCardSendResult',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            hrmInteractiveCardSendResult: SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult,
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.SendIsvCardMessageResponseBody = SendIsvCardMessageResponseBody;
class SendIsvCardMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendIsvCardMessageResponseBody,
        };
    }
}
exports.SendIsvCardMessageResponse = SendIsvCardMessageResponse;
class SolutionTaskInitHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SolutionTaskInitHeaders = SolutionTaskInitHeaders;
class SolutionTaskInitRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            category: 'category',
            claimTime: 'claimTime',
            description: 'description',
            finishTime: 'finishTime',
            outerId: 'outerId',
            status: 'status',
            title: 'title',
            userId: 'userId',
            solutionType: 'solutionType',
        };
    }
    static types() {
        return {
            category: 'string',
            claimTime: 'number',
            description: 'string',
            finishTime: 'number',
            outerId: 'string',
            status: 'string',
            title: 'string',
            userId: 'string',
            solutionType: 'string',
        };
    }
}
exports.SolutionTaskInitRequest = SolutionTaskInitRequest;
class SolutionTaskInitResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.SolutionTaskInitResponseBody = SolutionTaskInitResponseBody;
class SolutionTaskInitResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SolutionTaskInitResponseBody,
        };
    }
}
exports.SolutionTaskInitResponse = SolutionTaskInitResponse;
class SolutionTaskSaveHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SolutionTaskSaveHeaders = SolutionTaskSaveHeaders;
class SolutionTaskSaveRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            claimTime: 'claimTime',
            description: 'description',
            finishTime: 'finishTime',
            outerId: 'outerId',
            solutionInstanceId: 'solutionInstanceId',
            startTime: 'startTime',
            status: 'status',
            taskType: 'taskType',
            templateOuterId: 'templateOuterId',
            title: 'title',
            userId: 'userId',
            solutionType: 'solutionType',
        };
    }
    static types() {
        return {
            claimTime: 'number',
            description: 'string',
            finishTime: 'number',
            outerId: 'string',
            solutionInstanceId: 'string',
            startTime: 'number',
            status: 'string',
            taskType: 'string',
            templateOuterId: 'string',
            title: 'string',
            userId: 'string',
            solutionType: 'string',
        };
    }
}
exports.SolutionTaskSaveRequest = SolutionTaskSaveRequest;
class SolutionTaskSaveResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.SolutionTaskSaveResponseBody = SolutionTaskSaveResponseBody;
class SolutionTaskSaveResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SolutionTaskSaveResponseBody,
        };
    }
}
exports.SolutionTaskSaveResponse = SolutionTaskSaveResponse;
class SyncTaskTemplateHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SyncTaskTemplateHeaders = SyncTaskTemplateHeaders;
class SyncTaskTemplateRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            delete: 'delete',
            des: 'des',
            ext: 'ext',
            name: 'name',
            optUserId: 'optUserId',
            outerId: 'outerId',
            taskScopeVO: 'taskScopeVO',
            taskType: 'taskType',
            solutionType: 'solutionType',
        };
    }
    static types() {
        return {
            delete: 'boolean',
            des: 'string',
            ext: 'string',
            name: 'string',
            optUserId: 'string',
            outerId: 'string',
            taskScopeVO: SyncTaskTemplateRequestTaskScopeVO,
            taskType: 'string',
            solutionType: 'string',
        };
    }
}
exports.SyncTaskTemplateRequest = SyncTaskTemplateRequest;
class SyncTaskTemplateResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.SyncTaskTemplateResponseBody = SyncTaskTemplateResponseBody;
class SyncTaskTemplateResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SyncTaskTemplateResponseBody,
        };
    }
}
exports.SyncTaskTemplateResponse = SyncTaskTemplateResponse;
class UpdateIsvCardMessageHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateIsvCardMessageHeaders = UpdateIsvCardMessageHeaders;
class UpdateIsvCardMessageRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            agentId: 'agentId',
            bizId: 'bizId',
            messageType: 'messageType',
            sceneType: 'sceneType',
            scope: 'scope',
            valueMap: 'valueMap',
        };
    }
    static types() {
        return {
            agentId: 'number',
            bizId: 'string',
            messageType: 'string',
            sceneType: 'string',
            scope: 'string',
            valueMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.UpdateIsvCardMessageRequest = UpdateIsvCardMessageRequest;
class UpdateIsvCardMessageResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            requestId: 'requestId',
            success: 'success',
        };
    }
    static types() {
        return {
            errorCode: 'string',
            errorMsg: 'string',
            requestId: 'string',
            success: 'boolean',
        };
    }
}
exports.UpdateIsvCardMessageResponseBody = UpdateIsvCardMessageResponseBody;
class UpdateIsvCardMessageResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateIsvCardMessageResponseBody,
        };
    }
}
exports.UpdateIsvCardMessageResponse = UpdateIsvCardMessageResponse;
class AddHrmPreentryRequestGroupsSectionsEmpFieldVOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldCode: 'fieldCode',
            value: 'value',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            value: 'string',
        };
    }
}
exports.AddHrmPreentryRequestGroupsSectionsEmpFieldVOList = AddHrmPreentryRequestGroupsSectionsEmpFieldVOList;
class AddHrmPreentryRequestGroupsSections extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            empFieldVOList: 'empFieldVOList',
            oldIndex: 'oldIndex',
        };
    }
    static types() {
        return {
            empFieldVOList: { 'type': 'array', 'itemType': AddHrmPreentryRequestGroupsSectionsEmpFieldVOList },
            oldIndex: 'number',
        };
    }
}
exports.AddHrmPreentryRequestGroupsSections = AddHrmPreentryRequestGroupsSections;
class AddHrmPreentryRequestGroups extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            groupId: 'groupId',
            sections: 'sections',
        };
    }
    static types() {
        return {
            groupId: 'string',
            sections: { 'type': 'array', 'itemType': AddHrmPreentryRequestGroupsSections },
        };
    }
}
exports.AddHrmPreentryRequestGroups = AddHrmPreentryRequestGroups;
class MasterDataQueryRequestQueryParamsConditionList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operate: 'operate',
            value: 'value',
        };
    }
    static types() {
        return {
            operate: 'string',
            value: 'string',
        };
    }
}
exports.MasterDataQueryRequestQueryParamsConditionList = MasterDataQueryRequestQueryParamsConditionList;
class MasterDataQueryRequestQueryParams extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conditionList: 'conditionList',
            fieldCode: 'fieldCode',
            joinType: 'joinType',
        };
    }
    static types() {
        return {
            conditionList: { 'type': 'array', 'itemType': MasterDataQueryRequestQueryParamsConditionList },
            fieldCode: 'string',
            joinType: 'string',
        };
    }
}
exports.MasterDataQueryRequestQueryParams = MasterDataQueryRequestQueryParams;
class MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            key: 'key',
            value: 'value',
        };
    }
    static types() {
        return {
            key: 'string',
            value: 'string',
        };
    }
}
exports.MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO = MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO;
class MasterDataQueryResponseBodyResultViewEntityFieldVOList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldCode: 'fieldCode',
            fieldDataVO: 'fieldDataVO',
            fieldName: 'fieldName',
            fieldType: 'fieldType',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            fieldDataVO: MasterDataQueryResponseBodyResultViewEntityFieldVOListFieldDataVO,
            fieldName: 'string',
            fieldType: 'string',
        };
    }
}
exports.MasterDataQueryResponseBodyResultViewEntityFieldVOList = MasterDataQueryResponseBodyResultViewEntityFieldVOList;
class MasterDataQueryResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            outerId: 'outerId',
            relationId: 'relationId',
            scopeCode: 'scopeCode',
            viewEntityCode: 'viewEntityCode',
            viewEntityFieldVOList: 'viewEntityFieldVOList',
        };
    }
    static types() {
        return {
            outerId: 'string',
            relationId: 'string',
            scopeCode: 'string',
            viewEntityCode: 'string',
            viewEntityFieldVOList: { 'type': 'array', 'itemType': MasterDataQueryResponseBodyResultViewEntityFieldVOList },
        };
    }
}
exports.MasterDataQueryResponseBodyResult = MasterDataQueryResponseBodyResult;
class MasterDataSaveRequestBodyFieldList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            name: 'name',
            valueStr: 'valueStr',
        };
    }
    static types() {
        return {
            name: 'string',
            valueStr: 'string',
        };
    }
}
exports.MasterDataSaveRequestBodyFieldList = MasterDataSaveRequestBodyFieldList;
class MasterDataSaveRequestBodyScope extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            scopeCode: 'scopeCode',
            version: 'version',
        };
    }
    static types() {
        return {
            scopeCode: 'string',
            version: 'number',
        };
    }
}
exports.MasterDataSaveRequestBodyScope = MasterDataSaveRequestBodyScope;
class MasterDataSaveRequestBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizTime: 'bizTime',
            bizUk: 'bizUk',
            entityCode: 'entityCode',
            fieldList: 'fieldList',
            scope: 'scope',
            userId: 'userId',
        };
    }
    static types() {
        return {
            bizTime: 'number',
            bizUk: 'string',
            entityCode: 'string',
            fieldList: { 'type': 'array', 'itemType': MasterDataSaveRequestBodyFieldList },
            scope: MasterDataSaveRequestBodyScope,
            userId: 'string',
        };
    }
}
exports.MasterDataSaveRequestBody = MasterDataSaveRequestBody;
class MasterDataSaveResponseBodyFailResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizUk: 'bizUk',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
            success: 'success',
        };
    }
    static types() {
        return {
            bizUk: 'string',
            errorCode: 'string',
            errorMsg: 'string',
            success: 'boolean',
        };
    }
}
exports.MasterDataSaveResponseBodyFailResult = MasterDataSaveResponseBodyFailResult;
class MasterDataTenantQueyResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasData: 'hasData',
            integrateDataAuth: 'integrateDataAuth',
            name: 'name',
            readAuth: 'readAuth',
            tenantId: 'tenantId',
            type: 'type',
        };
    }
    static types() {
        return {
            hasData: 'boolean',
            integrateDataAuth: 'boolean',
            name: 'string',
            readAuth: 'boolean',
            tenantId: 'number',
            type: 'number',
        };
    }
}
exports.MasterDataTenantQueyResponseBodyResult = MasterDataTenantQueyResponseBodyResult;
class QueryCustomEntryProcessesResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            formDesc: 'formDesc',
            formId: 'formId',
            formName: 'formName',
            shortUrl: 'shortUrl',
        };
    }
    static types() {
        return {
            formDesc: 'string',
            formId: 'string',
            formName: 'string',
            shortUrl: 'string',
        };
    }
}
exports.QueryCustomEntryProcessesResponseBodyList = QueryCustomEntryProcessesResponseBodyList;
class QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptId: 'dept_id',
            deptPath: 'dept_path',
        };
    }
    static types() {
        return {
            deptId: 'number',
            deptPath: 'string',
        };
    }
}
exports.QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList = QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList;
class QueryHrmEmployeeDismissionInfoResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptList: 'deptList',
            handoverUserId: 'handoverUserId',
            lastWorkDay: 'lastWorkDay',
            mainDeptId: 'mainDeptId',
            mainDeptName: 'mainDeptName',
            name: 'name',
            passiveReason: 'passiveReason',
            preStatus: 'preStatus',
            reasonMemo: 'reasonMemo',
            status: 'status',
            userId: 'userId',
            voluntaryReason: 'voluntaryReason',
        };
    }
    static types() {
        return {
            deptList: { 'type': 'array', 'itemType': QueryHrmEmployeeDismissionInfoResponseBodyResultDeptList },
            handoverUserId: 'string',
            lastWorkDay: 'number',
            mainDeptId: 'number',
            mainDeptName: 'string',
            name: 'string',
            passiveReason: { 'type': 'array', 'itemType': 'string' },
            preStatus: 'number',
            reasonMemo: 'string',
            status: 'number',
            userId: 'string',
            voluntaryReason: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryHrmEmployeeDismissionInfoResponseBodyResult = QueryHrmEmployeeDismissionInfoResponseBodyResult;
class QueryJobRanksResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxJobGrade: 'maxJobGrade',
            minJobGrade: 'minJobGrade',
            rankCategoryId: 'rankCategoryId',
            rankCode: 'rankCode',
            rankDescription: 'rankDescription',
            rankId: 'rankId',
            rankName: 'rankName',
        };
    }
    static types() {
        return {
            maxJobGrade: 'number',
            minJobGrade: 'number',
            rankCategoryId: 'string',
            rankCode: 'string',
            rankDescription: 'string',
            rankId: 'string',
            rankName: 'string',
        };
    }
}
exports.QueryJobRanksResponseBodyList = QueryJobRanksResponseBodyList;
class QueryJobsResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobDescription: 'jobDescription',
            jobId: 'jobId',
            jobName: 'jobName',
        };
    }
    static types() {
        return {
            jobDescription: 'string',
            jobId: 'string',
            jobName: 'string',
        };
    }
}
exports.QueryJobsResponseBodyList = QueryJobsResponseBodyList;
class QueryPositionsResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            jobId: 'jobId',
            positionCategoryId: 'positionCategoryId',
            positionDes: 'positionDes',
            positionId: 'positionId',
            positionName: 'positionName',
            rankIdList: 'rankIdList',
            status: 'status',
        };
    }
    static types() {
        return {
            jobId: 'string',
            positionCategoryId: 'string',
            positionDes: 'string',
            positionId: 'string',
            positionName: 'string',
            rankIdList: { 'type': 'array', 'itemType': 'string' },
            status: 'number',
        };
    }
}
exports.QueryPositionsResponseBodyList = QueryPositionsResponseBodyList;
class RosterMetaAvailableFieldListResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            fieldCode: 'fieldCode',
            fieldName: 'fieldName',
            fieldType: 'fieldType',
        };
    }
    static types() {
        return {
            fieldCode: 'string',
            fieldName: 'string',
            fieldType: 'string',
        };
    }
}
exports.RosterMetaAvailableFieldListResponseBodyResult = RosterMetaAvailableFieldListResponseBodyResult;
class SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'bizId',
            errorCode: 'errorCode',
            errorMsg: 'errorMsg',
        };
    }
    static types() {
        return {
            bizId: 'string',
            errorCode: 'string',
            errorMsg: 'string',
        };
    }
}
exports.SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult = SendIsvCardMessageResponseBodyHrmInteractiveCardSendResult;
class SyncTaskTemplateRequestTaskScopeVO extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            deptIds: 'deptIds',
            positionIds: 'positionIds',
            roleIds: 'roleIds',
            userIds: 'userIds',
        };
    }
    static types() {
        return {
            deptIds: { 'type': 'array', 'itemType': 'number' },
            positionIds: { 'type': 'array', 'itemType': 'string' },
            roleIds: { 'type': 'array', 'itemType': 'string' },
            userIds: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.SyncTaskTemplateRequestTaskScopeVO = SyncTaskTemplateRequestTaskScopeVO;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._signatureAlgorithm = "v2";
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addHrmPreentryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.agentId)) {
            body["agentId"] = request.agentId;
        }
        if (!tea_util_1.default.isUnset(request.groups)) {
            body["groups"] = request.groups;
        }
        if (!tea_util_1.default.isUnset(request.mobile)) {
            body["mobile"] = request.mobile;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.needSendPreEntryMsg)) {
            body["needSendPreEntryMsg"] = request.needSendPreEntryMsg;
        }
        if (!tea_util_1.default.isUnset(request.preEntryTime)) {
            body["preEntryTime"] = request.preEntryTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddHrmPreentry",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/preentries`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddHrmPreentryResponse({}));
    }
    async addHrmPreentry(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddHrmPreentryHeaders({});
        return await this.addHrmPreentryWithOptions(request, headers, runtime);
    }
    async deviceMarketManagerWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeviceMarketManager",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/device/market/manager`,
            method: "GET",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeviceMarketManagerResponse({}));
    }
    async deviceMarketManager() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deviceMarketManagerWithOptions(headers, runtime);
    }
    async deviceMarketOrderManagerWithOptions(headers, runtime) {
        let req = new $OpenApi.OpenApiRequest({
            headers: headers,
        });
        let params = new $OpenApi.Params({
            action: "DeviceMarketOrderManager",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/device/market/order/manager`,
            method: "GET",
            authType: "Anonymous",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeviceMarketOrderManagerResponse({}));
    }
    async deviceMarketOrderManager() {
        let runtime = new $Util.RuntimeOptions({});
        let headers = {};
        return await this.deviceMarketOrderManagerWithOptions(headers, runtime);
    }
    async eCertQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "ECertQuery",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/eCerts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new ECertQueryResponse({}));
    }
    async eCertQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new ECertQueryHeaders({});
        return await this.eCertQueryWithOptions(request, headers, runtime);
    }
    async esignRollbackWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            query["optUserId"] = request.optUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "EsignRollback",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/contracts/esign/rollback`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new EsignRollbackResponse({}));
    }
    async esignRollback(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new EsignRollbackHeaders({});
        return await this.esignRollbackWithOptions(request, headers, runtime);
    }
    async hrmProcessRegularWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.operationId)) {
            body["operationId"] = request.operationId;
        }
        if (!tea_util_1.default.isUnset(request.regularDate)) {
            body["regularDate"] = request.regularDate;
        }
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmProcessRegular",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/processes/regulars/become`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmProcessRegularResponse({}));
    }
    async hrmProcessRegular(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmProcessRegularHeaders({});
        return await this.hrmProcessRegularWithOptions(request, headers, runtime);
    }
    async hrmProcessTransferWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.deptIdsAfterTransfer)) {
            body["deptIdsAfterTransfer"] = request.deptIdsAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.jobIdAfterTransfer)) {
            body["jobIdAfterTransfer"] = request.jobIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.mainDeptIdAfterTransfer)) {
            body["mainDeptIdAfterTransfer"] = request.mainDeptIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.operateUserId)) {
            body["operateUserId"] = request.operateUserId;
        }
        if (!tea_util_1.default.isUnset(request.positionIdAfterTransfer)) {
            body["positionIdAfterTransfer"] = request.positionIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.positionLevelAfterTransfer)) {
            body["positionLevelAfterTransfer"] = request.positionLevelAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.positionNameAfterTransfer)) {
            body["positionNameAfterTransfer"] = request.positionNameAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.rankIdAfterTransfer)) {
            body["rankIdAfterTransfer"] = request.rankIdAfterTransfer;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmProcessTransfer",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/processes/transfer`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmProcessTransferResponse({}));
    }
    async hrmProcessTransfer(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmProcessTransferHeaders({});
        return await this.hrmProcessTransferWithOptions(request, headers, runtime);
    }
    async hrmProcessUpdateTerminationInfoWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.dismissionMemo)) {
            body["dismissionMemo"] = request.dismissionMemo;
        }
        if (!tea_util_1.default.isUnset(request.lastWorkDate)) {
            body["lastWorkDate"] = request.lastWorkDate;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "HrmProcessUpdateTerminationInfo",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/processes/employees/terminations`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new HrmProcessUpdateTerminationInfoResponse({}));
    }
    async hrmProcessUpdateTerminationInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new HrmProcessUpdateTerminationInfoHeaders({});
        return await this.hrmProcessUpdateTerminationInfoWithOptions(request, headers, runtime);
    }
    async masterDataQueryWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizUK)) {
            body["bizUK"] = request.bizUK;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            body["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            body["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            body["optUserId"] = request.optUserId;
        }
        if (!tea_util_1.default.isUnset(request.queryParams)) {
            body["queryParams"] = request.queryParams;
        }
        if (!tea_util_1.default.isUnset(request.relationIds)) {
            body["relationIds"] = request.relationIds;
        }
        if (!tea_util_1.default.isUnset(request.scopeCode)) {
            body["scopeCode"] = request.scopeCode;
        }
        if (!tea_util_1.default.isUnset(request.tenantId)) {
            body["tenantId"] = request.tenantId;
        }
        if (!tea_util_1.default.isUnset(request.viewEntityCode)) {
            body["viewEntityCode"] = request.viewEntityCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MasterDataQuery",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masters/datas/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDataQueryResponse({}));
    }
    async masterDataQuery(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDataQueryHeaders({});
        return await this.masterDataQueryWithOptions(request, headers, runtime);
    }
    async masterDataSaveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.tenantId)) {
            query["tenantId"] = request.tenantId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: tea_util_1.default.toArray(request.body),
        });
        let params = new $OpenApi.Params({
            action: "MasterDataSave",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masters/datas/save`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDataSaveResponse({}));
    }
    async masterDataSave(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDataSaveHeaders({});
        return await this.masterDataSaveWithOptions(request, headers, runtime);
    }
    async masterDataTenantQueyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.entityCode)) {
            query["entityCode"] = request.entityCode;
        }
        if (!tea_util_1.default.isUnset(request.scopeCode)) {
            query["scopeCode"] = request.scopeCode;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "MasterDataTenantQuey",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/masters/tenants`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MasterDataTenantQueyResponse({}));
    }
    async masterDataTenantQuey(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MasterDataTenantQueyHeaders({});
        return await this.masterDataTenantQueyWithOptions(request, headers, runtime);
    }
    async queryCustomEntryProcessesWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.operateUserId)) {
            query["operateUserId"] = request.operateUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCustomEntryProcesses",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/customEntryProcesses`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCustomEntryProcessesResponse({}));
    }
    async queryCustomEntryProcesses(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCustomEntryProcessesHeaders({});
        return await this.queryCustomEntryProcessesWithOptions(request, headers, runtime);
    }
    async queryDismissionStaffIdListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryDismissionStaffIdList",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/employees/dismissions`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryDismissionStaffIdListResponse({}));
    }
    async queryDismissionStaffIdList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryDismissionStaffIdListHeaders({});
        return await this.queryDismissionStaffIdListWithOptions(request, headers, runtime);
    }
    async queryHrmEmployeeDismissionInfoWithOptions(tmpReq, headers, runtime) {
        tea_util_1.default.validateModel(tmpReq);
        let request = new QueryHrmEmployeeDismissionInfoShrinkRequest({});
        openapi_util_1.default.convert(tmpReq, request);
        if (!tea_util_1.default.isUnset(tmpReq.userIdList)) {
            request.userIdListShrink = openapi_util_1.default.arrayToStringWithSpecifiedStyle(tmpReq.userIdList, "userIdList", "json");
        }
        let query = {};
        if (!tea_util_1.default.isUnset(request.userIdListShrink)) {
            query["userIdList"] = request.userIdListShrink;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryHrmEmployeeDismissionInfo",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/employees/dimissionInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryHrmEmployeeDismissionInfoResponse({}));
    }
    async queryHrmEmployeeDismissionInfo(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryHrmEmployeeDismissionInfoHeaders({});
        return await this.queryHrmEmployeeDismissionInfoWithOptions(request, headers, runtime);
    }
    async queryJobRanksWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.rankCategoryId)) {
            query["rankCategoryId"] = request.rankCategoryId;
        }
        if (!tea_util_1.default.isUnset(request.rankCode)) {
            query["rankCode"] = request.rankCode;
        }
        if (!tea_util_1.default.isUnset(request.rankName)) {
            query["rankName"] = request.rankName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryJobRanks",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/jobRanks`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryJobRanksResponse({}));
    }
    async queryJobRanks(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryJobRanksHeaders({});
        return await this.queryJobRanksWithOptions(request, headers, runtime);
    }
    async queryJobsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.jobName)) {
            query["jobName"] = request.jobName;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryJobs",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/jobs`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryJobsResponse({}));
    }
    async queryJobs(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryJobsHeaders({});
        return await this.queryJobsWithOptions(request, headers, runtime);
    }
    async queryPositionsWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.deptId)) {
            body["deptId"] = request.deptId;
        }
        if (!tea_util_1.default.isUnset(request.inCategoryIds)) {
            body["inCategoryIds"] = request.inCategoryIds;
        }
        if (!tea_util_1.default.isUnset(request.inPositionIds)) {
            body["inPositionIds"] = request.inPositionIds;
        }
        if (!tea_util_1.default.isUnset(request.positionName)) {
            body["positionName"] = request.positionName;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryPositions",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/positions/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryPositionsResponse({}));
    }
    async queryPositions(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryPositionsHeaders({});
        return await this.queryPositionsWithOptions(request, headers, runtime);
    }
    async rosterMetaAvailableFieldListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appAgentId)) {
            query["appAgentId"] = request.appAgentId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "RosterMetaAvailableFieldList",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/rosters/meta/authorities/fields`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RosterMetaAvailableFieldListResponse({}));
    }
    async rosterMetaAvailableFieldList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RosterMetaAvailableFieldListHeaders({});
        return await this.rosterMetaAvailableFieldListWithOptions(request, headers, runtime);
    }
    async rosterMetaFieldOptionsUpdateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.appAgentId)) {
            query["appAgentId"] = request.appAgentId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.fieldCode)) {
            body["fieldCode"] = request.fieldCode;
        }
        if (!tea_util_1.default.isUnset(request.groupId)) {
            body["groupId"] = request.groupId;
        }
        if (!tea_util_1.default.isUnset(request.labels)) {
            body["labels"] = request.labels;
        }
        if (!tea_util_1.default.isUnset(request.modifyType)) {
            body["modifyType"] = request.modifyType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "RosterMetaFieldOptionsUpdate",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/rosters/meta/fields/options`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new RosterMetaFieldOptionsUpdateResponse({}));
    }
    async rosterMetaFieldOptionsUpdate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new RosterMetaFieldOptionsUpdateHeaders({});
        return await this.rosterMetaFieldOptionsUpdateWithOptions(request, headers, runtime);
    }
    async sendIsvCardMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.agentId)) {
            query["agentId"] = request.agentId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.messageType)) {
            body["messageType"] = request.messageType;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserIds)) {
            body["receiverUserIds"] = request.receiverUserIds;
        }
        if (!tea_util_1.default.isUnset(request.sceneType)) {
            body["sceneType"] = request.sceneType;
        }
        if (!tea_util_1.default.isUnset(request.scope)) {
            body["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            body["senderUserId"] = request.senderUserId;
        }
        if (!tea_util_1.default.isUnset(request.valueMap)) {
            body["valueMap"] = request.valueMap;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendIsvCardMessage",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/cardMessages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendIsvCardMessageResponse({}));
    }
    async sendIsvCardMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendIsvCardMessageHeaders({});
        return await this.sendIsvCardMessageWithOptions(request, headers, runtime);
    }
    async solutionTaskInitWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.solutionType)) {
            query["solutionType"] = request.solutionType;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.category)) {
            body["category"] = request.category;
        }
        if (!tea_util_1.default.isUnset(request.claimTime)) {
            body["claimTime"] = request.claimTime;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.finishTime)) {
            body["finishTime"] = request.finishTime;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SolutionTaskInit",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/solutions/tasks/init`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SolutionTaskInitResponse({}));
    }
    async solutionTaskInit(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SolutionTaskInitHeaders({});
        return await this.solutionTaskInitWithOptions(request, headers, runtime);
    }
    async solutionTaskSaveWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.solutionType)) {
            query["solutionType"] = request.solutionType;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.claimTime)) {
            body["claimTime"] = request.claimTime;
        }
        if (!tea_util_1.default.isUnset(request.description)) {
            body["description"] = request.description;
        }
        if (!tea_util_1.default.isUnset(request.finishTime)) {
            body["finishTime"] = request.finishTime;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.solutionInstanceId)) {
            body["solutionInstanceId"] = request.solutionInstanceId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.taskType)) {
            body["taskType"] = request.taskType;
        }
        if (!tea_util_1.default.isUnset(request.templateOuterId)) {
            body["templateOuterId"] = request.templateOuterId;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SolutionTaskSave",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/solutions/tasks/save`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SolutionTaskSaveResponse({}));
    }
    async solutionTaskSave(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SolutionTaskSaveHeaders({});
        return await this.solutionTaskSaveWithOptions(request, headers, runtime);
    }
    async syncTaskTemplateWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.solutionType)) {
            query["solutionType"] = request.solutionType;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.delete)) {
            body["delete"] = request.delete;
        }
        if (!tea_util_1.default.isUnset(request.des)) {
            body["des"] = request.des;
        }
        if (!tea_util_1.default.isUnset(request.ext)) {
            body["ext"] = request.ext;
        }
        if (!tea_util_1.default.isUnset(request.name)) {
            body["name"] = request.name;
        }
        if (!tea_util_1.default.isUnset(request.optUserId)) {
            body["optUserId"] = request.optUserId;
        }
        if (!tea_util_1.default.isUnset(request.outerId)) {
            body["outerId"] = request.outerId;
        }
        if (!tea_util_1.default.isUnset(request.taskScopeVO)) {
            body["taskScopeVO"] = request.taskScopeVO;
        }
        if (!tea_util_1.default.isUnset(request.taskType)) {
            body["taskType"] = request.taskType;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SyncTaskTemplate",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/solutions/tasks/templates/sync`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SyncTaskTemplateResponse({}));
    }
    async syncTaskTemplate(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SyncTaskTemplateHeaders({});
        return await this.syncTaskTemplateWithOptions(request, headers, runtime);
    }
    async updateIsvCardMessageWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.agentId)) {
            query["agentId"] = request.agentId;
        }
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizId)) {
            body["bizId"] = request.bizId;
        }
        if (!tea_util_1.default.isUnset(request.messageType)) {
            body["messageType"] = request.messageType;
        }
        if (!tea_util_1.default.isUnset(request.sceneType)) {
            body["sceneType"] = request.sceneType;
        }
        if (!tea_util_1.default.isUnset(request.scope)) {
            body["scope"] = request.scope;
        }
        if (!tea_util_1.default.isUnset(request.valueMap)) {
            body["valueMap"] = request.valueMap;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateIsvCardMessage",
            version: "hrm_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/hrm/cardMessages`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateIsvCardMessageResponse({}));
    }
    async updateIsvCardMessage(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateIsvCardMessageHeaders({});
        return await this.updateIsvCardMessageWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map