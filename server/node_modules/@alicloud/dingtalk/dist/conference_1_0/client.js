"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class MemberModelMapValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
            conferenceId: 'conferenceId',
            userNick: 'userNick',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            duration: 'duration',
            attendStatus: 'attendStatus',
            host: 'host',
            coHost: 'coHost',
            outerOrgMember: 'outerOrgMember',
            pstnJoin: 'pstnJoin',
            deviceType: 'deviceType',
        };
    }
    static types() {
        return {
            unionId: 'string',
            conferenceId: 'string',
            userNick: 'string',
            joinTime: 'number',
            leaveTime: 'number',
            duration: 'number',
            attendStatus: 'number',
            host: 'boolean',
            coHost: 'boolean',
            outerOrgMember: 'boolean',
            pstnJoin: 'boolean',
            deviceType: 'string',
        };
    }
}
exports.MemberModelMapValue = MemberModelMapValue;
class CancelScheduleConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CancelScheduleConferenceHeaders = CancelScheduleConferenceHeaders;
class CancelScheduleConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            scheduleConferenceId: 'scheduleConferenceId',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            scheduleConferenceId: 'string',
        };
    }
}
exports.CancelScheduleConferenceRequest = CancelScheduleConferenceRequest;
class CancelScheduleConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.CancelScheduleConferenceResponseBody = CancelScheduleConferenceResponseBody;
class CancelScheduleConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CancelScheduleConferenceResponseBody,
        };
    }
}
exports.CancelScheduleConferenceResponse = CancelScheduleConferenceResponse;
class CloseVideoConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CloseVideoConferenceHeaders = CloseVideoConferenceHeaders;
class CloseVideoConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.CloseVideoConferenceRequest = CloseVideoConferenceRequest;
class CloseVideoConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            cause: 'cause',
            code: 'code',
        };
    }
    static types() {
        return {
            cause: 'string',
            code: 'number',
        };
    }
}
exports.CloseVideoConferenceResponseBody = CloseVideoConferenceResponseBody;
class CloseVideoConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CloseVideoConferenceResponseBody,
        };
    }
}
exports.CloseVideoConferenceResponse = CloseVideoConferenceResponse;
class CohostsHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CohostsHeaders = CohostsHeaders;
class CohostsRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            userList: 'userList',
        };
    }
    static types() {
        return {
            action: 'string',
            userList: { 'type': 'array', 'itemType': CohostsRequestUserList },
        };
    }
}
exports.CohostsRequest = CohostsRequest;
class CohostsResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.CohostsResponseBody = CohostsResponseBody;
class CohostsResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CohostsResponseBody,
        };
    }
}
exports.CohostsResponse = CohostsResponse;
class CreateScheduleConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateScheduleConferenceHeaders = CreateScheduleConferenceHeaders;
class CreateScheduleConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            endTime: 'endTime',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            endTime: 'number',
            startTime: 'number',
            title: 'string',
        };
    }
}
exports.CreateScheduleConferenceRequest = CreateScheduleConferenceRequest;
class CreateScheduleConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            phones: 'phones',
            requestId: 'requestId',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            url: 'url',
        };
    }
    static types() {
        return {
            phones: { 'type': 'array', 'itemType': 'string' },
            requestId: 'string',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            url: 'string',
        };
    }
}
exports.CreateScheduleConferenceResponseBody = CreateScheduleConferenceResponseBody;
class CreateScheduleConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateScheduleConferenceResponseBody,
        };
    }
}
exports.CreateScheduleConferenceResponse = CreateScheduleConferenceResponse;
class CreateVideoConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateVideoConferenceHeaders = CreateVideoConferenceHeaders;
class CreateVideoConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confTitle: 'confTitle',
            inviteCaller: 'inviteCaller',
            inviteUserIds: 'inviteUserIds',
            userId: 'userId',
        };
    }
    static types() {
        return {
            confTitle: 'string',
            inviteCaller: 'boolean',
            inviteUserIds: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
}
exports.CreateVideoConferenceRequest = CreateVideoConferenceRequest;
class CreateVideoConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            conferencePassword: 'conferencePassword',
            externalLinkUrl: 'externalLinkUrl',
            hostPassword: 'hostPassword',
            phoneNumbers: 'phoneNumbers',
            roomCode: 'roomCode',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            conferencePassword: 'string',
            externalLinkUrl: 'string',
            hostPassword: 'string',
            phoneNumbers: { 'type': 'array', 'itemType': 'string' },
            roomCode: 'string',
        };
    }
}
exports.CreateVideoConferenceResponseBody = CreateVideoConferenceResponseBody;
class CreateVideoConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateVideoConferenceResponseBody,
        };
    }
}
exports.CreateVideoConferenceResponse = CreateVideoConferenceResponse;
class FocusHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.FocusHeaders = FocusHeaders;
class FocusRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            action: 'string',
            unionId: 'string',
        };
    }
}
exports.FocusRequest = FocusRequest;
class FocusResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.FocusResponseBody = FocusResponseBody;
class FocusResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: FocusResponseBody,
        };
    }
}
exports.FocusResponse = FocusResponse;
class GetConfDataByConferenceIdHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetConfDataByConferenceIdHeaders = GetConfDataByConferenceIdHeaders;
class GetConfDataByConferenceIdRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            realData: 'realData',
        };
    }
    static types() {
        return {
            realData: 'boolean',
        };
    }
}
exports.GetConfDataByConferenceIdRequest = GetConfDataByConferenceIdRequest;
class GetConfDataByConferenceIdResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            deptName: 'deptName',
            endTime: 'endTime',
            freeType: 'freeType',
            scene: 'scene',
            startTime: 'startTime',
            timeLength: 'timeLength',
            title: 'title',
            userCount: 'userCount',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            deptName: 'string',
            endTime: 'number',
            freeType: 'string',
            scene: 'string',
            startTime: 'number',
            timeLength: 'number',
            title: 'string',
            userCount: 'number',
        };
    }
}
exports.GetConfDataByConferenceIdResponseBody = GetConfDataByConferenceIdResponseBody;
class GetConfDataByConferenceIdResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConfDataByConferenceIdResponseBody,
        };
    }
}
exports.GetConfDataByConferenceIdResponse = GetConfDataByConferenceIdResponse;
class GetConfDetailDataHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetConfDetailDataHeaders = GetConfDetailDataHeaders;
class GetConfDetailDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            nick: 'nick',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
            nick: 'string',
        };
    }
}
exports.GetConfDetailDataRequest = GetConfDetailDataRequest;
class GetConfDetailDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': GetConfDetailDataResponseBodyList },
            nextToken: 'string',
        };
    }
}
exports.GetConfDetailDataResponseBody = GetConfDetailDataResponseBody;
class GetConfDetailDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConfDetailDataResponseBody,
        };
    }
}
exports.GetConfDetailDataResponse = GetConfDetailDataResponse;
class GetHistoryConfDataListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetHistoryConfDataListHeaders = GetHistoryConfDataListHeaders;
class GetHistoryConfDataListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorNike: 'creatorNike',
            endTime: 'endTime',
            freeType: 'freeType',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            realData: 'realData',
            scene: 'scene',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorNike: 'string',
            endTime: 'number',
            freeType: 'string',
            maxResults: 'number',
            nextToken: 'string',
            realData: 'boolean',
            scene: 'string',
            startTime: 'number',
            title: 'string',
        };
    }
}
exports.GetHistoryConfDataListRequest = GetHistoryConfDataListRequest;
class GetHistoryConfDataListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            list: 'list',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            list: { 'type': 'array', 'itemType': GetHistoryConfDataListResponseBodyList },
            nextToken: 'string',
        };
    }
}
exports.GetHistoryConfDataListResponseBody = GetHistoryConfDataListResponseBody;
class GetHistoryConfDataListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetHistoryConfDataListResponseBody,
        };
    }
}
exports.GetHistoryConfDataListResponse = GetHistoryConfDataListResponse;
class GetUserMetricDataHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetUserMetricDataHeaders = GetUserMetricDataHeaders;
class GetUserMetricDataRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            beginTime: 'beginTime',
            endTime: 'endTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            beginTime: 'number',
            endTime: 'number',
            unionId: 'string',
        };
    }
}
exports.GetUserMetricDataRequest = GetUserMetricDataRequest;
class GetUserMetricDataResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            metricDataList: 'metricDataList',
        };
    }
    static types() {
        return {
            metricDataList: { 'type': 'array', 'itemType': GetUserMetricDataResponseBodyMetricDataList },
        };
    }
}
exports.GetUserMetricDataResponseBody = GetUserMetricDataResponseBody;
class GetUserMetricDataResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetUserMetricDataResponseBody,
        };
    }
}
exports.GetUserMetricDataResponse = GetUserMetricDataResponse;
class InviteUsersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.InviteUsersHeaders = InviteUsersHeaders;
class InviteUsersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            inviteeList: 'inviteeList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            inviteeList: { 'type': 'array', 'itemType': InviteUsersRequestInviteeList },
            unionId: 'string',
        };
    }
}
exports.InviteUsersRequest = InviteUsersRequest;
class InviteUsersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.InviteUsersResponseBody = InviteUsersResponseBody;
class InviteUsersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: InviteUsersResponseBody,
        };
    }
}
exports.InviteUsersResponse = InviteUsersResponse;
class KickMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.KickMembersHeaders = KickMembersHeaders;
class KickMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            forbiddenRejoin: 'forbiddenRejoin',
            userList: 'userList',
        };
    }
    static types() {
        return {
            forbiddenRejoin: 'boolean',
            userList: { 'type': 'array', 'itemType': KickMembersRequestUserList },
        };
    }
}
exports.KickMembersRequest = KickMembersRequest;
class KickMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.KickMembersResponseBody = KickMembersResponseBody;
class KickMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: KickMembersResponseBody,
        };
    }
}
exports.KickMembersResponse = KickMembersResponse;
class MuteAllHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MuteAllHeaders = MuteAllHeaders;
class MuteAllRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            forceMute: 'forceMute',
        };
    }
    static types() {
        return {
            action: 'string',
            forceMute: 'boolean',
        };
    }
}
exports.MuteAllRequest = MuteAllRequest;
class MuteAllResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.MuteAllResponseBody = MuteAllResponseBody;
class MuteAllResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MuteAllResponseBody,
        };
    }
}
exports.MuteAllResponse = MuteAllResponse;
class MuteMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.MuteMembersHeaders = MuteMembersHeaders;
class MuteMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            action: 'action',
            userList: 'userList',
        };
    }
    static types() {
        return {
            action: 'string',
            userList: { 'type': 'array', 'itemType': MuteMembersRequestUserList },
        };
    }
}
exports.MuteMembersRequest = MuteMembersRequest;
class MuteMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.MuteMembersResponseBody = MuteMembersResponseBody;
class MuteMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: MuteMembersResponseBody,
        };
    }
}
exports.MuteMembersResponse = MuteMembersResponse;
class QueryCloudRecordTextHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCloudRecordTextHeaders = QueryCloudRecordTextHeaders;
class QueryCloudRecordTextRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            direction: 'direction',
            maxResults: 'maxResults',
            nextToken: 'nextToken',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            direction: 'string',
            maxResults: 'number',
            nextToken: 'number',
            startTime: 'number',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordTextRequest = QueryCloudRecordTextRequest;
class QueryCloudRecordTextResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            hasMore: 'hasMore',
            paragraphList: 'paragraphList',
        };
    }
    static types() {
        return {
            hasMore: 'boolean',
            paragraphList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphList },
        };
    }
}
exports.QueryCloudRecordTextResponseBody = QueryCloudRecordTextResponseBody;
class QueryCloudRecordTextResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordTextResponseBody,
        };
    }
}
exports.QueryCloudRecordTextResponse = QueryCloudRecordTextResponse;
class QueryCloudRecordVideoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCloudRecordVideoHeaders = QueryCloudRecordVideoHeaders;
class QueryCloudRecordVideoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordVideoRequest = QueryCloudRecordVideoRequest;
class QueryCloudRecordVideoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            videoList: 'videoList',
        };
    }
    static types() {
        return {
            videoList: { 'type': 'array', 'itemType': QueryCloudRecordVideoResponseBodyVideoList },
        };
    }
}
exports.QueryCloudRecordVideoResponseBody = QueryCloudRecordVideoResponseBody;
class QueryCloudRecordVideoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordVideoResponseBody,
        };
    }
}
exports.QueryCloudRecordVideoResponse = QueryCloudRecordVideoResponse;
class QueryCloudRecordVideoPlayInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoHeaders = QueryCloudRecordVideoPlayInfoHeaders;
class QueryCloudRecordVideoPlayInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mediaId: 'mediaId',
            regionId: 'regionId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mediaId: 'string',
            regionId: 'string',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoRequest = QueryCloudRecordVideoPlayInfoRequest;
class QueryCloudRecordVideoPlayInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            fileSize: 'fileSize',
            mp4FileUrl: 'mp4FileUrl',
            playUrl: 'playUrl',
            status: 'status',
        };
    }
    static types() {
        return {
            duration: 'number',
            fileSize: 'number',
            mp4FileUrl: 'string',
            playUrl: 'string',
            status: 'number',
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoResponseBody = QueryCloudRecordVideoPlayInfoResponseBody;
class QueryCloudRecordVideoPlayInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryCloudRecordVideoPlayInfoResponseBody,
        };
    }
}
exports.QueryCloudRecordVideoPlayInfoResponse = QueryCloudRecordVideoPlayInfoResponse;
class QueryConferenceInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryConferenceInfoHeaders = QueryConferenceInfoHeaders;
class QueryConferenceInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            confInfo: 'confInfo',
        };
    }
    static types() {
        return {
            confInfo: QueryConferenceInfoResponseBodyConfInfo,
        };
    }
}
exports.QueryConferenceInfoResponseBody = QueryConferenceInfoResponseBody;
class QueryConferenceInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceInfoResponseBody,
        };
    }
}
exports.QueryConferenceInfoResponse = QueryConferenceInfoResponse;
class QueryConferenceInfoBatchHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryConferenceInfoBatchHeaders = QueryConferenceInfoBatchHeaders;
class QueryConferenceInfoBatchRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceIdList: 'conferenceIdList',
        };
    }
    static types() {
        return {
            conferenceIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryConferenceInfoBatchRequest = QueryConferenceInfoBatchRequest;
class QueryConferenceInfoBatchResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            infos: 'infos',
        };
    }
    static types() {
        return {
            infos: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfos },
        };
    }
}
exports.QueryConferenceInfoBatchResponseBody = QueryConferenceInfoBatchResponseBody;
class QueryConferenceInfoBatchResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceInfoBatchResponseBody,
        };
    }
}
exports.QueryConferenceInfoBatchResponse = QueryConferenceInfoBatchResponse;
class QueryConferenceMembersHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryConferenceMembersHeaders = QueryConferenceMembersHeaders;
class QueryConferenceMembersRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.QueryConferenceMembersRequest = QueryConferenceMembersRequest;
class QueryConferenceMembersResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberModels: 'memberModels',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            memberModels: { 'type': 'array', 'itemType': QueryConferenceMembersResponseBodyMemberModels },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.QueryConferenceMembersResponseBody = QueryConferenceMembersResponseBody;
class QueryConferenceMembersResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryConferenceMembersResponseBody,
        };
    }
}
exports.QueryConferenceMembersResponse = QueryConferenceMembersResponse;
class QueryScheduleConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryScheduleConferenceHeaders = QueryScheduleConferenceHeaders;
class QueryScheduleConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            requestUnionId: 'requestUnionId',
        };
    }
    static types() {
        return {
            requestUnionId: 'string',
        };
    }
}
exports.QueryScheduleConferenceRequest = QueryScheduleConferenceRequest;
class QueryScheduleConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            phones: 'phones',
            requestId: 'requestId',
            roomCode: 'roomCode',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            title: 'title',
            url: 'url',
        };
    }
    static types() {
        return {
            endTime: 'number',
            phones: { 'type': 'array', 'itemType': 'string' },
            requestId: 'string',
            roomCode: 'string',
            scheduleConferenceId: 'string',
            startTime: 'number',
            title: 'string',
            url: 'string',
        };
    }
}
exports.QueryScheduleConferenceResponseBody = QueryScheduleConferenceResponseBody;
class QueryScheduleConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConferenceResponseBody,
        };
    }
}
exports.QueryScheduleConferenceResponse = QueryScheduleConferenceResponse;
class QueryScheduleConferenceInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryScheduleConferenceInfoHeaders = QueryScheduleConferenceInfoHeaders;
class QueryScheduleConferenceInfoRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            maxResults: 'maxResults',
            nextToken: 'nextToken',
        };
    }
    static types() {
        return {
            maxResults: 'number',
            nextToken: 'string',
        };
    }
}
exports.QueryScheduleConferenceInfoRequest = QueryScheduleConferenceInfoRequest;
class QueryScheduleConferenceInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceList: 'conferenceList',
            nextToken: 'nextToken',
            totalCount: 'totalCount',
        };
    }
    static types() {
        return {
            conferenceList: { 'type': 'array', 'itemType': QueryScheduleConferenceInfoResponseBodyConferenceList },
            nextToken: 'string',
            totalCount: 'number',
        };
    }
}
exports.QueryScheduleConferenceInfoResponseBody = QueryScheduleConferenceInfoResponseBody;
class QueryScheduleConferenceInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryScheduleConferenceInfoResponseBody,
        };
    }
}
exports.QueryScheduleConferenceInfoResponse = QueryScheduleConferenceInfoResponse;
class QueryUserOnGoingConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryUserOnGoingConferenceHeaders = QueryUserOnGoingConferenceHeaders;
class QueryUserOnGoingConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            operatorUnionId: 'operatorUnionId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            operatorUnionId: 'string',
            unionId: 'string',
        };
    }
}
exports.QueryUserOnGoingConferenceRequest = QueryUserOnGoingConferenceRequest;
class QueryUserOnGoingConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            memberModelMap: 'memberModelMap',
            onGoingConfIdList: 'onGoingConfIdList',
        };
    }
    static types() {
        return {
            memberModelMap: { 'type': 'map', 'keyType': 'string', 'valueType': MemberModelMapValue },
            onGoingConfIdList: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.QueryUserOnGoingConferenceResponseBody = QueryUserOnGoingConferenceResponseBody;
class QueryUserOnGoingConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryUserOnGoingConferenceResponseBody,
        };
    }
}
exports.QueryUserOnGoingConferenceResponse = QueryUserOnGoingConferenceResponse;
class StartCloudRecordHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StartCloudRecordHeaders = StartCloudRecordHeaders;
class StartCloudRecordRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mode: 'mode',
            smallWindowPosition: 'smallWindowPosition',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            smallWindowPosition: 'string',
            unionId: 'string',
        };
    }
}
exports.StartCloudRecordRequest = StartCloudRecordRequest;
class StartCloudRecordResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
}
exports.StartCloudRecordResponseBody = StartCloudRecordResponseBody;
class StartCloudRecordResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartCloudRecordResponseBody,
        };
    }
}
exports.StartCloudRecordResponse = StartCloudRecordResponse;
class StartStreamOutHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StartStreamOutHeaders = StartStreamOutHeaders;
class StartStreamOutRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            mode: 'mode',
            needHostJoin: 'needHostJoin',
            smallWindowPosition: 'smallWindowPosition',
            streamName: 'streamName',
            streamUrlList: 'streamUrlList',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            mode: 'string',
            needHostJoin: 'boolean',
            smallWindowPosition: 'string',
            streamName: 'string',
            streamUrlList: { 'type': 'array', 'itemType': 'string' },
            unionId: 'string',
        };
    }
}
exports.StartStreamOutRequest = StartStreamOutRequest;
class StartStreamOutResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            failStreamMap: 'failStreamMap',
            successStreamMap: 'successStreamMap',
        };
    }
    static types() {
        return {
            failStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            successStreamMap: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
        };
    }
}
exports.StartStreamOutResponseBody = StartStreamOutResponseBody;
class StartStreamOutResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StartStreamOutResponseBody,
        };
    }
}
exports.StartStreamOutResponse = StartStreamOutResponse;
class StopCloudRecordHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StopCloudRecordHeaders = StopCloudRecordHeaders;
class StopCloudRecordRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.StopCloudRecordRequest = StopCloudRecordRequest;
class StopCloudRecordResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
}
exports.StopCloudRecordResponseBody = StopCloudRecordResponseBody;
class StopCloudRecordResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopCloudRecordResponseBody,
        };
    }
}
exports.StopCloudRecordResponse = StopCloudRecordResponse;
class StopStreamOutHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.StopStreamOutHeaders = StopStreamOutHeaders;
class StopStreamOutRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            stopAllStream: 'stopAllStream',
            streamId: 'streamId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            stopAllStream: 'boolean',
            streamId: 'string',
            unionId: 'string',
        };
    }
}
exports.StopStreamOutRequest = StopStreamOutRequest;
class StopStreamOutResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            code: 'code',
        };
    }
    static types() {
        return {
            code: 'string',
        };
    }
}
exports.StopStreamOutResponseBody = StopStreamOutResponseBody;
class StopStreamOutResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: StopStreamOutResponseBody,
        };
    }
}
exports.StopStreamOutResponse = StopStreamOutResponse;
class UpdateScheduleConferenceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateScheduleConferenceHeaders = UpdateScheduleConferenceHeaders;
class UpdateScheduleConferenceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            creatorUnionId: 'creatorUnionId',
            endTime: 'endTime',
            scheduleConferenceId: 'scheduleConferenceId',
            startTime: 'startTime',
            title: 'title',
        };
    }
    static types() {
        return {
            creatorUnionId: 'string',
            endTime: 'number',
            scheduleConferenceId: 'string',
            startTime: 'number',
            title: 'string',
        };
    }
}
exports.UpdateScheduleConferenceRequest = UpdateScheduleConferenceRequest;
class UpdateScheduleConferenceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.UpdateScheduleConferenceResponseBody = UpdateScheduleConferenceResponseBody;
class UpdateScheduleConferenceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateScheduleConferenceResponseBody,
        };
    }
}
exports.UpdateScheduleConferenceResponse = UpdateScheduleConferenceResponse;
class UpdateVideoConferenceExtInfoHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateVideoConferenceExtInfoHeaders = UpdateVideoConferenceExtInfoHeaders;
class UpdateVideoConferenceExtInfoResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
}
exports.UpdateVideoConferenceExtInfoResponseBody = UpdateVideoConferenceExtInfoResponseBody;
class UpdateVideoConferenceExtInfoResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateVideoConferenceExtInfoResponseBody,
        };
    }
}
exports.UpdateVideoConferenceExtInfoResponse = UpdateVideoConferenceExtInfoResponse;
class UpdateVideoConferenceSettingHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateVideoConferenceSettingHeaders = UpdateVideoConferenceSettingHeaders;
class UpdateVideoConferenceSettingRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            allowUnmuteSelf: 'allowUnmuteSelf',
            autoTransferHost: 'autoTransferHost',
            forbiddenShareScreen: 'forbiddenShareScreen',
            lockConference: 'lockConference',
            muteAll: 'muteAll',
            onlyInternalEmployeesJoin: 'onlyInternalEmployeesJoin',
        };
    }
    static types() {
        return {
            allowUnmuteSelf: 'boolean',
            autoTransferHost: 'boolean',
            forbiddenShareScreen: 'boolean',
            lockConference: 'boolean',
            muteAll: 'boolean',
            onlyInternalEmployeesJoin: 'boolean',
        };
    }
}
exports.UpdateVideoConferenceSettingRequest = UpdateVideoConferenceSettingRequest;
class UpdateVideoConferenceSettingResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            case: 'case',
            code: 'code',
        };
    }
    static types() {
        return {
            case: 'string',
            code: 'string',
        };
    }
}
exports.UpdateVideoConferenceSettingResponseBody = UpdateVideoConferenceSettingResponseBody;
class UpdateVideoConferenceSettingResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateVideoConferenceSettingResponseBody,
        };
    }
}
exports.UpdateVideoConferenceSettingResponse = UpdateVideoConferenceSettingResponse;
class CohostsRequestUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            unionId: 'string',
        };
    }
}
exports.CohostsRequestUserList = CohostsRequestUserList;
class GetConfDetailDataResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            belongOrg: 'belongOrg',
            conferenceId: 'conferenceId',
            deviceType: 'deviceType',
            duration: 'duration',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            networkQuality: 'networkQuality',
            nick: 'nick',
            role: 'role',
            sessionId: 'sessionId',
            status: 'status',
            unionId: 'unionId',
            version: 'version',
        };
    }
    static types() {
        return {
            belongOrg: 'string',
            conferenceId: 'string',
            deviceType: 'string',
            duration: 'number',
            joinTime: 'number',
            leaveTime: 'number',
            networkQuality: 'string',
            nick: 'string',
            role: 'string',
            sessionId: 'string',
            status: 'string',
            unionId: 'string',
            version: 'string',
        };
    }
}
exports.GetConfDetailDataResponseBodyList = GetConfDetailDataResponseBodyList;
class GetHistoryConfDataListResponseBodyList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            deptName: 'deptName',
            endTime: 'endTime',
            freeType: 'freeType',
            scene: 'scene',
            startTime: 'startTime',
            timeLength: 'timeLength',
            title: 'title',
            userCount: 'userCount',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            deptName: 'string',
            endTime: 'number',
            freeType: 'string',
            scene: 'string',
            startTime: 'number',
            timeLength: 'number',
            title: 'string',
            userCount: 'number',
        };
    }
}
exports.GetHistoryConfDataListResponseBodyList = GetHistoryConfDataListResponseBodyList;
class GetUserMetricDataResponseBodyMetricDataList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            audioPlayLevel: 'audioPlayLevel',
            audioRecLevel: 'audioRecLevel',
            audioRecvBitRate: 'audioRecvBitRate',
            audioSendBitRate: 'audioSendBitRate',
            cameraRecvBitRate: 'cameraRecvBitRate',
            cameraRecvFrame: 'cameraRecvFrame',
            cameraRecvResolutionActual: 'cameraRecvResolutionActual',
            cameraSendBitRate: 'cameraSendBitRate',
            cameraSendFrame: 'cameraSendFrame',
            cameraSendResolutionActual: 'cameraSendResolutionActual',
            lostRate: 'lostRate',
            recvBitRate: 'recvBitRate',
            roundTripTime: 'roundTripTime',
            screenRecvBitRate: 'screenRecvBitRate',
            screenRecvFrame: 'screenRecvFrame',
            screenRecvResolutionActual: 'screenRecvResolutionActual',
            screenSendBitRate: 'screenSendBitRate',
            screenSendFrame: 'screenSendFrame',
            screenSendResolutionActual: 'screenSendResolutionActual',
            sendBitRate: 'sendBitRate',
            timestamp: 'timestamp',
        };
    }
    static types() {
        return {
            audioPlayLevel: 'string',
            audioRecLevel: 'string',
            audioRecvBitRate: 'string',
            audioSendBitRate: 'string',
            cameraRecvBitRate: 'string',
            cameraRecvFrame: 'string',
            cameraRecvResolutionActual: 'string',
            cameraSendBitRate: 'string',
            cameraSendFrame: 'string',
            cameraSendResolutionActual: 'string',
            lostRate: 'string',
            recvBitRate: 'string',
            roundTripTime: 'string',
            screenRecvBitRate: 'string',
            screenRecvFrame: 'string',
            screenRecvResolutionActual: 'string',
            screenSendBitRate: 'string',
            screenSendFrame: 'string',
            screenSendResolutionActual: 'string',
            sendBitRate: 'string',
            timestamp: 'number',
        };
    }
}
exports.GetUserMetricDataResponseBodyMetricDataList = GetUserMetricDataResponseBodyMetricDataList;
class InviteUsersRequestInviteeList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            nick: 'nick',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            nick: 'string',
            unionId: 'string',
        };
    }
}
exports.InviteUsersRequestInviteeList = InviteUsersRequestInviteeList;
class KickMembersRequestUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            participantId: 'participantId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            participantId: 'string',
            unionId: 'string',
        };
    }
}
exports.KickMembersRequestUserList = KickMembersRequestUserList;
class MuteMembersRequestUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            participantId: 'participantId',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            participantId: 'string',
            unionId: 'string',
        };
    }
}
exports.MuteMembersRequestUserList = MuteMembersRequestUserList;
class QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            startTime: 'startTime',
            word: 'word',
            wordId: 'wordId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            startTime: 'number',
            word: 'string',
            wordId: 'string',
        };
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList = QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList;
class QueryCloudRecordTextResponseBodyParagraphListSentenceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            sentence: 'sentence',
            startTime: 'startTime',
            unionId: 'unionId',
            wordList: 'wordList',
        };
    }
    static types() {
        return {
            endTime: 'number',
            sentence: 'string',
            startTime: 'number',
            unionId: 'string',
            wordList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceListWordList },
        };
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphListSentenceList = QueryCloudRecordTextResponseBodyParagraphListSentenceList;
class QueryCloudRecordTextResponseBodyParagraphList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            endTime: 'endTime',
            nextTtoken: 'nextTtoken',
            nickName: 'nickName',
            paragraph: 'paragraph',
            recordId: 'recordId',
            sentenceList: 'sentenceList',
            startTime: 'startTime',
            status: 'status',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            endTime: 'number',
            nextTtoken: 'number',
            nickName: 'string',
            paragraph: 'string',
            recordId: 'number',
            sentenceList: { 'type': 'array', 'itemType': QueryCloudRecordTextResponseBodyParagraphListSentenceList },
            startTime: 'number',
            status: 'number',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordTextResponseBodyParagraphList = QueryCloudRecordTextResponseBodyParagraphList;
class QueryCloudRecordVideoResponseBodyVideoList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            duration: 'duration',
            endTime: 'endTime',
            fileSize: 'fileSize',
            mediaId: 'mediaId',
            recordId: 'recordId',
            recordType: 'recordType',
            regionId: 'regionId',
            startTime: 'startTime',
            unionId: 'unionId',
        };
    }
    static types() {
        return {
            duration: 'number',
            endTime: 'number',
            fileSize: 'number',
            mediaId: 'string',
            recordId: 'string',
            recordType: 'number',
            regionId: 'string',
            startTime: 'number',
            unionId: 'string',
        };
    }
}
exports.QueryCloudRecordVideoResponseBodyVideoList = QueryCloudRecordVideoResponseBodyVideoList;
class QueryConferenceInfoResponseBodyConfInfo extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            activeNum: 'activeNum',
            attendNum: 'attendNum',
            confDuration: 'confDuration',
            conferenceId: 'conferenceId',
            creatorId: 'creatorId',
            creatorNick: 'creatorNick',
            endTime: 'endTime',
            externalLinkUrl: 'externalLinkUrl',
            invitedNum: 'invitedNum',
            roomCode: 'roomCode',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            activeNum: 'number',
            attendNum: 'number',
            confDuration: 'number',
            conferenceId: 'string',
            creatorId: 'string',
            creatorNick: 'string',
            endTime: 'number',
            externalLinkUrl: 'string',
            invitedNum: 'number',
            roomCode: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
}
exports.QueryConferenceInfoResponseBodyConfInfo = QueryConferenceInfoResponseBodyConfInfo;
class QueryConferenceInfoBatchResponseBodyInfosUserList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendStatus: 'attendStatus',
            cameraStatus: 'cameraStatus',
            micStatus: 'micStatus',
            nick: 'nick',
            rejectDescription: 'rejectDescription',
            userId: 'userId',
        };
    }
    static types() {
        return {
            attendStatus: 'number',
            cameraStatus: 'number',
            micStatus: 'number',
            nick: 'string',
            rejectDescription: 'string',
            userId: 'string',
        };
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfosUserList = QueryConferenceInfoBatchResponseBodyInfosUserList;
class QueryConferenceInfoBatchResponseBodyInfos extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            mediaStatus: 'mediaStatus',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
            userList: 'userList',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            mediaStatus: 'number',
            startTime: 'number',
            status: 'number',
            title: 'string',
            userList: { 'type': 'array', 'itemType': QueryConferenceInfoBatchResponseBodyInfosUserList },
        };
    }
}
exports.QueryConferenceInfoBatchResponseBodyInfos = QueryConferenceInfoBatchResponseBodyInfos;
class QueryConferenceMembersResponseBodyMemberModels extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            attendStatus: 'attendStatus',
            coHost: 'coHost',
            conferenceId: 'conferenceId',
            duration: 'duration',
            host: 'host',
            joinTime: 'joinTime',
            leaveTime: 'leaveTime',
            outerOrgMember: 'outerOrgMember',
            pstnJoin: 'pstnJoin',
            unionId: 'unionId',
            userNick: 'userNick',
        };
    }
    static types() {
        return {
            attendStatus: 'number',
            coHost: 'boolean',
            conferenceId: 'string',
            duration: 'number',
            host: 'boolean',
            joinTime: 'number',
            leaveTime: 'number',
            outerOrgMember: 'boolean',
            pstnJoin: 'boolean',
            unionId: 'string',
            userNick: 'string',
        };
    }
}
exports.QueryConferenceMembersResponseBodyMemberModels = QueryConferenceMembersResponseBodyMemberModels;
class QueryScheduleConferenceInfoResponseBodyConferenceList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            conferenceId: 'conferenceId',
            endTime: 'endTime',
            roomCode: 'roomCode',
            startTime: 'startTime',
            status: 'status',
            title: 'title',
        };
    }
    static types() {
        return {
            conferenceId: 'string',
            endTime: 'number',
            roomCode: 'string',
            startTime: 'number',
            status: 'number',
            title: 'string',
        };
    }
}
exports.QueryScheduleConferenceInfoResponseBodyConferenceList = QueryScheduleConferenceInfoResponseBodyConferenceList;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async cancelScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CancelScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/cancel`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CancelScheduleConferenceResponse({}));
    }
    async cancelScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CancelScheduleConferenceHeaders({});
        return await this.cancelScheduleConferenceWithOptions(request, headers, runtime);
    }
    async closeVideoConferenceWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "CloseVideoConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "DELETE",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CloseVideoConferenceResponse({}));
    }
    async closeVideoConference(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CloseVideoConferenceHeaders({});
        return await this.closeVideoConferenceWithOptions(conferenceId, request, headers, runtime);
    }
    async cohostsWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Cohosts",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/coHosts/set`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CohostsResponse({}));
    }
    async cohosts(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CohostsHeaders({});
        return await this.cohostsWithOptions(conferenceId, request, headers, runtime);
    }
    async createScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateScheduleConferenceResponse({}));
    }
    async createScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateScheduleConferenceHeaders({});
        return await this.createScheduleConferenceWithOptions(request, headers, runtime);
    }
    async createVideoConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.confTitle)) {
            body["confTitle"] = request.confTitle;
        }
        if (!tea_util_1.default.isUnset(request.inviteCaller)) {
            body["inviteCaller"] = request.inviteCaller;
        }
        if (!tea_util_1.default.isUnset(request.inviteUserIds)) {
            body["inviteUserIds"] = request.inviteUserIds;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateVideoConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateVideoConferenceResponse({}));
    }
    async createVideoConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateVideoConferenceHeaders({});
        return await this.createVideoConferenceWithOptions(request, headers, runtime);
    }
    async focusWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "Focus",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/focus`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new FocusResponse({}));
    }
    async focus(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new FocusHeaders({});
        return await this.focusWithOptions(conferenceId, request, headers, runtime);
    }
    async getConfDataByConferenceIdWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.realData)) {
            query["realData"] = request.realData;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetConfDataByConferenceId",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConfDataByConferenceIdResponse({}));
    }
    async getConfDataByConferenceId(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConfDataByConferenceIdHeaders({});
        return await this.getConfDataByConferenceIdWithOptions(conferenceId, request, headers, runtime);
    }
    async getConfDetailDataWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.nick)) {
            query["nick"] = request.nick;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetConfDetailData",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/details`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConfDetailDataResponse({}));
    }
    async getConfDetailData(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConfDetailDataHeaders({});
        return await this.getConfDetailDataWithOptions(conferenceId, request, headers, runtime);
    }
    async getHistoryConfDataListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.creatorNike)) {
            query["creatorNike"] = request.creatorNike;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.freeType)) {
            query["freeType"] = request.freeType;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.realData)) {
            query["realData"] = request.realData;
        }
        if (!tea_util_1.default.isUnset(request.scene)) {
            query["scene"] = request.scene;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            query["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetHistoryConfDataList",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/histories/dataLists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetHistoryConfDataListResponse({}));
    }
    async getHistoryConfDataList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetHistoryConfDataListHeaders({});
        return await this.getHistoryConfDataListWithOptions(request, headers, runtime);
    }
    async getUserMetricDataWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.beginTime)) {
            query["beginTime"] = request.beginTime;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            query["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetUserMetricData",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/metricDatas`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetUserMetricDataResponse({}));
    }
    async getUserMetricData(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetUserMetricDataHeaders({});
        return await this.getUserMetricDataWithOptions(conferenceId, request, headers, runtime);
    }
    async inviteUsersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.inviteeList)) {
            body["inviteeList"] = request.inviteeList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "InviteUsers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/users/invite`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new InviteUsersResponse({}));
    }
    async inviteUsers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new InviteUsersHeaders({});
        return await this.inviteUsersWithOptions(conferenceId, request, headers, runtime);
    }
    async kickMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.forbiddenRejoin)) {
            body["forbiddenRejoin"] = request.forbiddenRejoin;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "KickMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members/kick`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new KickMembersResponse({}));
    }
    async kickMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new KickMembersHeaders({});
        return await this.kickMembersWithOptions(conferenceId, request, headers, runtime);
    }
    async muteAllWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.forceMute)) {
            body["forceMute"] = request.forceMute;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MuteAll",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/allMembers/mute`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MuteAllResponse({}));
    }
    async muteAll(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MuteAllHeaders({});
        return await this.muteAllWithOptions(conferenceId, request, headers, runtime);
    }
    async muteMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.action)) {
            body["action"] = request.action;
        }
        if (!tea_util_1.default.isUnset(request.userList)) {
            body["userList"] = request.userList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "MuteMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members/mute`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new MuteMembersResponse({}));
    }
    async muteMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new MuteMembersHeaders({});
        return await this.muteMembersWithOptions(conferenceId, request, headers, runtime);
    }
    async queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.direction)) {
            query["direction"] = request.direction;
        }
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            query["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordText",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getTexts`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordTextResponse({}));
    }
    async queryCloudRecordText(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordTextHeaders({});
        return await this.queryCloudRecordTextWithOptions(conferenceId, request, headers, runtime);
    }
    async queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordVideo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/getVideos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordVideoResponse({}));
    }
    async queryCloudRecordVideo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoHeaders({});
        return await this.queryCloudRecordVideoWithOptions(conferenceId, request, headers, runtime);
    }
    async queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.mediaId)) {
            query["mediaId"] = request.mediaId;
        }
        if (!tea_util_1.default.isUnset(request.regionId)) {
            query["regionId"] = request.regionId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryCloudRecordVideoPlayInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/videos/getPlayInfos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryCloudRecordVideoPlayInfoResponse({}));
    }
    async queryCloudRecordVideoPlayInfo(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryCloudRecordVideoPlayInfoHeaders({});
        return await this.queryCloudRecordVideoPlayInfoWithOptions(conferenceId, request, headers, runtime);
    }
    async queryConferenceInfoWithOptions(conferenceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceInfoResponse({}));
    }
    async queryConferenceInfo(conferenceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoHeaders({});
        return await this.queryConferenceInfoWithOptions(conferenceId, headers, runtime);
    }
    async queryConferenceInfoBatchWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.conferenceIdList)) {
            body["conferenceIdList"] = request.conferenceIdList;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceInfoBatch",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceInfoBatchResponse({}));
    }
    async queryConferenceInfoBatch(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceInfoBatchHeaders({});
        return await this.queryConferenceInfoBatchWithOptions(request, headers, runtime);
    }
    async queryConferenceMembersWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryConferenceMembers",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/members`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryConferenceMembersResponse({}));
    }
    async queryConferenceMembers(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryConferenceMembersHeaders({});
        return await this.queryConferenceMembersWithOptions(conferenceId, request, headers, runtime);
    }
    async queryScheduleConferenceWithOptions(scheduleConferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.requestUnionId)) {
            query["requestUnionId"] = request.requestUnionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences/${scheduleConferenceId}/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConferenceResponse({}));
    }
    async queryScheduleConference(scheduleConferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConferenceHeaders({});
        return await this.queryScheduleConferenceWithOptions(scheduleConferenceId, request, headers, runtime);
    }
    async queryScheduleConferenceInfoWithOptions(scheduleConferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.maxResults)) {
            query["maxResults"] = request.maxResults;
        }
        if (!tea_util_1.default.isUnset(request.nextToken)) {
            query["nextToken"] = request.nextToken;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryScheduleConferenceInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/scheduleConferences/${scheduleConferenceId}`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryScheduleConferenceInfoResponse({}));
    }
    async queryScheduleConferenceInfo(scheduleConferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryScheduleConferenceInfoHeaders({});
        return await this.queryScheduleConferenceInfoWithOptions(scheduleConferenceId, request, headers, runtime);
    }
    async queryUserOnGoingConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.operatorUnionId)) {
            query["operatorUnionId"] = request.operatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            query["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryUserOnGoingConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/users/lists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryUserOnGoingConferenceResponse({}));
    }
    async queryUserOnGoingConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryUserOnGoingConferenceHeaders({});
        return await this.queryUserOnGoingConferenceWithOptions(request, headers, runtime);
    }
    async startCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartCloudRecord",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/start`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StartCloudRecordResponse({}));
    }
    async startCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartCloudRecordHeaders({});
        return await this.startCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    async startStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.mode)) {
            body["mode"] = request.mode;
        }
        if (!tea_util_1.default.isUnset(request.needHostJoin)) {
            body["needHostJoin"] = request.needHostJoin;
        }
        if (!tea_util_1.default.isUnset(request.smallWindowPosition)) {
            body["smallWindowPosition"] = request.smallWindowPosition;
        }
        if (!tea_util_1.default.isUnset(request.streamName)) {
            body["streamName"] = request.streamName;
        }
        if (!tea_util_1.default.isUnset(request.streamUrlList)) {
            body["streamUrlList"] = request.streamUrlList;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StartStreamOut",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/start`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StartStreamOutResponse({}));
    }
    async startStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StartStreamOutHeaders({});
        return await this.startStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    async stopCloudRecordWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StopCloudRecord",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/cloudRecords/stop`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StopCloudRecordResponse({}));
    }
    async stopCloudRecord(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopCloudRecordHeaders({});
        return await this.stopCloudRecordWithOptions(conferenceId, request, headers, runtime);
    }
    async stopStreamOutWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.stopAllStream)) {
            body["stopAllStream"] = request.stopAllStream;
        }
        if (!tea_util_1.default.isUnset(request.streamId)) {
            body["streamId"] = request.streamId;
        }
        if (!tea_util_1.default.isUnset(request.unionId)) {
            body["unionId"] = request.unionId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "StopStreamOut",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/streamOuts/stop`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new StopStreamOutResponse({}));
    }
    async stopStreamOut(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new StopStreamOutHeaders({});
        return await this.stopStreamOutWithOptions(conferenceId, request, headers, runtime);
    }
    async updateScheduleConferenceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.creatorUnionId)) {
            body["creatorUnionId"] = request.creatorUnionId;
        }
        if (!tea_util_1.default.isUnset(request.endTime)) {
            body["endTime"] = request.endTime;
        }
        if (!tea_util_1.default.isUnset(request.scheduleConferenceId)) {
            body["scheduleConferenceId"] = request.scheduleConferenceId;
        }
        if (!tea_util_1.default.isUnset(request.startTime)) {
            body["startTime"] = request.startTime;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateScheduleConference",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/scheduleConferences`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateScheduleConferenceResponse({}));
    }
    async updateScheduleConference(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateScheduleConferenceHeaders({});
        return await this.updateScheduleConferenceWithOptions(request, headers, runtime);
    }
    async updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime) {
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
        });
        let params = new $OpenApi.Params({
            action: "UpdateVideoConferenceExtInfo",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}/extInfo`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateVideoConferenceExtInfoResponse({}));
    }
    async updateVideoConferenceExtInfo(conferenceId) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceExtInfoHeaders({});
        return await this.updateVideoConferenceExtInfoWithOptions(conferenceId, headers, runtime);
    }
    async updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.allowUnmuteSelf)) {
            body["allowUnmuteSelf"] = request.allowUnmuteSelf;
        }
        if (!tea_util_1.default.isUnset(request.autoTransferHost)) {
            body["autoTransferHost"] = request.autoTransferHost;
        }
        if (!tea_util_1.default.isUnset(request.forbiddenShareScreen)) {
            body["forbiddenShareScreen"] = request.forbiddenShareScreen;
        }
        if (!tea_util_1.default.isUnset(request.lockConference)) {
            body["lockConference"] = request.lockConference;
        }
        if (!tea_util_1.default.isUnset(request.muteAll)) {
            body["muteAll"] = request.muteAll;
        }
        if (!tea_util_1.default.isUnset(request.onlyInternalEmployeesJoin)) {
            body["onlyInternalEmployeesJoin"] = request.onlyInternalEmployeesJoin;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateVideoConferenceSetting",
            version: "conference_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/conference/videoConferences/${conferenceId}`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateVideoConferenceSettingResponse({}));
    }
    async updateVideoConferenceSetting(conferenceId, request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateVideoConferenceSettingHeaders({});
        return await this.updateVideoConferenceSettingWithOptions(conferenceId, request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map