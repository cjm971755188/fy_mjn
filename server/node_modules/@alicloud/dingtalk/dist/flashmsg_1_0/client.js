"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class PrivateFieldMapValue extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            tipTitle: 'tipTitle',
            isDingSend: 'isDingSend',
            isRead: 'isRead',
            buttonStatus: 'buttonStatus',
            extension: 'extension',
        };
    }
    static types() {
        return {
            tipTitle: 'string',
            isDingSend: 'boolean',
            isRead: 'boolean',
            buttonStatus: 'string',
            extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
        };
    }
}
exports.PrivateFieldMapValue = PrivateFieldMapValue;
class AddPluginRuleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.AddPluginRuleHeaders = AddPluginRuleHeaders;
class AddPluginRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatType: 'chatType',
            code: 'code',
            itemType: 'itemType',
            rules: 'rules',
            userId: 'userId',
        };
    }
    static types() {
        return {
            chatType: 'string',
            code: 'string',
            itemType: 'string',
            rules: { 'type': 'array', 'itemType': AddPluginRuleRequestRules },
            userId: 'string',
        };
    }
}
exports.AddPluginRuleRequest = AddPluginRuleRequest;
class AddPluginRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.AddPluginRuleResponseBody = AddPluginRuleResponseBody;
class AddPluginRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: AddPluginRuleResponseBody,
        };
    }
}
exports.AddPluginRuleResponse = AddPluginRuleResponse;
class DeletePlguinRuleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DeletePlguinRuleHeaders = DeletePlguinRuleHeaders;
class DeletePlguinRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizIdList: 'bizIdList',
            userId: 'userId',
        };
    }
    static types() {
        return {
            bizIdList: { 'type': 'array', 'itemType': 'string' },
            userId: 'string',
        };
    }
}
exports.DeletePlguinRuleRequest = DeletePlguinRuleRequest;
class DeletePlguinRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.DeletePlguinRuleResponseBody = DeletePlguinRuleResponseBody;
class DeletePlguinRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DeletePlguinRuleResponseBody,
        };
    }
}
exports.DeletePlguinRuleResponse = DeletePlguinRuleResponse;
class GetBaseProfileListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetBaseProfileListHeaders = GetBaseProfileListHeaders;
class GetBaseProfileListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            body: 'body',
        };
    }
    static types() {
        return {
            body: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetBaseProfileListRequest = GetBaseProfileListRequest;
class GetBaseProfileListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': GetBaseProfileListResponseBodyResult },
            success: 'boolean',
        };
    }
}
exports.GetBaseProfileListResponseBody = GetBaseProfileListResponseBody;
class GetBaseProfileListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetBaseProfileListResponseBody,
        };
    }
}
exports.GetBaseProfileListResponse = GetBaseProfileListResponse;
class GetConversationHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetConversationHeaders = GetConversationHeaders;
class GetConversationRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            userId: 'string',
        };
    }
}
exports.GetConversationRequest = GetConversationRequest;
class GetConversationResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: GetConversationResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.GetConversationResponseBody = GetConversationResponseBody;
class GetConversationResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetConversationResponseBody,
        };
    }
}
exports.GetConversationResponse = GetConversationResponse;
class GetMemberListHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.GetMemberListHeaders = GetMemberListHeaders;
class GetMemberListRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            openConversationId: 'openConversationId',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
            userId: 'userId',
        };
    }
    static types() {
        return {
            openConversationId: 'string',
            pageNumber: 'number',
            pageSize: 'number',
            userId: 'string',
        };
    }
}
exports.GetMemberListRequest = GetMemberListRequest;
class GetMemberListResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: { 'type': 'array', 'itemType': 'string' },
        };
    }
}
exports.GetMemberListResponseBody = GetMemberListResponseBody;
class GetMemberListResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: GetMemberListResponseBody,
        };
    }
}
exports.GetMemberListResponse = GetMemberListResponse;
class QueryPluginRuleHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.QueryPluginRuleHeaders = QueryPluginRuleHeaders;
class QueryPluginRuleRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            chatType: 'chatType',
            code: 'code',
            itemId: 'itemId',
            itemType: 'itemType',
            pageNumber: 'pageNumber',
            pageSize: 'pageSize',
        };
    }
    static types() {
        return {
            chatType: 'string',
            code: 'string',
            itemId: 'string',
            itemType: 'string',
            pageNumber: 'number',
            pageSize: 'number',
        };
    }
}
exports.QueryPluginRuleRequest = QueryPluginRuleRequest;
class QueryPluginRuleResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: QueryPluginRuleResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.QueryPluginRuleResponseBody = QueryPluginRuleResponseBody;
class QueryPluginRuleResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: QueryPluginRuleResponseBody,
        };
    }
}
exports.QueryPluginRuleResponse = QueryPluginRuleResponse;
class SendDingTipHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendDingTipHeaders = SendDingTipHeaders;
class SendDingTipRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            link: 'link',
            messageId: 'messageId',
            receiverUserId: 'receiverUserId',
            senderUserId: 'senderUserId',
            textContent: 'textContent',
        };
    }
    static types() {
        return {
            extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            link: SendDingTipRequestLink,
            messageId: 'string',
            receiverUserId: { 'type': 'array', 'itemType': 'string' },
            senderUserId: 'string',
            textContent: 'string',
        };
    }
}
exports.SendDingTipRequest = SendDingTipRequest;
class SendDingTipResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            success: 'success',
        };
    }
    static types() {
        return {
            success: 'boolean',
        };
    }
}
exports.SendDingTipResponseBody = SendDingTipResponseBody;
class SendDingTipResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendDingTipResponseBody,
        };
    }
}
exports.SendDingTipResponse = SendDingTipResponse;
class SendMessageTipHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SendMessageTipHeaders = SendMessageTipHeaders;
class SendMessageTipRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            defaultView: 'defaultView',
            messageId: 'messageId',
            openConversationId: 'openConversationId',
            privateFieldMap: 'privateFieldMap',
            publicField: 'publicField',
            receiverUserId: 'receiverUserId',
            senderUserId: 'senderUserId',
        };
    }
    static types() {
        return {
            defaultView: SendMessageTipRequestDefaultView,
            messageId: 'string',
            openConversationId: 'string',
            privateFieldMap: { 'type': 'map', 'keyType': 'string', 'valueType': PrivateFieldMapValue },
            publicField: SendMessageTipRequestPublicField,
            receiverUserId: { 'type': 'array', 'itemType': 'string' },
            senderUserId: 'string',
        };
    }
}
exports.SendMessageTipRequest = SendMessageTipRequest;
class SendMessageTipResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
            success: 'success',
        };
    }
    static types() {
        return {
            result: SendMessageTipResponseBodyResult,
            success: 'boolean',
        };
    }
}
exports.SendMessageTipResponseBody = SendMessageTipResponseBody;
class SendMessageTipResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SendMessageTipResponseBody,
        };
    }
}
exports.SendMessageTipResponse = SendMessageTipResponse;
class AddPluginRuleRequestRules extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            itemId: 'itemId',
            itemName: 'itemName',
        };
    }
    static types() {
        return {
            itemId: 'string',
            itemName: 'string',
        };
    }
}
exports.AddPluginRuleRequestRules = AddPluginRuleRequestRules;
class GetBaseProfileListResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            avatarMediaId: 'avatarMediaId',
            nick: 'nick',
            nickPinyin: 'nickPinyin',
            userId: 'userId',
        };
    }
    static types() {
        return {
            avatarMediaId: 'string',
            nick: 'string',
            nickPinyin: 'string',
            userId: 'string',
        };
    }
}
exports.GetBaseProfileListResponseBodyResult = GetBaseProfileListResponseBodyResult;
class GetConversationResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            memberCount: 'memberCount',
            title: 'title',
        };
    }
    static types() {
        return {
            corpId: 'string',
            memberCount: 'number',
            title: 'string',
        };
    }
}
exports.GetConversationResponseBodyResult = GetConversationResponseBodyResult;
class QueryPluginRuleResponseBodyResultData extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'bizId',
            chatType: 'chatType',
            code: 'code',
            gmtCreate: 'gmtCreate',
            itemId: 'itemId',
            itemName: 'itemName',
            itemType: 'itemType',
        };
    }
    static types() {
        return {
            bizId: 'string',
            chatType: 'string',
            code: 'string',
            gmtCreate: 'string',
            itemId: 'string',
            itemName: 'string',
            itemType: 'string',
        };
    }
}
exports.QueryPluginRuleResponseBodyResultData = QueryPluginRuleResponseBodyResultData;
class QueryPluginRuleResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            data: 'data',
            total: 'total',
        };
    }
    static types() {
        return {
            data: { 'type': 'array', 'itemType': QueryPluginRuleResponseBodyResultData },
            total: 'number',
        };
    }
}
exports.QueryPluginRuleResponseBodyResult = QueryPluginRuleResponseBodyResult;
class SendDingTipRequestLink extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            extension: 'extension',
            linkUrl: 'linkUrl',
            picMediaId: 'picMediaId',
            text: 'text',
        };
    }
    static types() {
        return {
            extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            linkUrl: 'string',
            picMediaId: 'string',
            text: 'string',
        };
    }
}
exports.SendDingTipRequestLink = SendDingTipRequestLink;
class SendMessageTipRequestDefaultView extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            actionName: 'actionName',
            actionUrl: 'actionUrl',
            authCode: 'authCode',
            authMediaId: 'authMediaId',
            cardTitle: 'cardTitle',
            cardTitleColor: 'cardTitleColor',
            desc: 'desc',
            mediaId: 'mediaId',
            needShowUpdateTail: 'needShowUpdateTail',
            summary: 'summary',
            title: 'title',
        };
    }
    static types() {
        return {
            actionName: 'string',
            actionUrl: 'string',
            authCode: 'string',
            authMediaId: 'string',
            cardTitle: 'string',
            cardTitleColor: 'string',
            desc: 'string',
            mediaId: 'string',
            needShowUpdateTail: 'string',
            summary: 'string',
            title: 'string',
        };
    }
}
exports.SendMessageTipRequestDefaultView = SendMessageTipRequestDefaultView;
class SendMessageTipRequestPublicField extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            detailUrl: 'detailUrl',
            durationDesc: 'durationDesc',
            extension: 'extension',
            isExpired: 'isExpired',
            readActionUrl: 'readActionUrl',
            readProgressDesc: 'readProgressDesc',
        };
    }
    static types() {
        return {
            detailUrl: 'string',
            durationDesc: 'string',
            extension: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            isExpired: 'boolean',
            readActionUrl: 'string',
            readProgressDesc: 'string',
        };
    }
}
exports.SendMessageTipRequestPublicField = SendMessageTipRequestPublicField;
class SendMessageTipResponseBodyResult extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            bizId: 'bizId',
            cardInstanceId: 'cardInstanceId',
        };
    }
    static types() {
        return {
            bizId: 'string',
            cardInstanceId: 'string',
        };
    }
}
exports.SendMessageTipResponseBodyResult = SendMessageTipResponseBodyResult;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async addPluginRuleWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.chatType)) {
            body["chatType"] = request.chatType;
        }
        if (!tea_util_1.default.isUnset(request.code)) {
            body["code"] = request.code;
        }
        if (!tea_util_1.default.isUnset(request.itemType)) {
            body["itemType"] = request.itemType;
        }
        if (!tea_util_1.default.isUnset(request.rules)) {
            body["rules"] = request.rules;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "AddPluginRule",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/plugins`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new AddPluginRuleResponse({}));
    }
    async addPluginRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new AddPluginRuleHeaders({});
        return await this.addPluginRuleWithOptions(request, headers, runtime);
    }
    async deletePlguinRuleWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.bizIdList)) {
            body["bizIdList"] = request.bizIdList;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DeletePlguinRule",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/plugins/remove`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DeletePlguinRuleResponse({}));
    }
    async deletePlguinRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DeletePlguinRuleHeaders({});
        return await this.deletePlguinRuleWithOptions(request, headers, runtime);
    }
    async getBaseProfileListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: request.body,
        });
        let params = new $OpenApi.Params({
            action: "GetBaseProfileList",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/users/baseInfos/query`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetBaseProfileListResponse({}));
    }
    async getBaseProfileList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetBaseProfileListHeaders({});
        return await this.getBaseProfileListWithOptions(request, headers, runtime);
    }
    async getConversationWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetConversation",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/conversations/infos`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetConversationResponse({}));
    }
    async getConversation(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetConversationHeaders({});
        return await this.getConversationWithOptions(request, headers, runtime);
    }
    async getMemberListWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            query["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            query["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "GetMemberList",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/conversations/memberIdLists`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new GetMemberListResponse({}));
    }
    async getMemberList(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new GetMemberListHeaders({});
        return await this.getMemberListWithOptions(request, headers, runtime);
    }
    async queryPluginRuleWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let query = {};
        if (!tea_util_1.default.isUnset(request.chatType)) {
            query["chatType"] = request.chatType;
        }
        if (!tea_util_1.default.isUnset(request.code)) {
            query["code"] = request.code;
        }
        if (!tea_util_1.default.isUnset(request.itemId)) {
            query["itemId"] = request.itemId;
        }
        if (!tea_util_1.default.isUnset(request.itemType)) {
            query["itemType"] = request.itemType;
        }
        if (!tea_util_1.default.isUnset(request.pageNumber)) {
            query["pageNumber"] = request.pageNumber;
        }
        if (!tea_util_1.default.isUnset(request.pageSize)) {
            query["pageSize"] = request.pageSize;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            query: openapi_util_1.default.query(query),
        });
        let params = new $OpenApi.Params({
            action: "QueryPluginRule",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/plugins`,
            method: "GET",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new QueryPluginRuleResponse({}));
    }
    async queryPluginRule(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new QueryPluginRuleHeaders({});
        return await this.queryPluginRuleWithOptions(request, headers, runtime);
    }
    async sendDingTipWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.extension)) {
            body["extension"] = request.extension;
        }
        if (!tea_util_1.default.isUnset(request.link)) {
            body["link"] = request.link;
        }
        if (!tea_util_1.default.isUnset(request.messageId)) {
            body["messageId"] = request.messageId;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserId)) {
            body["receiverUserId"] = request.receiverUserId;
        }
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            body["senderUserId"] = request.senderUserId;
        }
        if (!tea_util_1.default.isUnset(request.textContent)) {
            body["textContent"] = request.textContent;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendDingTip",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/ding/messages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendDingTipResponse({}));
    }
    async sendDingTip(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendDingTipHeaders({});
        return await this.sendDingTipWithOptions(request, headers, runtime);
    }
    async sendMessageTipWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.defaultView)) {
            body["defaultView"] = request.defaultView;
        }
        if (!tea_util_1.default.isUnset(request.messageId)) {
            body["messageId"] = request.messageId;
        }
        if (!tea_util_1.default.isUnset(request.openConversationId)) {
            body["openConversationId"] = request.openConversationId;
        }
        if (!tea_util_1.default.isUnset(request.privateFieldMap)) {
            body["privateFieldMap"] = request.privateFieldMap;
        }
        if (!tea_util_1.default.isUnset(request.publicField)) {
            body["publicField"] = request.publicField;
        }
        if (!tea_util_1.default.isUnset(request.receiverUserId)) {
            body["receiverUserId"] = request.receiverUserId;
        }
        if (!tea_util_1.default.isUnset(request.senderUserId)) {
            body["senderUserId"] = request.senderUserId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SendMessageTip",
            version: "flashmsg_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/flashmsg/messages/send`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SendMessageTipResponse({}));
    }
    async sendMessageTip(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SendMessageTipHeaders({});
        return await this.sendMessageTipWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map