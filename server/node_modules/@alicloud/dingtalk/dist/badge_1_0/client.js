"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
// This file is auto-generated, don't edit it
/**
 *
 */
const tea_util_1 = __importStar(require("@alicloud/tea-util")), $Util = tea_util_1;
const gateway_dingtalk_1 = __importDefault(require("@alicloud/gateway-dingtalk"));
const openapi_client_1 = __importStar(require("@alicloud/openapi-client")), $OpenApi = openapi_client_1;
const openapi_util_1 = __importDefault(require("@alicloud/openapi-util"));
const $tea = __importStar(require("@alicloud/tea-typescript"));
class CreateBadgeCodeUserInstanceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateBadgeCodeUserInstanceHeaders = CreateBadgeCodeUserInstanceHeaders;
class CreateBadgeCodeUserInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableTimes: 'availableTimes',
            codeIdentity: 'codeIdentity',
            codeValue: 'codeValue',
            codeValueType: 'codeValueType',
            corpId: 'corpId',
            extInfo: 'extInfo',
            gmtExpired: 'gmtExpired',
            requestId: 'requestId',
            status: 'status',
            userCorpRelationType: 'userCorpRelationType',
            userIdentity: 'userIdentity',
        };
    }
    static types() {
        return {
            availableTimes: { 'type': 'array', 'itemType': CreateBadgeCodeUserInstanceRequestAvailableTimes },
            codeIdentity: 'string',
            codeValue: 'string',
            codeValueType: 'string',
            corpId: 'string',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            gmtExpired: 'string',
            requestId: 'string',
            status: 'string',
            userCorpRelationType: 'string',
            userIdentity: 'string',
        };
    }
}
exports.CreateBadgeCodeUserInstanceRequest = CreateBadgeCodeUserInstanceRequest;
class CreateBadgeCodeUserInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codeDetailUrl: 'codeDetailUrl',
            codeId: 'codeId',
        };
    }
    static types() {
        return {
            codeDetailUrl: 'string',
            codeId: 'string',
        };
    }
}
exports.CreateBadgeCodeUserInstanceResponseBody = CreateBadgeCodeUserInstanceResponseBody;
class CreateBadgeCodeUserInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateBadgeCodeUserInstanceResponseBody,
        };
    }
}
exports.CreateBadgeCodeUserInstanceResponse = CreateBadgeCodeUserInstanceResponse;
class CreateBadgeNotifyHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.CreateBadgeNotifyHeaders = CreateBadgeNotifyHeaders;
class CreateBadgeNotifyRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            content: 'content',
            msgId: 'msgId',
            msgType: 'msgType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            content: 'string',
            msgId: 'string',
            msgType: 'string',
            userId: 'string',
        };
    }
}
exports.CreateBadgeNotifyRequest = CreateBadgeNotifyRequest;
class CreateBadgeNotifyResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'boolean',
        };
    }
}
exports.CreateBadgeNotifyResponseBody = CreateBadgeNotifyResponseBody;
class CreateBadgeNotifyResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: CreateBadgeNotifyResponseBody,
        };
    }
}
exports.CreateBadgeNotifyResponse = CreateBadgeNotifyResponse;
class DecodeBadgeCodeHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.DecodeBadgeCodeHeaders = DecodeBadgeCodeHeaders;
class DecodeBadgeCodeRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            payCode: 'payCode',
            requestId: 'requestId',
        };
    }
    static types() {
        return {
            payCode: 'string',
            requestId: 'string',
        };
    }
}
exports.DecodeBadgeCodeRequest = DecodeBadgeCodeRequest;
class DecodeBadgeCodeResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            alipayCode: 'alipayCode',
            codeId: 'codeId',
            codeIdentity: 'codeIdentity',
            codeType: 'codeType',
            corpId: 'corpId',
            extInfo: 'extInfo',
            outBizId: 'outBizId',
            userCorpRelationType: 'userCorpRelationType',
            userId: 'userId',
        };
    }
    static types() {
        return {
            alipayCode: 'string',
            codeId: 'string',
            codeIdentity: 'string',
            codeType: 'string',
            corpId: 'string',
            extInfo: 'string',
            outBizId: 'string',
            userCorpRelationType: 'string',
            userId: 'string',
        };
    }
}
exports.DecodeBadgeCodeResponseBody = DecodeBadgeCodeResponseBody;
class DecodeBadgeCodeResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: DecodeBadgeCodeResponseBody,
        };
    }
}
exports.DecodeBadgeCodeResponse = DecodeBadgeCodeResponse;
class NotifyBadgeCodePayResultHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.NotifyBadgeCodePayResultHeaders = NotifyBadgeCodePayResultHeaders;
class NotifyBadgeCodePayResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            chargeAmount: 'chargeAmount',
            corpId: 'corpId',
            extInfo: 'extInfo',
            gmtTradeCreate: 'gmtTradeCreate',
            gmtTradeFinish: 'gmtTradeFinish',
            merchantName: 'merchantName',
            payChannelDetailList: 'payChannelDetailList',
            payCode: 'payCode',
            promotionAmount: 'promotionAmount',
            remark: 'remark',
            title: 'title',
            tradeErrorCode: 'tradeErrorCode',
            tradeErrorMsg: 'tradeErrorMsg',
            tradeNo: 'tradeNo',
            tradeStatus: 'tradeStatus',
            userId: 'userId',
        };
    }
    static types() {
        return {
            amount: 'string',
            chargeAmount: 'string',
            corpId: 'string',
            extInfo: 'string',
            gmtTradeCreate: 'string',
            gmtTradeFinish: 'string',
            merchantName: 'string',
            payChannelDetailList: { 'type': 'array', 'itemType': NotifyBadgeCodePayResultRequestPayChannelDetailList },
            payCode: 'string',
            promotionAmount: 'string',
            remark: 'string',
            title: 'string',
            tradeErrorCode: 'string',
            tradeErrorMsg: 'string',
            tradeNo: 'string',
            tradeStatus: 'string',
            userId: 'string',
        };
    }
}
exports.NotifyBadgeCodePayResultRequest = NotifyBadgeCodePayResultRequest;
class NotifyBadgeCodePayResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.NotifyBadgeCodePayResultResponseBody = NotifyBadgeCodePayResultResponseBody;
class NotifyBadgeCodePayResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: NotifyBadgeCodePayResultResponseBody,
        };
    }
}
exports.NotifyBadgeCodePayResultResponse = NotifyBadgeCodePayResultResponse;
class NotifyBadgeCodeRefundResultHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.NotifyBadgeCodeRefundResultHeaders = NotifyBadgeCodeRefundResultHeaders;
class NotifyBadgeCodeRefundResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            gmtRefund: 'gmtRefund',
            payChannelDetailList: 'payChannelDetailList',
            payCode: 'payCode',
            refundAmount: 'refundAmount',
            refundOrderNo: 'refundOrderNo',
            refundPromotionAmount: 'refundPromotionAmount',
            remark: 'remark',
            tradeNo: 'tradeNo',
            userId: 'userId',
        };
    }
    static types() {
        return {
            corpId: 'string',
            gmtRefund: 'string',
            payChannelDetailList: { 'type': 'array', 'itemType': NotifyBadgeCodeRefundResultRequestPayChannelDetailList },
            payCode: 'string',
            refundAmount: 'string',
            refundOrderNo: 'string',
            refundPromotionAmount: 'string',
            remark: 'string',
            tradeNo: 'string',
            userId: 'string',
        };
    }
}
exports.NotifyBadgeCodeRefundResultRequest = NotifyBadgeCodeRefundResultRequest;
class NotifyBadgeCodeRefundResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.NotifyBadgeCodeRefundResultResponseBody = NotifyBadgeCodeRefundResultResponseBody;
class NotifyBadgeCodeRefundResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: NotifyBadgeCodeRefundResultResponseBody,
        };
    }
}
exports.NotifyBadgeCodeRefundResultResponse = NotifyBadgeCodeRefundResultResponse;
class NotifyBadgeCodeVerifyResultHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.NotifyBadgeCodeVerifyResultHeaders = NotifyBadgeCodeVerifyResultHeaders;
class NotifyBadgeCodeVerifyResultRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            corpId: 'corpId',
            payCode: 'payCode',
            remark: 'remark',
            userCorpRelationType: 'userCorpRelationType',
            userIdentity: 'userIdentity',
            verifyEvent: 'verifyEvent',
            verifyLocation: 'verifyLocation',
            verifyNo: 'verifyNo',
            verifyResult: 'verifyResult',
            verifyTime: 'verifyTime',
        };
    }
    static types() {
        return {
            corpId: 'string',
            payCode: 'string',
            remark: 'string',
            userCorpRelationType: 'string',
            userIdentity: 'string',
            verifyEvent: 'string',
            verifyLocation: 'string',
            verifyNo: 'string',
            verifyResult: 'boolean',
            verifyTime: 'string',
        };
    }
}
exports.NotifyBadgeCodeVerifyResultRequest = NotifyBadgeCodeVerifyResultRequest;
class NotifyBadgeCodeVerifyResultResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            result: 'result',
        };
    }
    static types() {
        return {
            result: 'string',
        };
    }
}
exports.NotifyBadgeCodeVerifyResultResponseBody = NotifyBadgeCodeVerifyResultResponseBody;
class NotifyBadgeCodeVerifyResultResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: NotifyBadgeCodeVerifyResultResponseBody,
        };
    }
}
exports.NotifyBadgeCodeVerifyResultResponse = NotifyBadgeCodeVerifyResultResponse;
class SaveBadgeCodeCorpInstanceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.SaveBadgeCodeCorpInstanceHeaders = SaveBadgeCodeCorpInstanceHeaders;
class SaveBadgeCodeCorpInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codeIdentity: 'codeIdentity',
            corpId: 'corpId',
            extInfo: 'extInfo',
            status: 'status',
        };
    }
    static types() {
        return {
            codeIdentity: 'string',
            corpId: 'string',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            status: 'string',
        };
    }
}
exports.SaveBadgeCodeCorpInstanceRequest = SaveBadgeCodeCorpInstanceRequest;
class SaveBadgeCodeCorpInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codeIdentity: 'codeIdentity',
            corpId: 'corpId',
            extInfo: 'extInfo',
            status: 'status',
        };
    }
    static types() {
        return {
            codeIdentity: 'string',
            corpId: 'string',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            status: 'string',
        };
    }
}
exports.SaveBadgeCodeCorpInstanceResponseBody = SaveBadgeCodeCorpInstanceResponseBody;
class SaveBadgeCodeCorpInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: SaveBadgeCodeCorpInstanceResponseBody,
        };
    }
}
exports.SaveBadgeCodeCorpInstanceResponse = SaveBadgeCodeCorpInstanceResponse;
class UpdateBadgeCodeUserInstanceHeaders extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            commonHeaders: 'commonHeaders',
            xAcsDingtalkAccessToken: 'x-acs-dingtalk-access-token',
        };
    }
    static types() {
        return {
            commonHeaders: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            xAcsDingtalkAccessToken: 'string',
        };
    }
}
exports.UpdateBadgeCodeUserInstanceHeaders = UpdateBadgeCodeUserInstanceHeaders;
class UpdateBadgeCodeUserInstanceRequest extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            availableTimes: 'availableTimes',
            codeId: 'codeId',
            codeIdentity: 'codeIdentity',
            codeValue: 'codeValue',
            corpId: 'corpId',
            extInfo: 'extInfo',
            gmtExpired: 'gmtExpired',
            status: 'status',
            userCorpRelationType: 'userCorpRelationType',
            userIdentity: 'userIdentity',
        };
    }
    static types() {
        return {
            availableTimes: { 'type': 'array', 'itemType': UpdateBadgeCodeUserInstanceRequestAvailableTimes },
            codeId: 'string',
            codeIdentity: 'string',
            codeValue: 'string',
            corpId: 'string',
            extInfo: { 'type': 'map', 'keyType': 'string', 'valueType': 'any' },
            gmtExpired: 'string',
            status: 'string',
            userCorpRelationType: 'string',
            userIdentity: 'string',
        };
    }
}
exports.UpdateBadgeCodeUserInstanceRequest = UpdateBadgeCodeUserInstanceRequest;
class UpdateBadgeCodeUserInstanceResponseBody extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            codeId: 'codeId',
        };
    }
    static types() {
        return {
            codeId: 'string',
        };
    }
}
exports.UpdateBadgeCodeUserInstanceResponseBody = UpdateBadgeCodeUserInstanceResponseBody;
class UpdateBadgeCodeUserInstanceResponse extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            headers: 'headers',
            statusCode: 'statusCode',
            body: 'body',
        };
    }
    static types() {
        return {
            headers: { 'type': 'map', 'keyType': 'string', 'valueType': 'string' },
            statusCode: 'number',
            body: UpdateBadgeCodeUserInstanceResponseBody,
        };
    }
}
exports.UpdateBadgeCodeUserInstanceResponse = UpdateBadgeCodeUserInstanceResponse;
class CreateBadgeCodeUserInstanceRequestAvailableTimes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtEnd: 'gmtEnd',
            gmtStart: 'gmtStart',
        };
    }
    static types() {
        return {
            gmtEnd: 'string',
            gmtStart: 'string',
        };
    }
}
exports.CreateBadgeCodeUserInstanceRequestAvailableTimes = CreateBadgeCodeUserInstanceRequestAvailableTimes;
class NotifyBadgeCodePayResultRequestPayChannelDetailListFundToolDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            extInfo: 'extInfo',
            fundToolName: 'fundToolName',
            gmtCreate: 'gmtCreate',
            gmtFinish: 'gmtFinish',
            promotionFundTool: 'promotionFundTool',
        };
    }
    static types() {
        return {
            amount: 'string',
            extInfo: 'string',
            fundToolName: 'string',
            gmtCreate: 'string',
            gmtFinish: 'string',
            promotionFundTool: 'boolean',
        };
    }
}
exports.NotifyBadgeCodePayResultRequestPayChannelDetailListFundToolDetailList = NotifyBadgeCodePayResultRequestPayChannelDetailListFundToolDetailList;
class NotifyBadgeCodePayResultRequestPayChannelDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            fundToolDetailList: 'fundToolDetailList',
            gmtCreate: 'gmtCreate',
            gmtFinish: 'gmtFinish',
            payChannelName: 'payChannelName',
            payChannelOrderNo: 'payChannelOrderNo',
            payChannelType: 'payChannelType',
            promotionAmount: 'promotionAmount',
        };
    }
    static types() {
        return {
            amount: 'string',
            fundToolDetailList: { 'type': 'array', 'itemType': NotifyBadgeCodePayResultRequestPayChannelDetailListFundToolDetailList },
            gmtCreate: 'string',
            gmtFinish: 'string',
            payChannelName: 'string',
            payChannelOrderNo: 'string',
            payChannelType: 'string',
            promotionAmount: 'string',
        };
    }
}
exports.NotifyBadgeCodePayResultRequestPayChannelDetailList = NotifyBadgeCodePayResultRequestPayChannelDetailList;
class NotifyBadgeCodeRefundResultRequestPayChannelDetailListFundToolDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            extInfo: 'extInfo',
            fundToolName: 'fundToolName',
            gmtCreate: 'gmtCreate',
            gmtFinish: 'gmtFinish',
            promotionFundTool: 'promotionFundTool',
        };
    }
    static types() {
        return {
            amount: 'string',
            extInfo: 'string',
            fundToolName: 'string',
            gmtCreate: 'string',
            gmtFinish: 'string',
            promotionFundTool: 'boolean',
        };
    }
}
exports.NotifyBadgeCodeRefundResultRequestPayChannelDetailListFundToolDetailList = NotifyBadgeCodeRefundResultRequestPayChannelDetailListFundToolDetailList;
class NotifyBadgeCodeRefundResultRequestPayChannelDetailList extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            amount: 'amount',
            fundToolDetailList: 'fundToolDetailList',
            payChannelName: 'payChannelName',
            payChannelOrderNo: 'payChannelOrderNo',
            payChannelRefundOrderNo: 'payChannelRefundOrderNo',
            payChannelType: 'payChannelType',
            promotionAmount: 'promotionAmount',
        };
    }
    static types() {
        return {
            amount: 'string',
            fundToolDetailList: { 'type': 'array', 'itemType': NotifyBadgeCodeRefundResultRequestPayChannelDetailListFundToolDetailList },
            payChannelName: 'string',
            payChannelOrderNo: 'string',
            payChannelRefundOrderNo: 'string',
            payChannelType: 'string',
            promotionAmount: 'string',
        };
    }
}
exports.NotifyBadgeCodeRefundResultRequestPayChannelDetailList = NotifyBadgeCodeRefundResultRequestPayChannelDetailList;
class UpdateBadgeCodeUserInstanceRequestAvailableTimes extends $tea.Model {
    constructor(map) {
        super(map);
    }
    static names() {
        return {
            gmtEnd: 'gmtEnd',
            gmtStart: 'gmtStart',
        };
    }
    static types() {
        return {
            gmtEnd: 'string',
            gmtStart: 'string',
        };
    }
}
exports.UpdateBadgeCodeUserInstanceRequestAvailableTimes = UpdateBadgeCodeUserInstanceRequestAvailableTimes;
class Client extends openapi_client_1.default {
    constructor(config) {
        super(config);
        this._client = new gateway_dingtalk_1.default();
        this._spi = this._client;
        this._endpointRule = "";
        if (tea_util_1.default.empty(this._endpoint)) {
            this._endpoint = "api.dingtalk.com";
        }
    }
    async createBadgeCodeUserInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.availableTimes)) {
            body["availableTimes"] = request.availableTimes;
        }
        if (!tea_util_1.default.isUnset(request.codeIdentity)) {
            body["codeIdentity"] = request.codeIdentity;
        }
        if (!tea_util_1.default.isUnset(request.codeValue)) {
            body["codeValue"] = request.codeValue;
        }
        if (!tea_util_1.default.isUnset(request.codeValueType)) {
            body["codeValueType"] = request.codeValueType;
        }
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.extInfo)) {
            body["extInfo"] = request.extInfo;
        }
        if (!tea_util_1.default.isUnset(request.gmtExpired)) {
            body["gmtExpired"] = request.gmtExpired;
        }
        if (!tea_util_1.default.isUnset(request.requestId)) {
            body["requestId"] = request.requestId;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.userCorpRelationType)) {
            body["userCorpRelationType"] = request.userCorpRelationType;
        }
        if (!tea_util_1.default.isUnset(request.userIdentity)) {
            body["userIdentity"] = request.userIdentity;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateBadgeCodeUserInstance",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/codes/userInstances`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateBadgeCodeUserInstanceResponse({}));
    }
    async createBadgeCodeUserInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateBadgeCodeUserInstanceHeaders({});
        return await this.createBadgeCodeUserInstanceWithOptions(request, headers, runtime);
    }
    async createBadgeNotifyWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.content)) {
            body["content"] = request.content;
        }
        if (!tea_util_1.default.isUnset(request.msgId)) {
            body["msgId"] = request.msgId;
        }
        if (!tea_util_1.default.isUnset(request.msgType)) {
            body["msgType"] = request.msgType;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "CreateBadgeNotify",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/notices`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new CreateBadgeNotifyResponse({}));
    }
    async createBadgeNotify(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new CreateBadgeNotifyHeaders({});
        return await this.createBadgeNotifyWithOptions(request, headers, runtime);
    }
    async decodeBadgeCodeWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.payCode)) {
            body["payCode"] = request.payCode;
        }
        if (!tea_util_1.default.isUnset(request.requestId)) {
            body["requestId"] = request.requestId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "DecodeBadgeCode",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/codes/decode`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new DecodeBadgeCodeResponse({}));
    }
    async decodeBadgeCode(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new DecodeBadgeCodeHeaders({});
        return await this.decodeBadgeCodeWithOptions(request, headers, runtime);
    }
    async notifyBadgeCodePayResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.amount)) {
            body["amount"] = request.amount;
        }
        if (!tea_util_1.default.isUnset(request.chargeAmount)) {
            body["chargeAmount"] = request.chargeAmount;
        }
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.extInfo)) {
            body["extInfo"] = request.extInfo;
        }
        if (!tea_util_1.default.isUnset(request.gmtTradeCreate)) {
            body["gmtTradeCreate"] = request.gmtTradeCreate;
        }
        if (!tea_util_1.default.isUnset(request.gmtTradeFinish)) {
            body["gmtTradeFinish"] = request.gmtTradeFinish;
        }
        if (!tea_util_1.default.isUnset(request.merchantName)) {
            body["merchantName"] = request.merchantName;
        }
        if (!tea_util_1.default.isUnset(request.payChannelDetailList)) {
            body["payChannelDetailList"] = request.payChannelDetailList;
        }
        if (!tea_util_1.default.isUnset(request.payCode)) {
            body["payCode"] = request.payCode;
        }
        if (!tea_util_1.default.isUnset(request.promotionAmount)) {
            body["promotionAmount"] = request.promotionAmount;
        }
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.title)) {
            body["title"] = request.title;
        }
        if (!tea_util_1.default.isUnset(request.tradeErrorCode)) {
            body["tradeErrorCode"] = request.tradeErrorCode;
        }
        if (!tea_util_1.default.isUnset(request.tradeErrorMsg)) {
            body["tradeErrorMsg"] = request.tradeErrorMsg;
        }
        if (!tea_util_1.default.isUnset(request.tradeNo)) {
            body["tradeNo"] = request.tradeNo;
        }
        if (!tea_util_1.default.isUnset(request.tradeStatus)) {
            body["tradeStatus"] = request.tradeStatus;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "NotifyBadgeCodePayResult",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/codes/payResults`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new NotifyBadgeCodePayResultResponse({}));
    }
    async notifyBadgeCodePayResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new NotifyBadgeCodePayResultHeaders({});
        return await this.notifyBadgeCodePayResultWithOptions(request, headers, runtime);
    }
    async notifyBadgeCodeRefundResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.gmtRefund)) {
            body["gmtRefund"] = request.gmtRefund;
        }
        if (!tea_util_1.default.isUnset(request.payChannelDetailList)) {
            body["payChannelDetailList"] = request.payChannelDetailList;
        }
        if (!tea_util_1.default.isUnset(request.payCode)) {
            body["payCode"] = request.payCode;
        }
        if (!tea_util_1.default.isUnset(request.refundAmount)) {
            body["refundAmount"] = request.refundAmount;
        }
        if (!tea_util_1.default.isUnset(request.refundOrderNo)) {
            body["refundOrderNo"] = request.refundOrderNo;
        }
        if (!tea_util_1.default.isUnset(request.refundPromotionAmount)) {
            body["refundPromotionAmount"] = request.refundPromotionAmount;
        }
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.tradeNo)) {
            body["tradeNo"] = request.tradeNo;
        }
        if (!tea_util_1.default.isUnset(request.userId)) {
            body["userId"] = request.userId;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "NotifyBadgeCodeRefundResult",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/codes/refundResults`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new NotifyBadgeCodeRefundResultResponse({}));
    }
    async notifyBadgeCodeRefundResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new NotifyBadgeCodeRefundResultHeaders({});
        return await this.notifyBadgeCodeRefundResultWithOptions(request, headers, runtime);
    }
    async notifyBadgeCodeVerifyResultWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.payCode)) {
            body["payCode"] = request.payCode;
        }
        if (!tea_util_1.default.isUnset(request.remark)) {
            body["remark"] = request.remark;
        }
        if (!tea_util_1.default.isUnset(request.userCorpRelationType)) {
            body["userCorpRelationType"] = request.userCorpRelationType;
        }
        if (!tea_util_1.default.isUnset(request.userIdentity)) {
            body["userIdentity"] = request.userIdentity;
        }
        if (!tea_util_1.default.isUnset(request.verifyEvent)) {
            body["verifyEvent"] = request.verifyEvent;
        }
        if (!tea_util_1.default.isUnset(request.verifyLocation)) {
            body["verifyLocation"] = request.verifyLocation;
        }
        if (!tea_util_1.default.isUnset(request.verifyNo)) {
            body["verifyNo"] = request.verifyNo;
        }
        if (!tea_util_1.default.isUnset(request.verifyResult)) {
            body["verifyResult"] = request.verifyResult;
        }
        if (!tea_util_1.default.isUnset(request.verifyTime)) {
            body["verifyTime"] = request.verifyTime;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "NotifyBadgeCodeVerifyResult",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/codes/verifyResults`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new NotifyBadgeCodeVerifyResultResponse({}));
    }
    async notifyBadgeCodeVerifyResult(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new NotifyBadgeCodeVerifyResultHeaders({});
        return await this.notifyBadgeCodeVerifyResultWithOptions(request, headers, runtime);
    }
    async saveBadgeCodeCorpInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.codeIdentity)) {
            body["codeIdentity"] = request.codeIdentity;
        }
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.extInfo)) {
            body["extInfo"] = request.extInfo;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "SaveBadgeCodeCorpInstance",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/codes/corpInstances`,
            method: "POST",
            authType: "AK",
            style: "ROA",
            reqBodyType: "none",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new SaveBadgeCodeCorpInstanceResponse({}));
    }
    async saveBadgeCodeCorpInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new SaveBadgeCodeCorpInstanceHeaders({});
        return await this.saveBadgeCodeCorpInstanceWithOptions(request, headers, runtime);
    }
    async updateBadgeCodeUserInstanceWithOptions(request, headers, runtime) {
        tea_util_1.default.validateModel(request);
        let body = {};
        if (!tea_util_1.default.isUnset(request.availableTimes)) {
            body["availableTimes"] = request.availableTimes;
        }
        if (!tea_util_1.default.isUnset(request.codeId)) {
            body["codeId"] = request.codeId;
        }
        if (!tea_util_1.default.isUnset(request.codeIdentity)) {
            body["codeIdentity"] = request.codeIdentity;
        }
        if (!tea_util_1.default.isUnset(request.codeValue)) {
            body["codeValue"] = request.codeValue;
        }
        if (!tea_util_1.default.isUnset(request.corpId)) {
            body["corpId"] = request.corpId;
        }
        if (!tea_util_1.default.isUnset(request.extInfo)) {
            body["extInfo"] = request.extInfo;
        }
        if (!tea_util_1.default.isUnset(request.gmtExpired)) {
            body["gmtExpired"] = request.gmtExpired;
        }
        if (!tea_util_1.default.isUnset(request.status)) {
            body["status"] = request.status;
        }
        if (!tea_util_1.default.isUnset(request.userCorpRelationType)) {
            body["userCorpRelationType"] = request.userCorpRelationType;
        }
        if (!tea_util_1.default.isUnset(request.userIdentity)) {
            body["userIdentity"] = request.userIdentity;
        }
        let realHeaders = {};
        if (!tea_util_1.default.isUnset(headers.commonHeaders)) {
            realHeaders = headers.commonHeaders;
        }
        if (!tea_util_1.default.isUnset(headers.xAcsDingtalkAccessToken)) {
            realHeaders["x-acs-dingtalk-access-token"] = tea_util_1.default.toJSONString(headers.xAcsDingtalkAccessToken);
        }
        let req = new $OpenApi.OpenApiRequest({
            headers: realHeaders,
            body: openapi_util_1.default.parseToMap(body),
        });
        let params = new $OpenApi.Params({
            action: "UpdateBadgeCodeUserInstance",
            version: "badge_1.0",
            protocol: "HTTP",
            pathname: `/v1.0/badge/codes/userInstances`,
            method: "PUT",
            authType: "AK",
            style: "ROA",
            reqBodyType: "json",
            bodyType: "json",
        });
        return $tea.cast(await this.execute(params, req, runtime), new UpdateBadgeCodeUserInstanceResponse({}));
    }
    async updateBadgeCodeUserInstance(request) {
        let runtime = new $Util.RuntimeOptions({});
        let headers = new UpdateBadgeCodeUserInstanceHeaders({});
        return await this.updateBadgeCodeUserInstanceWithOptions(request, headers, runtime);
    }
}
exports.default = Client;
//# sourceMappingURL=client.js.map